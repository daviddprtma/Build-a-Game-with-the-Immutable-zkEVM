"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
describe("Marketplace Royalty Enforcement", function () {
    this.timeout(300000); // 5 min
    let erc721;
    let operatorAllowlist;
    let mockMarketplace;
    let owner;
    let minter;
    let registrar;
    let royaltyRecipient;
    let buyer;
    let seller;
    const baseURI = "https://baseURI.com/";
    const contractURI = "https://contractURI.com";
    const name = "ERC721Preset";
    const symbol = "EP";
    const royalty = hardhat_1.ethers.BigNumber.from("2000");
    before(async function () {
        // Retrieve accounts
        [owner, minter, registrar, royaltyRecipient, buyer, seller] = await hardhat_1.ethers.getSigners();
        // Deploy operator Allowlist
        const operatorAllowlistFactory = (await hardhat_1.ethers.getContractFactory("OperatorAllowlist"));
        operatorAllowlist = await operatorAllowlistFactory.deploy(owner.address);
        // Deploy ERC721 contract
        const erc721PresetFactory = (await hardhat_1.ethers.getContractFactory("ImmutableERC721MintByID"));
        erc721 = await erc721PresetFactory.deploy(owner.address, name, symbol, baseURI, contractURI, operatorAllowlist.address, royaltyRecipient.address, royalty);
        // Deploy mock marketplace
        const mockMarketplaceFactory = (await hardhat_1.ethers.getContractFactory("MockMarketplace"));
        mockMarketplace = await mockMarketplaceFactory.deploy(erc721.address);
        // Set up roles
        await erc721.connect(owner).grantMinterRole(minter.address);
        await operatorAllowlist.connect(owner).grantRegistrarRole(registrar.address);
    });
    describe("Royalties", function () {
        it("Should set a valid OperatorAllowlist registry", async function () {
            await erc721.connect(owner).setOperatorAllowlistRegistry(operatorAllowlist.address);
            (0, chai_1.expect)(await erc721.operatorAllowlist()).to.be.equal(operatorAllowlist.address);
        });
        it("Should allow a marketplace contract to be Allowlisted", async function () {
            await operatorAllowlist.connect(registrar).addAddressToAllowlist([mockMarketplace.address]);
            (0, chai_1.expect)(await operatorAllowlist.isAllowlisted(mockMarketplace.address)).to.be.equal(true);
        });
        it("Should enforce royalties on a marketplace trade", async function () {
            // Get royalty info
            const salePrice = hardhat_1.ethers.utils.parseEther("1");
            const tokenInfo = await erc721.royaltyInfo(2, salePrice);
            // Mint Nft to seller
            await erc721.connect(minter).mint(seller.address, 1);
            // Approve marketplace
            await erc721.connect(seller).setApprovalForAll(mockMarketplace.address, true);
            // Get pre-trade balances
            const recipientBal = await hardhat_1.ethers.provider.getBalance(royaltyRecipient.address);
            const sellerBal = await hardhat_1.ethers.provider.getBalance(seller.address);
            // Execute trade
            await mockMarketplace.connect(buyer).executeTransferRoyalties(seller.address, buyer.address, 1, salePrice, {
                value: salePrice,
            });
            // Check if buyer recieved NFT
            (0, chai_1.expect)(await erc721.ownerOf(1)).to.be.equal(buyer.address);
            // Check if royalty recipient has increased balance newBal = oldBal + royaltyAmount
            (0, chai_1.expect)(await hardhat_1.ethers.provider.getBalance(royaltyRecipient.address)).to.equal(recipientBal.add(tokenInfo[1]));
            // Check if seller has increased balance newBal = oldBal + (salePrice - royaltyAmount)
            (0, chai_1.expect)(await hardhat_1.ethers.provider.getBalance(seller.address)).to.equal(sellerBal.add(salePrice.sub(tokenInfo[1])));
        });
    });
});
