import globalAxios from 'axios';

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "https://api.sandbox.immutable.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    field;
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null)
        return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || axios.defaults.baseURL || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
const ActivitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (chainName, activityId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getActivity', 'chainName', chainName);
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('getActivity', 'activityId', activityId);
            const localVarPath = `/v1/chains/{chain_name}/activities/{activity_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"activity_id"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities: async (chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listActivities', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/activities`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }
            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {string} chainName The name of chain
         * @param {string} fromUpdatedAt From indexed at including given date
         * @param {string} [toUpdatedAt] To indexed at including given date
         * @param {string} [contractAddress] The contract address of the collection
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityHistory: async (chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listActivityHistory', 'chainName', chainName);
            // verify required parameter 'fromUpdatedAt' is not null or undefined
            assertParamExists('listActivityHistory', 'fromUpdatedAt', fromUpdatedAt);
            const localVarPath = `/v1/chains/{chain_name}/activity-history`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = (toUpdatedAt instanceof Date) ?
                    toUpdatedAt.toISOString() :
                    toUpdatedAt;
            }
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
const ActivitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(chainName, activityId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(chainName, activityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {string} chainName The name of chain
         * @param {string} fromUpdatedAt From indexed at including given date
         * @param {string} [toUpdatedAt] To indexed at including given date
         * @param {string} [contractAddress] The contract address of the collection
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivityHistory(chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivityHistory(chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
const ActivitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActivitiesApiFp(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(requestParameters, options) {
            return localVarFp.getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities(requestParameters, options) {
            return localVarFp.listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {ActivitiesApiListActivityHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityHistory(requestParameters, options) {
            return localVarFp.listActivityHistory(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.toUpdatedAt, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI {
    /**
     * Get a single activity by ID
     * @summary Get a single activity by ID
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivity(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all activities
     * @summary List all activities
     * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivities(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List activities sorted by updated_at timestamp ascending, useful for time based data replication
     * @summary List history of activities
     * @param {ActivitiesApiListActivityHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivityHistory(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivityHistory(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.toUpdatedAt, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ChainsApi - axios parameter creator
 * @export
 */
const ChainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains: async (pageCursor, pageSize, options = {}) => {
            const localVarPath = `/v1/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainsApi - functional programming interface
 * @export
 */
const ChainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChains(pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChains(pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ChainsApi - factory interface
 * @export
 */
const ChainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChainsApiFp(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains(requestParameters = {}, options) {
            return localVarFp.listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
class ChainsApi extends BaseAPI {
    /**
     * List supported chains
     * @summary List supported chains
     * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainsApi
     */
    listChains(requestParameters = {}, options) {
        return ChainsApiFp(this.configuration).listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
const CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getCollection', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getCollection', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {Array<string>} [contractAddress] List of contract addresses to filter by
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listCollections', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner: async (accountAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists('listCollectionsByNFTOwner', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listCollectionsByNFTOwner', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/collections`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata: async (contractAddress, chainName, refreshCollectionMetadataRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'chainName', chainName);
            // verify required parameter 'refreshCollectionMetadataRequest' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'refreshCollectionMetadataRequest', refreshCollectionMetadataRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refreshCollectionMetadataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
const CollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(contractAddress, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {Array<string>} [contractAddress] List of contract addresses to filter by
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
const CollectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CollectionsApiFp(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(requestParameters, options) {
            return localVarFp.getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(requestParameters, options) {
            return localVarFp.listCollections(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner(requestParameters, options) {
            return localVarFp.listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata(requestParameters, options) {
            return localVarFp.refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends BaseAPI {
    /**
     * Get collection by contract address
     * @summary Get collection by contract address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters, options) {
        return CollectionsApiFp(this.configuration).getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all collections
     * @summary List all collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollections(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List collections by NFT owner account address
     * @summary List collections by NFT owner
     * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionsByNFTOwner(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh collection metadata
     * @summary Refresh collection metadata
     * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    refreshCollectionMetadata(requestParameters, options) {
        return CollectionsApiFp(this.configuration).refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MetadataApi - axios parameter creator
 * @export
 */
const MetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (chainName, contractAddress, metadataId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('getMetadata', 'metadataId', metadataId);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/{metadata_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadata: async (chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listMetadata', 'contractAddress', contractAddress);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadataForChain: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listMetadataForChain', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID: async (chainName, contractAddress, refreshMetadataByIDRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('refreshMetadataByID', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('refreshMetadataByID', 'contractAddress', contractAddress);
            // verify required parameter 'refreshMetadataByIDRequest' is not null or undefined
            assertParamExists('refreshMetadataByID', 'refreshMetadataByIDRequest', refreshMetadataByIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/refresh-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refreshMetadataByIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {RefreshNFTMetadataByTokenIDRequest} refreshNFTMetadataByTokenIDRequest the request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadataByTokenID: async (contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('refreshNFTMetadataByTokenID', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('refreshNFTMetadataByTokenID', 'chainName', chainName);
            // verify required parameter 'refreshNFTMetadataByTokenIDRequest' is not null or undefined
            assertParamExists('refreshNFTMetadataByTokenID', 'refreshNFTMetadataByTokenIDRequest', refreshNFTMetadataByTokenIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refreshNFTMetadataByTokenIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetadataApi - functional programming interface
 * @export
 */
const MetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration);
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(chainName, contractAddress, metadataId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(chainName, contractAddress, metadataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetadata(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetadata(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetadataForChain(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetadataForChain(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {RefreshNFTMetadataByTokenIDRequest} refreshNFTMetadataByTokenIDRequest the request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshNFTMetadataByTokenID(contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshNFTMetadataByTokenID(contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MetadataApi - factory interface
 * @export
 */
const MetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetadataApiFp(configuration);
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(requestParameters, options) {
            return localVarFp.getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {MetadataApiListMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadata(requestParameters, options) {
            return localVarFp.listMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {MetadataApiListMetadataForChainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadataForChain(requestParameters, options) {
            return localVarFp.listMetadataForChain(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID(requestParameters, options) {
            return localVarFp.refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {MetadataApiRefreshNFTMetadataByTokenIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadataByTokenID(requestParameters, options) {
            return localVarFp.refreshNFTMetadataByTokenID(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshNFTMetadataByTokenIDRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
class MetadataApi extends BaseAPI {
    /**
     * Get metadata by ID
     * @summary Get metadata by ID
     * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of metadata from the given contract
     * @summary Get a list of metadata from the given contract
     * @param {MetadataApiListMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    listMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).listMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of metadata from the given chain
     * @summary Get a list of metadata from the given chain
     * @param {MetadataApiListMetadataForChainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    listMetadataForChain(requestParameters, options) {
        return MetadataApiFp(this.configuration).listMetadataForChain(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh stacked metadata
     * @summary Refresh stacked metadata
     * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshMetadataByID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh NFT metadata
     * @summary Refresh NFT metadata
     * @param {MetadataApiRefreshNFTMetadataByTokenIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshNFTMetadataByTokenID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshNFTMetadataByTokenID(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshNFTMetadataByTokenIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftOwnersApi - axios parameter creator
 * @export
 */
const NftOwnersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTOwners: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listAllNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/nft-owners`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners: async (contractAddress, tokenId, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listNFTOwners', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('listNFTOwners', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnersByContractAddress: async (contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listOwnersByContractAddress', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listOwnersByContractAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftOwnersApi - functional programming interface
 * @export
 */
const NftOwnersApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftOwnersApiAxiosParamCreator(configuration);
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllNFTOwners(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllNFTOwners(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOwnersByContractAddress(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOwnersByContractAddress(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NftOwnersApi - factory interface
 * @export
 */
const NftOwnersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftOwnersApiFp(configuration);
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {NftOwnersApiListAllNFTOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTOwners(requestParameters, options) {
            return localVarFp.listAllNFTOwners(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners(requestParameters, options) {
            return localVarFp.listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {NftOwnersApiListOwnersByContractAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnersByContractAddress(requestParameters, options) {
            return localVarFp.listOwnersByContractAddress(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftOwnersApi - object-oriented interface
 * @export
 * @class NftOwnersApi
 * @extends {BaseAPI}
 */
class NftOwnersApi extends BaseAPI {
    /**
     * List all NFT owners on a chain
     * @summary List all NFT owners
     * @param {NftOwnersApiListAllNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listAllNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listAllNFTOwners(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFT owners by token ID
     * @summary List NFT owners by token ID
     * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List owners by contract address
     * @summary List owners by contract address
     * @param {NftOwnersApiListOwnersByContractAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listOwnersByContractAddress(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listOwnersByContractAddress(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftsApi - axios parameter creator
 * @export
 */
const NftsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (contractAddress, tokenId, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getNFT', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getNFT', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getNFT', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTs: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listAllNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/nfts`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs: async (contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listNFTs', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress: async (accountAddress, chainName, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists('listNFTsByAccountAddress', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTsByAccountAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/nfts`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftsApi - functional programming interface
 * @export
 */
const NftsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(contractAddress, tokenId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(contractAddress, tokenId, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllNFTs(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllNFTs(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTs(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTs(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NftsApi - factory interface
 * @export
 */
const NftsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftsApiFp(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT(requestParameters, options) {
            return localVarFp.getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {NftsApiListAllNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTs(requestParameters, options) {
            return localVarFp.listAllNFTs(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs(requestParameters, options) {
            return localVarFp.listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress(requestParameters, options) {
            return localVarFp.listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftsApi - object-oriented interface
 * @export
 * @class NftsApi
 * @extends {BaseAPI}
 */
class NftsApi extends BaseAPI {
    /**
     * Get NFT by token ID
     * @summary Get NFT by token ID
     * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    getNFT(requestParameters, options) {
        return NftsApiFp(this.configuration).getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all NFTs on a chain
     * @summary List all NFTs
     * @param {NftsApiListAllNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listAllNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listAllNFTs(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by contract address
     * @summary List NFTs by contract address
     * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by account address
     * @summary List NFTs by account address
     * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTsByAccountAddress(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {string} chainName
         * @param {CancelOrdersRequestBody} cancelOrdersRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders: async (chainName, cancelOrdersRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('cancelOrders', 'chainName', chainName);
            // verify required parameter 'cancelOrdersRequestBody' is not null or undefined
            assertParamExists('cancelOrders', 'cancelOrdersRequestBody', cancelOrdersRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/cancel`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrdersRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (chainName, createListingRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('createListing', 'chainName', chainName);
            // verify required parameter 'createListingRequestBody' is not null or undefined
            assertParamExists('createListing', 'createListingRequestBody', createListingRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createListingRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData: async (chainName, fulfillmentDataRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('fulfillmentData', 'chainName', chainName);
            // verify required parameter 'fulfillmentDataRequest' is not null or undefined
            assertParamExists('fulfillmentData', 'fulfillmentDataRequest', fulfillmentDataRequest);
            const localVarPath = `/v1/chains/{chain_name}/orders/fulfillment-data`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(fulfillmentDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing: async (chainName, listingId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getListing', 'chainName', chainName);
            // verify required parameter 'listingId' is not null or undefined
            assertParamExists('getListing', 'listingId', listingId);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings/{listing_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"listing_id"}}`, encodeURIComponent(String(listingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (chainName, tradeId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getTrade', 'chainName', chainName);
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/chains/{chain_name}/trades/{trade_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatusName} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [accountAddress] The account address of the user who created the listing
         * @param {string} [sellItemMetadataId] The metadata_id of the sell item
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {string} [fromUpdatedAt] From updated at including given date
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {ListListingsSortByEnum} [sortBy] Order field to sort by
         * @param {ListListingsSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings: async (chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listListings', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sellItemContractAddress !== undefined) {
                localVarQueryParameter['sell_item_contract_address'] = sellItemContractAddress;
            }
            if (buyItemContractAddress !== undefined) {
                localVarQueryParameter['buy_item_contract_address'] = buyItemContractAddress;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (sellItemMetadataId !== undefined) {
                localVarQueryParameter['sell_item_metadata_id'] = sellItemMetadataId;
            }
            if (sellItemTokenId !== undefined) {
                localVarQueryParameter['sell_item_token_id'] = sellItemTokenId;
            }
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {ListTradesSortByEnum} [sortBy] Trade field to sort by
         * @param {ListTradesSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listTrades', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/trades`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (fromIndexedAt !== undefined) {
                localVarQueryParameter['from_indexed_at'] = (fromIndexedAt instanceof Date) ?
                    fromIndexedAt.toISOString() :
                    fromIndexedAt;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {string} chainName
         * @param {CancelOrdersRequestBody} cancelOrdersRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrders(chainName, cancelOrdersRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrders(chainName, cancelOrdersRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(chainName, createListingRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(chainName, createListingRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillmentData(chainName, fulfillmentDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillmentData(chainName, fulfillmentDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListing(chainName, listingId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListing(chainName, listingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(chainName, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(chainName, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatusName} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [accountAddress] The account address of the user who created the listing
         * @param {string} [sellItemMetadataId] The metadata_id of the sell item
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {string} [fromUpdatedAt] From updated at including given date
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {ListListingsSortByEnum} [sortBy] Order field to sort by
         * @param {ListListingsSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {ListTradesSortByEnum} [sortBy] Trade field to sort by
         * @param {ListTradesSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {OrdersApiCancelOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders(requestParameters, options) {
            return localVarFp.cancelOrders(requestParameters.chainName, requestParameters.cancelOrdersRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing(requestParameters, options) {
            return localVarFp.createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData(requestParameters, options) {
            return localVarFp.fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing(requestParameters, options) {
            return localVarFp.getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(requestParameters, options) {
            return localVarFp.getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings(requestParameters, options) {
            return localVarFp.listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.accountAddress, requestParameters.sellItemMetadataId, requestParameters.sellItemTokenId, requestParameters.fromUpdatedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(requestParameters, options) {
            return localVarFp.listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.fromIndexedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends BaseAPI {
    /**
     * Cancel one or more orders
     * @summary Cancel one or more orders
     * @param {OrdersApiCancelOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    cancelOrders(requestParameters, options) {
        return OrdersApiFp(this.configuration).cancelOrders(requestParameters.chainName, requestParameters.cancelOrdersRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a listing
     * @summary Create a listing
     * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @summary Retrieve fulfillment data for orders
     * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    fulfillmentData(requestParameters, options) {
        return OrdersApiFp(this.configuration).fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single listing by ID
     * @summary Get a single listing by ID
     * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single trade by ID
     * @summary Get a single trade by ID
     * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getTrade(requestParameters, options) {
        return OrdersApiFp(this.configuration).getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all listings
     * @summary List all listings
     * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listListings(requestParameters, options) {
        return OrdersApiFp(this.configuration).listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.accountAddress, requestParameters.sellItemMetadataId, requestParameters.sellItemTokenId, requestParameters.fromUpdatedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all trades
     * @summary List all trades
     * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listTrades(requestParameters, options) {
        return OrdersApiFp(this.configuration).listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.fromIndexedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
const ListListingsSortByEnum$1 = {
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at',
    BuyItemAmount: 'buy_item_amount'
};
/**
 * @export
 */
const ListListingsSortDirectionEnum$1 = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * @export
 */
const ListTradesSortByEnum$1 = {
    IndexedAt: 'indexed_at'
};
/**
 * @export
 */
const ListTradesSortDirectionEnum$1 = {
    Asc: 'asc',
    Desc: 'desc'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * PassportApi - axios parameter creator
 * @export
 */
const PassportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {string} chainName
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress: async (chainName, createCounterfactualAddressRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('createCounterfactualAddress', 'chainName', chainName);
            // verify required parameter 'createCounterfactualAddressRequest' is not null or undefined
            assertParamExists('createCounterfactualAddress', 'createCounterfactualAddressRequest', createCounterfactualAddressRequest);
            const localVarPath = `/v1/chains/{chain_name}/passport/counterfactual-address`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createCounterfactualAddressRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequestDeprecated} createCounterfactualAddressRequestDeprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddressDeprecated: async (createCounterfactualAddressRequestDeprecated, options = {}) => {
            // verify required parameter 'createCounterfactualAddressRequestDeprecated' is not null or undefined
            assertParamExists('createCounterfactualAddressDeprecated', 'createCounterfactualAddressRequestDeprecated', createCounterfactualAddressRequestDeprecated);
            const localVarPath = `/passport-mr/v1/counterfactual-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createCounterfactualAddressRequestDeprecated, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {string} chainName
         * @param {string} contractAddress contract address
         * @param {string} methodId method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAbi: async (chainName, contractAddress, methodId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getContractAbi', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getContractAbi', 'contractAddress', contractAddress);
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('getContractAbi', 'methodId', methodId);
            const localVarPath = `/v1/chains/{chain_name}/passport/transaction-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (methodId !== undefined) {
                localVarQueryParameter['method_id'] = methodId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {string} chainName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses: async (userId, chainName, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getLinkedAddresses', 'userId', userId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getLinkedAddresses', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/passport/users/{user_id}/linked-addresses`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddressesDeprecated: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getLinkedAddressesDeprecated', 'userId', userId);
            const localVarPath = `/passport-mr/v1/users/{userId}/linked-addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassportApi - functional programming interface
 * @export
 */
const PassportApiFp = function (configuration) {
    const localVarAxiosParamCreator = PassportApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {string} chainName
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddress(chainName, createCounterfactualAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddress(chainName, createCounterfactualAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequestDeprecated} createCounterfactualAddressRequestDeprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddressDeprecated(createCounterfactualAddressRequestDeprecated, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddressDeprecated(createCounterfactualAddressRequestDeprecated, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {string} chainName
         * @param {string} contractAddress contract address
         * @param {string} methodId method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractAbi(chainName, contractAddress, methodId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractAbi(chainName, contractAddress, methodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {string} chainName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddresses(userId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddresses(userId, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddressesDeprecated(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddressesDeprecated(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PassportApi - factory interface
 * @export
 */
const PassportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PassportApiFp(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress(requestParameters, options) {
            return localVarFp.createCounterfactualAddress(requestParameters.chainName, requestParameters.createCounterfactualAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {PassportApiCreateCounterfactualAddressDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddressDeprecated(requestParameters, options) {
            return localVarFp.createCounterfactualAddressDeprecated(requestParameters.createCounterfactualAddressRequestDeprecated, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {PassportApiGetContractAbiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAbi(requestParameters, options) {
            return localVarFp.getContractAbi(requestParameters.chainName, requestParameters.contractAddress, requestParameters.methodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses(requestParameters, options) {
            return localVarFp.getLinkedAddresses(requestParameters.userId, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {PassportApiGetLinkedAddressesDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddressesDeprecated(requestParameters, options) {
            return localVarFp.getLinkedAddressesDeprecated(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PassportApi - object-oriented interface
 * @export
 * @class PassportApi
 * @extends {BaseAPI}
 */
class PassportApi extends BaseAPI {
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddress(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddress(requestParameters.chainName, requestParameters.createCounterfactualAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddressDeprecated(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddressDeprecated(requestParameters.createCounterfactualAddressRequestDeprecated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a contract abi by contract address and method id
     * @summary Get a contract abi
     * @param {PassportApiGetContractAbiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getContractAbi(requestParameters, options) {
        return PassportApiFp(this.configuration).getContractAbi(requestParameters.chainName, requestParameters.contractAddress, requestParameters.methodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddresses(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddresses(requestParameters.userId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddressesDeprecated(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddressesDeprecated(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getERC20Token', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getERC20Token', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listERC20Tokens', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getERC20Token(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getERC20Token(contractAddress, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listERC20Tokens(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listERC20Tokens(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TokensApiFp(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token(requestParameters, options) {
            return localVarFp.getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens(requestParameters, options) {
            return localVarFp.listERC20Tokens(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends BaseAPI {
    /**
     * Get single ERC20 token
     * @summary Get single ERC20 token
     * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getERC20Token(requestParameters, options) {
        return TokensApiFp(this.configuration).getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List ERC20 tokens
     * @summary List ERC20 tokens
     * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listERC20Tokens(requestParameters, options) {
        return TokensApiFp(this.configuration).listERC20Tokens(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError400AllOfCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError401AllOfCodeEnum = {
    UnauthorisedRequest: 'UNAUTHORISED_REQUEST'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError403AllOfCodeEnum = {
    AuthenticationError: 'AUTHENTICATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError404AllOfCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError429AllOfCodeEnum = {
    TooManyRequestsError: 'TOO_MANY_REQUESTS_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError500AllOfCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError501AllOfCodeEnum = {
    NotImplementedError: 'NOT_IMPLEMENTED_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ActiveOrderStatusNameEnum = {
    Active: 'ACTIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The activity type
 * @export
 * @enum {string}
 */
const ActivityType = {
    Mint: 'mint',
    Burn: 'burn',
    Transfer: 'transfer',
    Sale: 'sale',
    Deposit: 'deposit',
    Withdrawal: 'withdrawal'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const CancelledOrderStatusNameEnum = {
    Cancelled: 'CANCELLED'
};
const CancelledOrderStatusCancellationTypeEnum = {
    OnChain: 'ON_CHAIN',
    OffChain: 'OFF_CHAIN'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The collection contract type
 * @export
 * @enum {string}
 */
const CollectionContractType = {
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC1155ItemTypeEnum = {
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC20ItemTypeEnum = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC721ItemTypeEnum = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ExpiredOrderStatusNameEnum = {
    Expired: 'EXPIRED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FailedOrderCancellationReasonCodeEnum = {
    Filled: 'FILLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FeeTypeEnum = {
    Royalty: 'ROYALTY',
    MakerEcosystem: 'MAKER_ECOSYSTEM',
    TakerEcosystem: 'TAKER_ECOSYSTEM',
    Protocol: 'PROTOCOL'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FilledOrderStatusNameEnum = {
    Filled: 'FILLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const GetContractAbiResTransactionTypeEnum = {
    Erc20Approve: 'ERC20_APPROVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const InactiveOrderStatusNameEnum = {
    Inactive: 'INACTIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The status of the mint request
 * @export
 * @enum {string}
 */
const MintRequestStatus = {
    Pending: 'pending',
    Succeeded: 'succeeded',
    Failed: 'failed'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for an NFT
 * @export
 * @enum {string}
 */
const NFTContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const NativeItemTypeEnum = {
    Native: 'NATIVE',
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const OrderTypeEnum = {
    Listing: 'LISTING'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The Order status
 * @export
 * @enum {string}
 */
const OrderStatusName = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Filled: 'FILLED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PendingOrderStatusNameEnum = {
    Pending: 'PENDING'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProtocolDataOrderTypeEnum = {
    FullRestricted: 'FULL_RESTRICTED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SaleFeeTypeEnum = {
    Royalty: 'ROYALTY'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for a token
 * @export
 * @enum {string}
 */
const TokenContractType = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError400AllOfCodeEnum: APIError400AllOfCodeEnum,
    APIError401AllOfCodeEnum: APIError401AllOfCodeEnum,
    APIError403AllOfCodeEnum: APIError403AllOfCodeEnum,
    APIError404AllOfCodeEnum: APIError404AllOfCodeEnum,
    APIError429AllOfCodeEnum: APIError429AllOfCodeEnum,
    APIError500AllOfCodeEnum: APIError500AllOfCodeEnum,
    APIError501AllOfCodeEnum: APIError501AllOfCodeEnum,
    ActiveOrderStatusNameEnum: ActiveOrderStatusNameEnum,
    ActivitiesApi: ActivitiesApi,
    ActivitiesApiAxiosParamCreator: ActivitiesApiAxiosParamCreator,
    ActivitiesApiFactory: ActivitiesApiFactory,
    ActivitiesApiFp: ActivitiesApiFp,
    ActivityType: ActivityType,
    CancelledOrderStatusCancellationTypeEnum: CancelledOrderStatusCancellationTypeEnum,
    CancelledOrderStatusNameEnum: CancelledOrderStatusNameEnum,
    ChainsApi: ChainsApi,
    ChainsApiAxiosParamCreator: ChainsApiAxiosParamCreator,
    ChainsApiFactory: ChainsApiFactory,
    ChainsApiFp: ChainsApiFp,
    CollectionContractType: CollectionContractType,
    CollectionsApi: CollectionsApi,
    CollectionsApiAxiosParamCreator: CollectionsApiAxiosParamCreator,
    CollectionsApiFactory: CollectionsApiFactory,
    CollectionsApiFp: CollectionsApiFp,
    Configuration: Configuration,
    ERC1155ItemTypeEnum: ERC1155ItemTypeEnum,
    ERC20ItemTypeEnum: ERC20ItemTypeEnum,
    ERC721ItemTypeEnum: ERC721ItemTypeEnum,
    ExpiredOrderStatusNameEnum: ExpiredOrderStatusNameEnum,
    FailedOrderCancellationReasonCodeEnum: FailedOrderCancellationReasonCodeEnum,
    FeeTypeEnum: FeeTypeEnum,
    FilledOrderStatusNameEnum: FilledOrderStatusNameEnum,
    GetContractAbiResTransactionTypeEnum: GetContractAbiResTransactionTypeEnum,
    InactiveOrderStatusNameEnum: InactiveOrderStatusNameEnum,
    ListListingsSortByEnum: ListListingsSortByEnum$1,
    ListListingsSortDirectionEnum: ListListingsSortDirectionEnum$1,
    ListTradesSortByEnum: ListTradesSortByEnum$1,
    ListTradesSortDirectionEnum: ListTradesSortDirectionEnum$1,
    MetadataApi: MetadataApi,
    MetadataApiAxiosParamCreator: MetadataApiAxiosParamCreator,
    MetadataApiFactory: MetadataApiFactory,
    MetadataApiFp: MetadataApiFp,
    MintRequestStatus: MintRequestStatus,
    NFTContractType: NFTContractType,
    NativeItemTypeEnum: NativeItemTypeEnum,
    NftOwnersApi: NftOwnersApi,
    NftOwnersApiAxiosParamCreator: NftOwnersApiAxiosParamCreator,
    NftOwnersApiFactory: NftOwnersApiFactory,
    NftOwnersApiFp: NftOwnersApiFp,
    NftsApi: NftsApi,
    NftsApiAxiosParamCreator: NftsApiAxiosParamCreator,
    NftsApiFactory: NftsApiFactory,
    NftsApiFp: NftsApiFp,
    OrderStatusName: OrderStatusName,
    OrderTypeEnum: OrderTypeEnum,
    OrdersApi: OrdersApi,
    OrdersApiAxiosParamCreator: OrdersApiAxiosParamCreator,
    OrdersApiFactory: OrdersApiFactory,
    OrdersApiFp: OrdersApiFp,
    PassportApi: PassportApi,
    PassportApiAxiosParamCreator: PassportApiAxiosParamCreator,
    PassportApiFactory: PassportApiFactory,
    PassportApiFp: PassportApiFp,
    PendingOrderStatusNameEnum: PendingOrderStatusNameEnum,
    ProtocolDataOrderTypeEnum: ProtocolDataOrderTypeEnum,
    SaleFeeTypeEnum: SaleFeeTypeEnum,
    TokenContractType: TokenContractType,
    TokensApi: TokensApi,
    TokensApiAxiosParamCreator: TokensApiAxiosParamCreator,
    TokensApiFactory: TokensApiFactory,
    TokensApiFp: TokensApiFp
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var activitiesApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActivityType: ActivityType
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var chainsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var collectionsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var metadataApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var nftOwnersApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var nftsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var tokensApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

/**
 * Custom Error class that is returned from the API when a request fails
 */
class APIError extends Error {
    code;
    details;
    link;
    traceId;
    constructor({ message, code, details, link, trace_id: traceId, }) {
        super(message);
        this.code = code;
        this.details = details;
        this.link = link;
        this.traceId = traceId;
    }
}

/* eslint-disable implicit-arrow-linebreak */
const defaultHeaders = {
    sdkVersion: 'ts-immutable-sdk-multi-rollup-api-client-0.35.8',
};
/**
 * createAPIConfiguration to create a custom Configuration
 * other than the production and sandbox defined below.
 */
const createAPIConfiguration = ({ baseConfig, basePath, headers: baseHeaders, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const headers = { ...(baseHeaders || {}), ...defaultHeaders };
    const configParams = {
        ...baseConfig,
        basePath,
        baseOptions: { headers },
    };
    return new index.Configuration(configParams);
};
class BlockchainDataConfiguration {
    apiConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.apiConfig = createAPIConfiguration(overrides);
        }
        else {
            switch (baseConfig.environment) {
                case Environment.SANDBOX: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.sandbox.immutable.com',
                        baseConfig,
                    });
                    break;
                }
                case Environment.PRODUCTION: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.immutable.com',
                        baseConfig,
                    });
                    break;
                }
                default: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.sandbox.immutable.com',
                        baseConfig,
                    });
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/naming-convention */
/**
 * [Formats an error in the APIError shape](https://axios-http.com/docs/handling_errors)
 * @param error - The Error object thrown by the request
 * @returns APIError
 */
function formatError(error) {
    if (globalAxios.isAxiosError(error) && error.response) {
        const apiError = error.response.data;
        if (apiError.code && apiError.message) {
            return new APIError({
                code: apiError.code,
                message: apiError.message,
                details: apiError.details || null,
                link: apiError.link || '',
                trace_id: apiError.trace_id || '',
            });
        }
        return new APIError({
            code: error.code ?? error.response?.status.toString() ?? 'unknown_error_code',
            message: String(error),
            details: null,
            link: '',
            trace_id: '',
        });
    }
    return new APIError({
        code: 'unknown_error_code',
        message: String(error),
        details: null,
        link: '',
        trace_id: '',
    });
}

class BlockchainData {
    config;
    activities;
    chains;
    collections;
    nfts;
    nftOwners;
    tokens;
    metadata;
    constructor(moduleConfig) {
        this.config = new BlockchainDataConfiguration(moduleConfig);
        this.activities = new index.ActivitiesApi(this.config.apiConfig);
        this.chains = new index.ChainsApi(this.config.apiConfig);
        this.collections = new index.CollectionsApi(this.config.apiConfig);
        this.nfts = new index.NftsApi(this.config.apiConfig);
        this.nftOwners = new index.NftOwnersApi(this.config.apiConfig);
        this.tokens = new index.TokensApi(this.config.apiConfig);
        this.metadata = new index.MetadataApi(this.config.apiConfig);
    }
    /**
     * List all activities
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivities(request) {
        return await this.activities
            .listActivities(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List activities sorted by updated_at timestamp ascending, useful for time based data replication
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivityHistory(request) {
        return await this.activities
            .listActivityHistory(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a single activity by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single activity
     * @throws {@link index.APIError}
     */
    async getActivity(request) {
        return await this.activities
            .getActivity(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List supported chains
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of supported chains
     * @throws {@link index.APIError}
     */
    async listChains(request) {
        return await this.chains
            .listChains(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List all collections
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollections(request) {
        return await this.collections
            .listCollections(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List collections by NFT owner
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollectionsByNFTOwner(request) {
        return await this.collections
            .listCollectionsByNFTOwner(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a collection by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single collection
     * @throws {@link index.APIError}
     */
    async getCollection(request) {
        return await this.collections
            .getCollection(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get NFT by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single NFT
     * @throws {@link index.APIError}
     */
    async getNFT(request) {
        return await this.nfts
            .getNFT(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTs(request) {
        return await this.nfts
            .listNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by account address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTsByAccountAddress(request) {
        return await this.nfts
            .listNFTsByAccountAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List All NFTs on a chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listAllNFTs(request) {
        return await this.nfts
            .listAllNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwners(request) {
        return await this.nftOwners
            .listNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwnersByContractAddress(request) {
        return await this.nftOwners
            .listOwnersByContractAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List All NFT owners on a chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listAllNFTOwners(request) {
        return await this.nftOwners
            .listAllNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List ERC20 Token contracts
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async listTokens(request) {
        return await this.tokens
            .listERC20Tokens(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get details for an ERC20 Token by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async getToken(request) {
        return await this.tokens
            .getERC20Token(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get metadata by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single Metadata
     * @throws {@link index.APIError}
     */
    async getMetadata(request) {
        return await this.metadata
            .getMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT Metadata by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of Metadata
     * @throws {@link index.APIError}
     */
    async listNFTMetadataByContractAddress(request) {
        return await this.metadata
            .listMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT Metadata by chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of Metadata
     * @throws {@link index.APIError}
     */
    async listNFTMetadataByChain(request) {
        return await this.metadata
            .listMetadataForChain(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh collection metadata
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated collection
     * @throws {@link index.APIError}
     */
    async refreshCollectionMetadata(request) {
        return await this.collections
            .refreshCollectionMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh metadata for specific NFTs
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the remaining rate limits
     * @throws {@link index.APIError}
     */
    async refreshNFTMetadata(request) {
        return await this.metadata
            .refreshNFTMetadataByTokenID(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh metadata by ID. This will refresh metadata for all NFTs that reference the given metadata ID.
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the remaining rate limits
     * @throws {@link index.APIError}
     */
    async refreshStackedMetadata(request) {
        return await this.metadata
            .refreshMetadataByID(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
}

export { APIError, activitiesApiTypes as ActivitiesTypes, BlockchainData, chainsApiTypes as ChainsTypes, collectionsApiTypes as CollectionsTypes, metadataApiTypes as MetadataTypes, nftOwnersApiTypes as NFTOwnersTypes, nftsApiTypes as NFTsTypes, tokensApiTypes as TokensTypes };
