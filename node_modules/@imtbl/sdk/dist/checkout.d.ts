/// <reference types="node" />
declare type Bytes = ArrayLike<number>;
declare type BytesLike = Bytes | string;
interface Hexable {
    toHexString(): string;
}

declare type BigNumberish = BigNumber | Bytes | bigint | string | number;
declare class BigNumber implements Hexable {
    readonly _hex: string;
    readonly _isBigNumber: boolean;
    constructor(constructorGuard: any, hex: string);
    fromTwos(value: number): BigNumber;
    toTwos(value: number): BigNumber;
    abs(): BigNumber;
    add(other: BigNumberish): BigNumber;
    sub(other: BigNumberish): BigNumber;
    div(other: BigNumberish): BigNumber;
    mul(other: BigNumberish): BigNumber;
    mod(other: BigNumberish): BigNumber;
    pow(other: BigNumberish): BigNumber;
    and(other: BigNumberish): BigNumber;
    or(other: BigNumberish): BigNumber;
    xor(other: BigNumberish): BigNumber;
    mask(value: number): BigNumber;
    shl(value: number): BigNumber;
    shr(value: number): BigNumber;
    eq(other: BigNumberish): boolean;
    lt(other: BigNumberish): boolean;
    lte(other: BigNumberish): boolean;
    gt(other: BigNumberish): boolean;
    gte(other: BigNumberish): boolean;
    isNegative(): boolean;
    isZero(): boolean;
    toNumber(): number;
    toBigInt(): bigint;
    toString(): string;
    toHexString(): string;
    toJSON(key?: string): any;
    static from(value: any): BigNumber;
    static isBigNumber(value: any): value is BigNumber;
}

declare type Network = {
    name: string;
    chainId: number;
    ensAddress?: string;
    _defaultProvider?: (providers: any, options?: any) => any;
};
declare type Networkish = Network | string | number;

declare type Deferrable<T> = {
    [K in keyof T]: T[K] | Promise<T[K]>;
};
declare class Description<T = any> {
    constructor(info: {
        [K in keyof T]: T[K];
    });
}

declare type AccessList = Array<{
    address: string;
    storageKeys: Array<string>;
}>;
declare type AccessListish = AccessList | Array<[string, Array<string>]> | Record<string, Array<string>>;
interface Transaction {
    hash?: string;
    to?: string;
    from?: string;
    nonce: number;
    gasLimit: BigNumber;
    gasPrice?: BigNumber;
    data: string;
    value: BigNumber;
    chainId: number;
    r?: string;
    s?: string;
    v?: number;
    type?: number | null;
    accessList?: AccessList;
    maxPriorityFeePerGas?: BigNumber;
    maxFeePerGas?: BigNumber;
}

declare type ConnectionInfo = {
    url: string;
    headers?: {
        [key: string]: string | number;
    };
    user?: string;
    password?: string;
    allowInsecureAuthentication?: boolean;
    allowGzip?: boolean;
    throttleLimit?: number;
    throttleSlotInterval?: number;
    throttleCallback?: (attempt: number, url: string) => Promise<boolean>;
    skipFetchSetup?: boolean;
    fetchOptions?: Record<string, string>;
    errorPassThrough?: boolean;
    timeout?: number;
};
interface OnceBlockable {
    once(eventName: "block", handler: () => void): void;
}

declare type TransactionRequest = {
    to?: string;
    from?: string;
    nonce?: BigNumberish;
    gasLimit?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: BytesLike;
    value?: BigNumberish;
    chainId?: number;
    type?: number;
    accessList?: AccessListish;
    maxPriorityFeePerGas?: BigNumberish;
    maxFeePerGas?: BigNumberish;
    customData?: Record<string, any>;
    ccipReadEnabled?: boolean;
};
interface TransactionResponse extends Transaction {
    hash: string;
    blockNumber?: number;
    blockHash?: string;
    timestamp?: number;
    confirmations: number;
    from: string;
    raw?: string;
    wait: (confirmations?: number) => Promise<TransactionReceipt>;
}
declare type BlockTag = string | number;
interface _Block {
    hash: string;
    parentHash: string;
    number: number;
    timestamp: number;
    nonce: string;
    difficulty: number;
    _difficulty: BigNumber;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    miner: string;
    extraData: string;
    baseFeePerGas?: null | BigNumber;
}
interface Block extends _Block {
    transactions: Array<string>;
}
interface BlockWithTransactions extends _Block {
    transactions: Array<TransactionResponse>;
}
interface Log {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
}
interface TransactionReceipt {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    gasUsed: BigNumber;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    logs: Array<Log>;
    blockNumber: number;
    confirmations: number;
    cumulativeGasUsed: BigNumber;
    effectiveGasPrice: BigNumber;
    byzantium: boolean;
    type: number;
    status?: number;
}
interface FeeData$1 {
    lastBaseFeePerGas: null | BigNumber;
    maxFeePerGas: null | BigNumber;
    maxPriorityFeePerGas: null | BigNumber;
    gasPrice: null | BigNumber;
}
interface EventFilter {
    address?: string;
    topics?: Array<string | Array<string> | null>;
}
interface Filter extends EventFilter {
    fromBlock?: BlockTag;
    toBlock?: BlockTag;
}
interface FilterByBlockHash extends EventFilter {
    blockHash?: string;
}
declare abstract class ForkEvent extends Description {
    readonly expiry: number;
    readonly _isForkEvent?: boolean;
    static isForkEvent(value: any): value is ForkEvent;
}
declare type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;
declare type Listener = (...args: Array<any>) => void;
declare abstract class Provider$1 implements OnceBlockable {
    abstract getNetwork(): Promise<Network>;
    abstract getBlockNumber(): Promise<number>;
    abstract getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData$1>;
    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;
    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;
    abstract getLogs(filter: Filter): Promise<Array<Log>>;
    abstract resolveName(name: string | Promise<string>): Promise<null | string>;
    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;
    abstract on(eventName: EventType, listener: Listener): Provider$1;
    abstract once(eventName: EventType, listener: Listener): Provider$1;
    abstract emit(eventName: EventType, ...args: Array<any>): boolean;
    abstract listenerCount(eventName?: EventType): number;
    abstract listeners(eventName?: EventType): Array<Listener>;
    abstract off(eventName: EventType, listener?: Listener): Provider$1;
    abstract removeAllListeners(eventName?: EventType): Provider$1;
    addListener(eventName: EventType, listener: Listener): Provider$1;
    removeListener(eventName: EventType, listener: Listener): Provider$1;
    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    readonly _isProvider: boolean;
    constructor();
    static isProvider(value: any): value is Provider$1;
}

declare type FormatFunc = (value: any) => any;
declare type FormatFuncs = {
    [key: string]: FormatFunc;
};
declare type Formats = {
    transaction: FormatFuncs;
    transactionRequest: FormatFuncs;
    receipt: FormatFuncs;
    receiptLog: FormatFuncs;
    block: FormatFuncs;
    blockWithTransactions: FormatFuncs;
    filter: FormatFuncs;
    filterLog: FormatFuncs;
};
declare class Formatter {
    readonly formats: Formats;
    constructor();
    getDefaultFormats(): Formats;
    accessList(accessList: Array<any>): AccessList;
    number(number: any): number;
    type(number: any): number;
    bigNumber(value: any): BigNumber;
    boolean(value: any): boolean;
    hex(value: any, strict?: boolean): string;
    data(value: any, strict?: boolean): string;
    address(value: any): string;
    callAddress(value: any): string;
    contractAddress(value: any): string;
    blockTag(blockTag: any): string;
    hash(value: any, strict?: boolean): string;
    difficulty(value: any): number;
    uint256(value: any): string;
    _block(value: any, format: any): Block;
    block(value: any): Block;
    blockWithTransactions(value: any): Block;
    transactionRequest(value: any): any;
    transactionResponse(transaction: any): TransactionResponse;
    transaction(value: any): any;
    receiptLog(value: any): any;
    receipt(value: any): TransactionReceipt;
    topics(value: any): any;
    filter(value: any): any;
    filterLog(value: any): any;
    static check(format: {
        [name: string]: FormatFunc;
    }, object: any): any;
    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc;
    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc;
    static arrayOf(format: FormatFunc): FormatFunc;
}

declare class Event {
    readonly listener: Listener;
    readonly once: boolean;
    readonly tag: string;
    _lastBlockNumber: number;
    _inflight: boolean;
    constructor(tag: string, listener: Listener, once: boolean);
    get event(): EventType;
    get type(): string;
    get hash(): string;
    get filter(): Filter;
    pollable(): boolean;
}
interface EnsResolver {
    readonly name: string;
    readonly address: string;
    getAddress(coinType?: 60): Promise<null | string>;
    getContentHash(): Promise<null | string>;
    getText(key: string): Promise<null | string>;
}
interface EnsProvider {
    resolveName(name: string): Promise<null | string>;
    lookupAddress(address: string): Promise<null | string>;
    getResolver(name: string): Promise<null | EnsResolver>;
}
interface Avatar {
    url: string;
    linkage: Array<{
        type: string;
        content: string;
    }>;
}
declare class Resolver implements EnsResolver {
    readonly provider: BaseProvider;
    readonly name: string;
    readonly address: string;
    readonly _resolvedAddress: null | string;
    _supportsEip2544: null | Promise<boolean>;
    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string);
    supportsWildcard(): Promise<boolean>;
    _fetch(selector: string, parameters?: string): Promise<null | string>;
    _fetchBytes(selector: string, parameters?: string): Promise<null | string>;
    _getAddress(coinType: number, hexBytes: string): string;
    getAddress(coinType?: number): Promise<string>;
    getAvatar(): Promise<null | Avatar>;
    getContentHash(): Promise<string>;
    getText(key: string): Promise<string>;
}
declare class BaseProvider extends Provider$1 implements EnsProvider {
    _networkPromise: Promise<Network>;
    _network: Network;
    _events: Array<Event>;
    formatter: Formatter;
    _emitted: {
        [eventName: string]: number | "pending";
    };
    _pollingInterval: number;
    _poller: NodeJS.Timer;
    _bootstrapPoll: NodeJS.Timer;
    _lastBlockNumber: number;
    _maxFilterBlockRange: number;
    _fastBlockNumber: number;
    _fastBlockNumberPromise: Promise<number>;
    _fastQueryDate: number;
    _maxInternalBlockNumber: number;
    _internalBlockNumber: Promise<{
        blockNumber: number;
        reqTime: number;
        respTime: number;
    }>;
    readonly anyNetwork: boolean;
    disableCcipRead: boolean;
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network: Networkish | Promise<Network>);
    _ready(): Promise<Network>;
    get ready(): Promise<Network>;
    static getFormatter(): Formatter;
    static getNetwork(network: Networkish): Network;
    ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string>;
    _getInternalBlockNumber(maxAge: number): Promise<number>;
    poll(): Promise<void>;
    resetEventsBlock(blockNumber: number): void;
    get network(): Network;
    detectNetwork(): Promise<Network>;
    getNetwork(): Promise<Network>;
    get blockNumber(): number;
    get polling(): boolean;
    set polling(value: boolean);
    get pollingInterval(): number;
    set pollingInterval(value: number);
    _getFastBlockNumber(): Promise<number>;
    _setFastBlockNumber(blockNumber: number): void;
    waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
        data: string;
        from: string;
        nonce: number;
        to: string;
        value: BigNumber;
        startBlock: number;
    }): Promise<TransactionReceipt>;
    getBlockNumber(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse;
    sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction>;
    _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash>;
    _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    _getAddress(addressOrName: string | Promise<string>): Promise<string>;
    _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions>;
    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse>;
    getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt>;
    getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>>;
    getEtherPrice(): Promise<number>;
    _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag>;
    getResolver(name: string): Promise<null | Resolver>;
    _getResolver(name: string, operation?: string): Promise<string>;
    resolveName(name: string | Promise<string>): Promise<null | string>;
    lookupAddress(address: string | Promise<string>): Promise<null | string>;
    getAvatar(nameOrAddress: string): Promise<null | string>;
    perform(method: string, params: any): Promise<any>;
    _startEvent(event: Event): void;
    _stopEvent(event: Event): void;
    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this;
    on(eventName: EventType, listener: Listener): this;
    once(eventName: EventType, listener: Listener): this;
    emit(eventName: EventType, ...args: Array<any>): boolean;
    listenerCount(eventName?: EventType): number;
    listeners(eventName?: EventType): Array<Listener>;
    off(eventName: EventType, listener?: Listener): this;
    removeAllListeners(eventName?: EventType): this;
}

interface TypedDataDomain {
    name?: string;
    version?: string;
    chainId?: BigNumberish;
    verifyingContract?: string;
    salt?: BytesLike;
}
interface TypedDataField {
    name: string;
    type: string;
}
interface TypedDataSigner {
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
}
declare abstract class Signer {
    readonly provider?: Provider$1;
    abstract getAddress(): Promise<string>;
    abstract signMessage(message: Bytes | string): Promise<string>;
    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    abstract connect(provider: Provider$1): Signer;
    readonly _isSigner: boolean;
    constructor();
    getBalance(blockTag?: BlockTag): Promise<BigNumber>;
    getTransactionCount(blockTag?: BlockTag): Promise<number>;
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    getChainId(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData$1>;
    resolveName(name: string): Promise<string>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    _checkProvider(operation?: string): void;
    static isSigner(value: any): value is Signer;
}

declare class JsonRpcSigner extends Signer implements TypedDataSigner {
    readonly provider: JsonRpcProvider;
    _index: number;
    _address: string;
    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number);
    connect(provider: Provider$1): JsonRpcSigner;
    connectUnchecked(): JsonRpcSigner;
    getAddress(): Promise<string>;
    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    signMessage(message: Bytes | string): Promise<string>;
    _legacySignMessage(message: Bytes | string): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
    unlock(password: string): Promise<boolean>;
}
declare class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
}
declare class JsonRpcProvider extends BaseProvider {
    readonly connection: ConnectionInfo;
    _pendingFilter: Promise<number>;
    _nextId: number;
    _eventLoopCache: Record<string, Promise<any>>;
    get _cache(): Record<string, Promise<any>>;
    constructor(url?: ConnectionInfo | string, network?: Networkish);
    static defaultUrl(): string;
    detectNetwork(): Promise<Network>;
    _uncachedDetectNetwork(): Promise<Network>;
    getSigner(addressOrIndex?: string | number): JsonRpcSigner;
    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner;
    listAccounts(): Promise<Array<string>>;
    send(method: string, params: Array<any>): Promise<any>;
    prepareRequest(method: string, params: any): [string, Array<any>];
    perform(method: string, params: any): Promise<any>;
    _startEvent(event: Event): void;
    _startPending(): void;
    _stopEvent(event: Event): void;
    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: {
        [key: string]: boolean;
    }): {
        [key: string]: string | AccessList;
    };
}

declare type ExternalProvider = {
    isMetaMask?: boolean;
    isStatus?: boolean;
    host?: string;
    path?: string;
    sendAsync?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    send?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    request?: (request: {
        method: string;
        params?: Array<any>;
    }) => Promise<any>;
};
declare type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;
declare class Web3Provider extends JsonRpcProvider {
    readonly provider: ExternalProvider;
    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;
    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish);
    send(method: string, params: Array<any>): Promise<any>;
}

// TypeScript Version: 3.0

type AxiosRequestHeaders = Record<string, string | number | boolean>;

type AxiosResponseHeaders = Record<string, string> & {
  "set-cookie"?: string[]
};

interface AxiosRequestTransformer {
  (data: any, headers?: AxiosRequestHeaders): any;
}

interface AxiosResponseTransformer {
  (data: any, headers?: AxiosResponseHeaders): any;
}

interface AxiosAdapter {
  (config: AxiosRequestConfig): AxiosPromise;
}

interface AxiosBasicCredentials {
  username: string;
  password: string;
}

interface AxiosProxyConfig {
  host: string;
  port: number;
  auth?: {
    username: string;
    password: string;
  };
  protocol?: string;
}

type Method =
  | 'get' | 'GET'
  | 'delete' | 'DELETE'
  | 'head' | 'HEAD'
  | 'options' | 'OPTIONS'
  | 'post' | 'POST'
  | 'put' | 'PUT'
  | 'patch' | 'PATCH'
  | 'purge' | 'PURGE'
  | 'link' | 'LINK'
  | 'unlink' | 'UNLINK';

type ResponseType =
  | 'arraybuffer'
  | 'blob'
  | 'document'
  | 'json'
  | 'text'
  | 'stream';

  type responseEncoding =
  | 'ascii' | 'ASCII'
  | 'ansi' | 'ANSI'
  | 'binary' | 'BINARY'
  | 'base64' | 'BASE64'
  | 'base64url' | 'BASE64URL'
  | 'hex' | 'HEX'
  | 'latin1' | 'LATIN1'
  | 'ucs-2' | 'UCS-2'
  | 'ucs2' | 'UCS2'
  | 'utf-8' | 'UTF-8'
  | 'utf8' | 'UTF8'
  | 'utf16le' | 'UTF16LE';

interface TransitionalOptions {
  silentJSONParsing?: boolean;
  forcedJSONParsing?: boolean;
  clarifyTimeoutError?: boolean;
}

interface AxiosRequestConfig<D = any> {
  url?: string;
  method?: Method;
  baseURL?: string;
  transformRequest?: AxiosRequestTransformer | AxiosRequestTransformer[];
  transformResponse?: AxiosResponseTransformer | AxiosResponseTransformer[];
  headers?: AxiosRequestHeaders;
  params?: any;
  paramsSerializer?: (params: any) => string;
  data?: D;
  timeout?: number;
  timeoutErrorMessage?: string;
  withCredentials?: boolean;
  adapter?: AxiosAdapter;
  auth?: AxiosBasicCredentials;
  responseType?: ResponseType;
  responseEncoding?: responseEncoding | string;
  xsrfCookieName?: string;
  xsrfHeaderName?: string;
  onUploadProgress?: (progressEvent: any) => void;
  onDownloadProgress?: (progressEvent: any) => void;
  maxContentLength?: number;
  validateStatus?: ((status: number) => boolean) | null;
  maxBodyLength?: number;
  maxRedirects?: number;
  socketPath?: string | null;
  httpAgent?: any;
  httpsAgent?: any;
  proxy?: AxiosProxyConfig | false;
  cancelToken?: CancelToken;
  decompress?: boolean;
  transitional?: TransitionalOptions;
  signal?: AbortSignal;
  insecureHTTPParser?: boolean;
}

interface HeadersDefaults {
  common: AxiosRequestHeaders;
  delete: AxiosRequestHeaders;
  get: AxiosRequestHeaders;
  head: AxiosRequestHeaders;
  post: AxiosRequestHeaders;
  put: AxiosRequestHeaders;
  patch: AxiosRequestHeaders;
  options?: AxiosRequestHeaders;
  purge?: AxiosRequestHeaders;
  link?: AxiosRequestHeaders;
  unlink?: AxiosRequestHeaders;
}

interface AxiosDefaults<D = any> extends Omit<AxiosRequestConfig<D>, 'headers'> {
  headers: HeadersDefaults;
}

interface AxiosResponse<T = any, D = any>  {
  data: T;
  status: number;
  statusText: string;
  headers: AxiosResponseHeaders;
  config: AxiosRequestConfig<D>;
  request?: any;
}

interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {
}

interface Cancel {
  message: string | undefined;
}

interface CancelToken {
  promise: Promise<Cancel>;
  reason?: Cancel;
  throwIfRequested(): void;
}

interface AxiosInterceptorManager<V> {
  use<T = V>(onFulfilled?: (value: V) => T | Promise<T>, onRejected?: (error: any) => any): number;
  eject(id: number): void;
}

declare class Axios {
  constructor(config?: AxiosRequestConfig);
  defaults: AxiosDefaults;
  interceptors: {
    request: AxiosInterceptorManager<AxiosRequestConfig>;
    response: AxiosInterceptorManager<AxiosResponse>;
  };
  getUri(config?: AxiosRequestConfig): string;
  request<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;
  get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
  delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
  head<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
  options<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
  post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
  put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
  patch<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
}

interface AxiosInstance extends Axios {
  (config: AxiosRequestConfig): AxiosPromise;
  (url: string, config?: AxiosRequestConfig): AxiosPromise;
}

/**
 * An abstraction of a Stark account, which can be used to sign messages and transactions on StarkEx to execute state changing operations
 */
interface StarkSigner {
    /**
     * Signs the prefixed-message
     * @params message - this must be a UTF8-message
     * @example "0x1234"
     * @returns the signed prefixed-message
     */
    signMessage(message: string): Promise<string>;
    /**
     * Get the Signer address
     * @returns the Signer's checksum address
     */
    getAddress(): string | Promise<string>;
}
/**
 * A pair of Signers
 */
interface WalletConnection {
    /**
     * The L1 signer
     */
    ethSigner: Signer;
    /**
     * The L2 signer
     */
    starkSigner: StarkSigner;
}

/**
 * An ERC20 token
 */
interface ERC20Token {
    type: 'ERC20';
    tokenAddress: string;
}
/**
 * An ERC721 token
 */
interface ERC721Token {
    type: 'ERC721';
    tokenId: string;
    tokenAddress: string;
}
/**
 * An ETH token
 */
interface ETHToken {
    type: 'ETH';
}
/**
 * An amount of ETH token of unit Wei
 */
interface ETHAmount extends ETHToken {
    /**
     * An amount in unit Wei
     */
    amount: string;
}
/**
 * The token details and amount of ERC20 token units
 */
interface ERC20Amount extends ERC20Token {
    /**
     * An amount in units for the given ERC20 token
     */
    amount: string;
}
/**
 * Union type that represents all token types
 */
declare type AnyToken = ETHToken | ERC721Token | ERC20Token;
/**
 * Union type that represents all token type amounts
 */
declare type TokenAmount = ETHAmount | ERC20Amount | ERC721Token;
/**
 * Union type that represents exchange token type amounts
 */
declare type ExchangeTokenAmount = ETHAmount | ERC20Amount;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataSchemaRequest
 */
interface MetadataSchemaRequest {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof MetadataSchemaRequest
     */
    'filterable'?: boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof MetadataSchemaRequest
     */
    'name': string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof MetadataSchemaRequest
     */
    'type'?: MetadataSchemaRequestTypeEnum;
}
declare const MetadataSchemaRequestTypeEnum: {
    readonly Enum: "enum";
    readonly Text: "text";
    readonly Boolean: "boolean";
    readonly Continuous: "continuous";
    readonly Discrete: "discrete";
};
declare type MetadataSchemaRequestTypeEnum = typeof MetadataSchemaRequestTypeEnum[keyof typeof MetadataSchemaRequestTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AddMetadataSchemaToCollectionRequest
 */
interface AddMetadataSchemaToCollectionRequest {
    /**
     * Not required from API user
     * @type {string}
     * @memberof AddMetadataSchemaToCollectionRequest
     */
    'contract_address'?: string;
    /**
     * The metadata container
     * @type {Array<MetadataSchemaRequest>}
     * @memberof AddMetadataSchemaToCollectionRequest
     */
    'metadata': Array<MetadataSchemaRequest>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface AggregateLimit
 */
interface AggregateLimit {
    /**
     * Max transaction amount
     * @type {number}
     * @memberof AggregateLimit
     */
    'max_amount'?: number;
    /**
     * Min transaction amount
     * @type {number}
     * @memberof AggregateLimit
     */
    'min_amount'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CollectionDetails
 */
interface CollectionDetails {
    /**
     * URL of the icon of the collection
     * @type {string}
     * @memberof CollectionDetails
     */
    'icon_url': string | null;
    /**
     * Name of the collection
     * @type {string}
     * @memberof CollectionDetails
     */
    'name': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type AssetPropertiesCollection
 * Details of this asset\'s collection
 * @export
 */
declare type AssetPropertiesCollection = CollectionDetails;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AssetProperties
 */
interface AssetProperties {
    /**
     *
     * @type {AssetPropertiesCollection}
     * @memberof AssetProperties
     */
    'collection'?: AssetPropertiesCollection;
    /**
     * Image URL of this asset
     * @type {string}
     * @memberof AssetProperties
     */
    'image_url'?: string;
    /**
     * Name of this asset
     * @type {string}
     * @memberof AssetProperties
     */
    'name'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TokenDataProperties
 * Properties of this asset
 * @export
 */
declare type TokenDataProperties = AssetProperties;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface TokenData
 */
interface TokenData {
    /**
     * Number of decimals supported by this asset
     * @type {number}
     * @memberof TokenData
     */
    'decimals'?: number;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof TokenData
     */
    'id'?: string;
    /**
     *
     * @type {TokenDataProperties}
     * @memberof TokenData
     */
    'properties'?: TokenDataProperties;
    /**
     * Quantity of this asset - inclusive of fees for buy order in v1 API and exclusive of fees in v3 API
     * @type {string}
     * @memberof TokenData
     */
    'quantity': string;
    /**
     * [DEPRECATED for v3 endpoints] Quantity of this asset with the sum of all fees applied to the asset. Replaced by quantity_with_fees in maker_fees / taker_fees depending on the type of order. Refer https://docs.x.immutable.com/docs/maker-taker-fees/#new-maker-taker-fields-and-the-deprecation-of-quantity_with_fees-in-buy-and-sell.
     * @type {string}
     * @memberof TokenData
     */
    'quantity_with_fees': string;
    /**
     * Symbol of a token
     * @type {string}
     * @memberof TokenData
     */
    'symbol'?: string;
    /**
     * Address of ERC721/ERC20 contract
     * @type {string}
     * @memberof TokenData
     */
    'token_address'?: string;
    /**
     * ERC721 Token ID
     * @type {string}
     * @memberof TokenData
     */
    'token_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TokenDataOAIGen
 * Token details of this asset
 * @export
 */
declare type TokenDataOAIGen = TokenData;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Token
 */
interface Token {
    /**
     *
     * @type {TokenDataOAIGen}
     * @memberof Token
     */
    'data': TokenDataOAIGen;
    /**
     * Type of this asset (ETH/ERC20/ERC721)
     * @type {string}
     * @memberof Token
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeData
 */
interface FeeData {
    /**
     * Address of ERC721/ERC20 contract
     * @type {string}
     * @memberof FeeData
     */
    'contract_address'?: string;
    /**
     * Number of decimals supported by this asset
     * @type {number}
     * @memberof FeeData
     */
    'decimals'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type FeeTokenData
 * Fee token data details
 * @export
 */
declare type FeeTokenData = FeeData;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface FeeToken
 */
interface FeeToken$1 {
    /**
     *
     * @type {FeeTokenData}
     * @memberof FeeToken
     */
    'data'?: FeeTokenData;
    /**
     * Fee token type. One of ETH/ERC20
     * @type {string}
     * @memberof FeeToken
     */
    'type'?: FeeTokenTypeEnum;
}
declare const FeeTokenTypeEnum: {
    readonly Eth: "ETH";
    readonly Erc20: "ERC20";
};
declare type FeeTokenTypeEnum = typeof FeeTokenTypeEnum[keyof typeof FeeTokenTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type OrderFeeInfoToken
 * Details of the fee currency
 * @export
 */
declare type OrderFeeInfoToken = FeeToken$1;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface OrderFeeInfo
 */
interface OrderFeeInfo {
    /**
     * Address of the fee recipient
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'address'?: string;
    /**
     * Fee amount
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'amount'?: string;
    /**
     *
     * @type {OrderFeeInfoToken}
     * @memberof OrderFeeInfo
     */
    'token'?: OrderFeeInfoToken;
    /**
     * Fee type
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'type'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ApiRegisterPassportUserRequest
 */
interface ApiRegisterPassportUserRequest {
    /**
     * Eth signature
     * @type {string}
     * @memberof ApiRegisterPassportUserRequest
     */
    'eth_signature': string;
    /**
     * The ether key of the user
     * @type {string}
     * @memberof ApiRegisterPassportUserRequest
     */
    'ether_key': string;
    /**
     * Public stark key of the user
     * @type {string}
     * @memberof ApiRegisterPassportUserRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof ApiRegisterPassportUserRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ApiSDKVersionCheckResponse
 */
interface ApiSDKVersionCheckResponse {
    /**
     *
     * @type {string}
     * @memberof ApiSDKVersionCheckResponse
     */
    'message'?: string;
    /**
     *
     * @type {boolean}
     * @memberof ApiSDKVersionCheckResponse
     */
    'ok'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ApiSDKVersionCheckResponse
     */
    'runtimeId'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type AssetCollection
 * Information about the collection to which this asset belongs
 * @export
 */
declare type AssetCollection = CollectionDetails;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface OrderDetails
 */
interface OrderDetails {
    /**
     * Buy orders for this asset
     * @type {Array<object>}
     * @memberof OrderDetails
     */
    'buy_orders'?: Array<object>;
    /**
     * Sell orders for this asset
     * @type {Array<object>}
     * @memberof OrderDetails
     */
    'sell_orders'?: Array<object>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type AssetOrders
 * [DEPRECATED] Open orders for this asset will always return empty. Use GET /orders
 * @export
 */
declare type AssetOrders = OrderDetails;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Fee
 */
interface Fee$1 {
    /**
     * Wallet address
     * @type {string}
     * @memberof Fee
     */
    'address': string;
    /**
     * The percentage of fee
     * @type {number}
     * @memberof Fee
     */
    'percentage': number;
    /**
     * Type of fee. Examples: `royalty`, `maker`, `taker` or `protocol`
     * @type {string}
     * @memberof Fee
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Asset
 */
interface Asset {
    /**
     *
     * @type {AssetCollection}
     * @memberof Asset
     */
    'collection': AssetCollection;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof Asset
     */
    'created_at': string | null;
    /**
     * Description of this asset
     * @type {string}
     * @memberof Asset
     */
    'description': string | null;
    /**
     * Royalties to pay on this asset operations
     * @type {Array<Fee>}
     * @memberof Asset
     */
    'fees'?: Array<Fee$1>;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof Asset
     */
    'id'?: string;
    /**
     * URL of the image which should be used for this asset
     * @type {string}
     * @memberof Asset
     */
    'image_url': string | null;
    /**
     * Metadata of this asset
     * @type {object}
     * @memberof Asset
     */
    'metadata': object | null;
    /**
     * Name of this asset
     * @type {string}
     * @memberof Asset
     */
    'name': string | null;
    /**
     *
     * @type {AssetOrders}
     * @memberof Asset
     */
    'orders'?: AssetOrders;
    /**
     * Status of this asset (where it is in the system)
     * @type {string}
     * @memberof Asset
     */
    'status': string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof Asset
     */
    'token_address': string;
    /**
     * ERC721 Token ID of this asset
     * @type {string}
     * @memberof Asset
     */
    'token_id': string;
    /**
     * Timestamp of when the asset was updated
     * @type {string}
     * @memberof Asset
     */
    'updated_at': string | null;
    /**
     * URI to access this asset externally to Immutable X
     * @type {string}
     * @memberof Asset
     */
    'uri': string | null;
    /**
     * Ethereum address of the user who owns this asset
     * @type {string}
     * @memberof Asset
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type AssetWithOrdersCollection
 * Information about the collection to which this asset belongs
 * @export
 */
declare type AssetWithOrdersCollection = CollectionDetails;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type AssetWithOrdersOrders
 * Open orders for this asset
 * @export
 */
declare type AssetWithOrdersOrders = OrderDetails;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AssetWithOrders
 */
interface AssetWithOrders {
    /**
     *
     * @type {AssetWithOrdersCollection}
     * @memberof AssetWithOrders
     */
    'collection': AssetWithOrdersCollection;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof AssetWithOrders
     */
    'created_at': string | null;
    /**
     * Description of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'description': string | null;
    /**
     * Royalties to pay on this asset operations
     * @type {Array<Fee>}
     * @memberof AssetWithOrders
     */
    'fees'?: Array<Fee$1>;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof AssetWithOrders
     */
    'id'?: string;
    /**
     * URL of the image which should be used for this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'image_url': string | null;
    /**
     * Metadata of this asset
     * @type {object}
     * @memberof AssetWithOrders
     */
    'metadata': object | null;
    /**
     * Name of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'name': string | null;
    /**
     *
     * @type {AssetWithOrdersOrders}
     * @memberof AssetWithOrders
     */
    'orders'?: AssetWithOrdersOrders;
    /**
     * Status of this asset (where it is in the system)
     * @type {string}
     * @memberof AssetWithOrders
     */
    'status': string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof AssetWithOrders
     */
    'token_address': string;
    /**
     * ERC721 Token ID of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'token_id': string;
    /**
     * Timestamp of when the asset was updated
     * @type {string}
     * @memberof AssetWithOrders
     */
    'updated_at': string | null;
    /**
     * URI to access this asset externally to Immutable X
     * @type {string}
     * @memberof AssetWithOrders
     */
    'uri': string | null;
    /**
     * Ethereum address of the user who owns this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Balance
 */
interface Balance {
    /**
     * Amount which is currently inside the exchange
     * @type {string}
     * @memberof Balance
     */
    'balance': string;
    /**
     * Amount which is currently preparing withdrawal from the exchange
     * @type {string}
     * @memberof Balance
     */
    'preparing_withdrawal': string;
    /**
     * Symbol of the token (e.g. ETH, IMX)
     * @type {string}
     * @memberof Balance
     */
    'symbol': string;
    /**
     * Address of the contract that represents this ERC20 token or empty for ETH
     * @type {string}
     * @memberof Balance
     */
    'token_address': string;
    /**
     * Amount which is currently withdrawable from the exchange
     * @type {string}
     * @memberof Balance
     */
    'withdrawable': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CancelOrderRequest
 */
interface CancelOrderRequest {
    /**
     * ID of the order
     * @type {number}
     * @memberof CancelOrderRequest
     */
    'order_id': number;
    /**
     * Payload signature
     * @type {string}
     * @memberof CancelOrderRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CancelOrderResponse
 */
interface CancelOrderResponse {
    /**
     * ID of the cancelled order
     * @type {number}
     * @memberof CancelOrderResponse
     */
    'order_id': number;
    /**
     * New status of the order
     * @type {string}
     * @memberof CancelOrderResponse
     */
    'status': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Collection
 */
interface Collection {
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof Collection
     */
    'address': string;
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof Collection
     */
    'collection_image_url': string | null;
    /**
     * Timestamp of when the collection was created
     * @type {string}
     * @memberof Collection
     */
    'created_at': string | null;
    /**
     * Description of the collection
     * @type {string}
     * @memberof Collection
     */
    'description': string | null;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof Collection
     */
    'icon_url': string | null;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof Collection
     */
    'metadata_api_url': string | null;
    /**
     * Name of the collection
     * @type {string}
     * @memberof Collection
     */
    'name': string;
    /**
     * The collection\'s project ID
     * @type {number}
     * @memberof Collection
     */
    'project_id': number;
    /**
     * Project owner address
     * @type {string}
     * @memberof Collection
     */
    'project_owner_address': string;
    /**
     * Timestamp of when the collection was updated
     * @type {string}
     * @memberof Collection
     */
    'updated_at': string | null;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Range
 */
interface Range {
    /**
     * Maximum value
     * @type {number}
     * @memberof Range
     */
    'max'?: number;
    /**
     * Minimum value
     * @type {number}
     * @memberof Range
     */
    'min'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type CollectionFilterRange
 * Range of values for this property
 * @export
 */
declare type CollectionFilterRange = Range;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CollectionFilter
 */
interface CollectionFilter {
    /**
     * Key of this property
     * @type {string}
     * @memberof CollectionFilter
     */
    'key'?: string;
    /**
     *
     * @type {CollectionFilterRange}
     * @memberof CollectionFilter
     */
    'range'?: CollectionFilterRange;
    /**
     * Type of this filter
     * @type {string}
     * @memberof CollectionFilter
     */
    'type'?: string;
    /**
     * List of possible values for this property
     * @type {Array<string>}
     * @memberof CollectionFilter
     */
    'value'?: Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ContractCreateAPIRequest
 */
interface ContractCreateAPIRequest {
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'contract_address'?: string;
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'data_url'?: string;
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'mint_url'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ContractCreateResponse
 */
interface ContractCreateResponse {
    /**
     *
     * @type {string}
     * @memberof ContractCreateResponse
     */
    'webhook_hash'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateCollectionRequest
 */
interface CreateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'contract_address': string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'name': string;
    /**
     * Owner Public Key: The uncompressed public key of the owner of the contract
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'owner_public_key': string;
    /**
     * The collection\'s project ID
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'project_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface WidgetParams
 */
interface WidgetParams {
    /**
     * Amount that will be prefilled in the widget
     * @type {string}
     * @memberof WidgetParams
     */
    'amount'?: string;
    /**
     * Currencies that will be available in the widget. If not defined all available currencies will be shown
     * @type {Array<string>}
     * @memberof WidgetParams
     */
    'supported_currencies'?: Array<string>;
    /**
     * Widget theme dark by default
     * @type {string}
     * @memberof WidgetParams
     */
    'theme'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateExchangeAndURLAPIRequest
 */
interface CreateExchangeAndURLAPIRequest {
    /**
     * Provider name
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'provider'?: CreateExchangeAndURLAPIRequestProviderEnum;
    /**
     * Transaction type
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'type'?: CreateExchangeAndURLAPIRequestTypeEnum;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'wallet_address'?: string;
    /**
     *
     * @type {WidgetParams}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'widget'?: WidgetParams;
}
declare const CreateExchangeAndURLAPIRequestProviderEnum: {
    readonly Moonpay: "moonpay";
    readonly Layerswap: "layerswap";
};
declare type CreateExchangeAndURLAPIRequestProviderEnum = typeof CreateExchangeAndURLAPIRequestProviderEnum[keyof typeof CreateExchangeAndURLAPIRequestProviderEnum];
declare const CreateExchangeAndURLAPIRequestTypeEnum: {
    readonly Onramp: "onramp";
    readonly Offramp: "offramp";
};
declare type CreateExchangeAndURLAPIRequestTypeEnum = typeof CreateExchangeAndURLAPIRequestTypeEnum[keyof typeof CreateExchangeAndURLAPIRequestTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateMetadataRefreshRequest
 */
interface CreateMetadataRefreshRequest {
    /**
     * The collection contract address
     * @type {string}
     * @memberof CreateMetadataRefreshRequest
     */
    'collection_address': string;
    /**
     * The tokens to refresh
     * @type {Array<string>}
     * @memberof CreateMetadataRefreshRequest
     */
    'token_ids': Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateMetadataRefreshResponse
 */
interface CreateMetadataRefreshResponse {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof CreateMetadataRefreshResponse
     */
    'refresh_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeEntry
 */
interface FeeEntry {
    /**
     *
     * @type {string}
     * @memberof FeeEntry
     */
    'address'?: string;
    /**
     *
     * @type {number}
     * @memberof FeeEntry
     */
    'fee_percentage'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateOrderRequestV3
 */
interface CreateOrderRequestV3 {
    /**
     * Amount to buy
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof CreateOrderRequestV3
     */
    'expiration_timestamp': number;
    /**
     * Fee information
     * @type {Array<FeeEntry>}
     * @memberof CreateOrderRequestV3
     */
    'fees'?: Array<FeeEntry>;
    /**
     * [DEPRECATED] Whether to include fees in order
     * @type {boolean}
     * @memberof CreateOrderRequestV3
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof CreateOrderRequestV3
     */
    'nonce': number;
    /**
     * Public stark key of the user creating order
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof CreateOrderRequestV3
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof CreateOrderRequestV3
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof CreateOrderRequestV3
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateOrderResponse
 */
interface CreateOrderResponse {
    /**
     * ID of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'order_id': number;
    /**
     * Request ID as a reference for an asynchronous order creation request
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'request_id'?: string;
    /**
     * Status of the created order
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'status': string;
    /**
     * Timestamp of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'time': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateProjectRequest
 */
interface CreateProjectRequest {
    /**
     * The company name
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'company_name': string;
    /**
     * The project contact email (must be registered as a developer account with Immutable at https://hub.immutable.com)
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'contact_email': string;
    /**
     * The project name
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'name': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateProjectResponse
 */
interface CreateProjectResponse {
    /**
     * The project group ID
     * @type {string}
     * @memberof CreateProjectResponse
     */
    'id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeInfo
 */
interface FeeInfo {
    /**
     * ID of the asset these fees relate to
     * @type {string}
     * @memberof FeeInfo
     */
    'asset_id': string;
    /**
     * Fee limit
     * @type {string}
     * @memberof FeeInfo
     */
    'fee_limit': string;
    /**
     * ID of vault the asset belong to
     * @type {number}
     * @memberof FeeInfo
     */
    'source_vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTradeResponse
 */
interface CreateTradeResponse {
    /**
     * Request ID as a reference for an asynchronous trade creation request
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'request_id'?: string;
    /**
     * Current status of trade
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'status': string;
    /**
     * ID of trade within Immutable X
     * @type {number}
     * @memberof CreateTradeResponse
     */
    'trade_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TransferRequest
 */
interface TransferRequest {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof TransferRequest
     */
    'receiver_vault_id': number;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof TransferRequest
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof TransferRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateTransferRequest
 */
interface CreateTransferRequest {
    /**
     * List of transfers
     * @type {Array<TransferRequest>}
     * @memberof CreateTransferRequest
     */
    'requests': Array<TransferRequest>;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'sender_stark_key': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferRequestV1
 */
interface CreateTransferRequestV1 {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'receiver_vault_id': number;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'sender_stark_key': string;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponse
 */
interface CreateTransferResponse {
    /**
     * List of transfer IDs
     * @type {Array<number>}
     * @memberof CreateTransferResponse
     */
    'transfer_ids': Array<number>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponseV1
 */
interface CreateTransferResponseV1 {
    /**
     * [deprecated] Sent signature
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'sent_signature': string;
    /**
     * [deprecated] The status of transfer
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'status': string;
    /**
     * [deprecated] Time of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'time': number;
    /**
     * ID of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'transfer_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponseV2
 */
interface CreateTransferResponseV2 {
    /**
     * List of transfer IDs
     * @type {Array<number>}
     * @memberof CreateTransferResponseV2
     */
    'transfer_ids': Array<number>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateWithdrawalRequest
 */
interface CreateWithdrawalRequest {
    /**
     * Amount to withdraw
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'amount': string;
    /**
     * The ID of asset the user is withdrawing
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'asset_id': string;
    /**
     * Nonce of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalRequest
     */
    'nonce': number;
    /**
     * Public stark key of the withdrawing user
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'stark_signature': string;
    /**
     * The ID of the vault the asset belong to
     * @type {number}
     * @memberof CreateWithdrawalRequest
     */
    'vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateWithdrawalResponse
 */
interface CreateWithdrawalResponse {
    /**
     * Status of the withdrawal
     * @type {string}
     * @memberof CreateWithdrawalResponse
     */
    'status': string;
    /**
     * Time of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'time': number;
    /**
     * ID of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'withdrawal_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CurrencyWithLimits
 */
interface CurrencyWithLimits {
    /**
     * Provider currency code
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'currency_code'?: string;
    /**
     *
     * @type {AggregateLimit}
     * @memberof CurrencyWithLimits
     */
    'limits'?: AggregateLimit;
    /**
     * Provider name (e.g. moonpay)
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'provider'?: string;
    /**
     * Currency Symbol
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'symbol'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type DepositToken
 * Details of the asset being deposited
 * @export
 */
declare type DepositToken = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Deposit
 */
interface Deposit {
    /**
     * Status of this deposit in Immutable X
     * @type {string}
     * @memberof Deposit
     */
    'status': string;
    /**
     * Timestamp of the deposit
     * @type {string}
     * @memberof Deposit
     */
    'timestamp': string;
    /**
     *
     * @type {DepositToken}
     * @memberof Deposit
     */
    'token': DepositToken;
    /**
     * Sequential ID of this transaction within Immutable X
     * @type {number}
     * @memberof Deposit
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user making this deposit
     * @type {string}
     * @memberof Deposit
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface OptionalExchangeData
 */
interface OptionalExchangeData {
    /**
     * Provider transaction ID
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'external_id'?: string;
    /**
     * Fees amount
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'fees_amount'?: number;
    /**
     * Amount that was exchanged from
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'from_amount'?: number;
    /**
     * Currency that was exchanged from
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'from_currency'?: string;
    /**
     * Provider wallet address that was used for transferring crypto
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'provider_wallet_address'?: string;
    /**
     * Amount that was exchanged to
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'to_amount'?: number;
    /**
     * Currency that was exchanged to
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'to_currency'?: string;
    /**
     * Transfer ID
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'transfer_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Exchange
 */
interface Exchange {
    /**
     * Time this transaction was created
     * @type {string}
     * @memberof Exchange
     */
    'created_at'?: string;
    /**
     *
     * @type {OptionalExchangeData}
     * @memberof Exchange
     */
    'data'?: OptionalExchangeData;
    /**
     * Transaction ID
     * @type {number}
     * @memberof Exchange
     */
    'id'?: number;
    /**
     * Provider name
     * @type {string}
     * @memberof Exchange
     */
    'provider'?: string;
    /**
     * Transaction status
     * @type {string}
     * @memberof Exchange
     */
    'status'?: string;
    /**
     * Transaction type
     * @type {string}
     * @memberof Exchange
     */
    'type'?: string;
    /**
     * Time this transaction was updates
     * @type {string}
     * @memberof Exchange
     */
    'updated_at'?: string;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof Exchange
     */
    'wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ExchangeCreateExchangeAndURLResponse
 */
interface ExchangeCreateExchangeAndURLResponse {
    /**
     * Created transaction ID
     * @type {number}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'id'?: number;
    /**
     * Provider name (e.g. moonpay)
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'provider'?: string;
    /**
     * Transaction type
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'type'?: string;
    /**
     * Widget URL
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'url'?: string;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshErrors
 */
interface MetadataRefreshErrors {
    /**
     * Metadata API response for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_response_body': string | null;
    /**
     * Metadata API response code for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_response_status_code': string | null;
    /**
     * Requested metadata url for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_token_metadata_url': string;
    /**
     * The collection contract address
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'collection_address': string;
    /**
     * When the error was created
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'created_at': string;
    /**
     * Metadata refresh error code
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'error_code': string;
    /**
     * The token ID
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'token_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshErrorsResponse
 */
interface GetMetadataRefreshErrorsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'remaining': number;
    /**
     * Metadata refresh errors matching query parameters
     * @type {Array<MetadataRefreshErrors>}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'result': Array<MetadataRefreshErrors>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshSummary
 */
interface MetadataRefreshSummary {
    /**
     * The number of tokens with failed metadata refreshes
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'failed'?: number;
    /**
     * The number of tokens that has not been refreshed yet
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'pending'?: number;
    /**
     * The number of tokens with successful metadata refreshes
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'succeeded'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshResponse
 */
interface GetMetadataRefreshResponse {
    /**
     * The collection address
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'collection_address': string;
    /**
     * When the metadata refresh completed
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'completed_at'?: string | null;
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'refresh_id': string;
    /**
     * When the metadata refresh started
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'started_at': string;
    /**
     * The metadata refresh status
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'status': GetMetadataRefreshResponseStatusEnum;
    /**
     * The current metadata refresh summary. The summary continue to update until metadata refresh is completed
     * @type {Array<MetadataRefreshSummary>}
     * @memberof GetMetadataRefreshResponse
     */
    'summary': Array<MetadataRefreshSummary>;
}
declare const GetMetadataRefreshResponseStatusEnum: {
    readonly Queued: "queued";
    readonly InProgress: "in_progress";
    readonly Completed: "completed";
};
declare type GetMetadataRefreshResponseStatusEnum = typeof GetMetadataRefreshResponseStatusEnum[keyof typeof GetMetadataRefreshResponseStatusEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshExcludingSummary
 */
interface MetadataRefreshExcludingSummary {
    /**
     * The collection address
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'collection_address': string;
    /**
     * When the metadata refresh completed
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'completed_at'?: string | null;
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'refresh_id': string;
    /**
     * When the metadata refresh started
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'started_at': string;
    /**
     * The metadata refresh status
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'status': MetadataRefreshExcludingSummaryStatusEnum;
}
declare const MetadataRefreshExcludingSummaryStatusEnum: {
    readonly Queued: "queued";
    readonly InProgress: "in_progress";
    readonly Completed: "completed";
};
declare type MetadataRefreshExcludingSummaryStatusEnum = typeof MetadataRefreshExcludingSummaryStatusEnum[keyof typeof MetadataRefreshExcludingSummaryStatusEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshes
 */
interface GetMetadataRefreshes {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetMetadataRefreshes
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetMetadataRefreshes
     */
    'remaining': number;
    /**
     * Metadata refresh errors matching query parameters
     * @type {Array<MetadataRefreshExcludingSummary>}
     * @memberof GetMetadataRefreshes
     */
    'result': Array<MetadataRefreshExcludingSummary>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Project
 */
interface Project {
    /**
     * The project ChainType
     * @type {string}
     * @memberof Project
     */
    'chain_type'?: string;
    /**
     * The project group ID
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * The project group name
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * The organisation ID that the project belongs to
     * @type {string}
     * @memberof Project
     */
    'org_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetProjectsResponse
 */
interface GetProjectsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetProjectsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetProjectsResponse
     */
    'remaining': number;
    /**
     * Projects matching query parameters
     * @type {Array<Project>}
     * @memberof GetProjectsResponse
     */
    'result': Array<Project>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableCancelOrderRequest
 */
interface GetSignableCancelOrderRequest {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof GetSignableCancelOrderRequest
     */
    'order_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableCancelOrderResponse
 */
interface GetSignableCancelOrderResponse {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof GetSignableCancelOrderResponse
     */
    'order_id': number;
    /**
     * Hash of the payload to be signed for cancel order
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx cancel order request to be displayed to the user
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'readable_transaction': string;
    /**
     * Message to sign from wallet to confirm cancel order
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'signable_message': string;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface SignableToken
 */
interface SignableToken {
    /**
     * Token data. See https://docs.x.immutable.com/docs/token-data-object
     * @type {object}
     * @memberof SignableToken
     */
    'data'?: object;
    /**
     * Type of token
     * @type {string}
     * @memberof SignableToken
     */
    'type'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableDepositRequestToken
 * Details of the token the user is depositing
 * @export
 */
declare type GetSignableDepositRequestToken = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableDepositRequest
 */
interface GetSignableDepositRequest {
    /**
     * Amount of the token the user is depositing
     * @type {string}
     * @memberof GetSignableDepositRequest
     */
    'amount': string;
    /**
     *
     * @type {GetSignableDepositRequestToken}
     * @memberof GetSignableDepositRequest
     */
    'token': GetSignableDepositRequestToken;
    /**
     * User who is depositing
     * @type {string}
     * @memberof GetSignableDepositRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableDepositResponse
 */
interface GetSignableDepositResponse {
    /**
     * Amount this user is depositing
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'amount': string;
    /**
     * ID of the asset this user is depositing
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'asset_id': string;
    /**
     * Nonce of the deposit
     * @type {number}
     * @memberof GetSignableDepositResponse
     */
    'nonce': number;
    /**
     * Public stark key of the depositing user
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'stark_key': string;
    /**
     * ID of the vault this user is depositing to
     * @type {number}
     * @memberof GetSignableDepositResponse
     */
    'vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableOrderRequestV3TokenBuy
 * Token to buy
 * @export
 */
declare type GetSignableOrderRequestV3TokenBuy = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableOrderRequestV3TokenSell
 * Token to sell
 * @export
 */
declare type GetSignableOrderRequestV3TokenSell = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableOrderRequestV3
 */
interface GetSignableOrderRequestV3 {
    /**
     * Fee-exclusive amount to buy the asset
     * @type {string}
     * @memberof GetSignableOrderRequestV3
     */
    'amount_buy': string;
    /**
     * Amount to sell (quantity)
     * @type {string}
     * @memberof GetSignableOrderRequestV3
     */
    'amount_sell': string;
    /**
     * ExpirationTimestamp in Unix time in hours. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableOrderRequestV3
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<FeeEntry>}
     * @memberof GetSignableOrderRequestV3
     */
    'fees'?: Array<FeeEntry>;
    /**
     * SplitFees is a deprecated field. It\'s value is ignored.
     * @type {boolean}
     * @memberof GetSignableOrderRequestV3
     */
    'split_fees'?: boolean;
    /**
     *
     * @type {GetSignableOrderRequestV3TokenBuy}
     * @memberof GetSignableOrderRequestV3
     */
    'token_buy': GetSignableOrderRequestV3TokenBuy;
    /**
     *
     * @type {GetSignableOrderRequestV3TokenSell}
     * @memberof GetSignableOrderRequestV3
     */
    'token_sell': GetSignableOrderRequestV3TokenSell;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof GetSignableOrderRequestV3
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableOrderResponseFeeInfo
 * Fee information
 * @export
 */
declare type GetSignableOrderResponseFeeInfo = FeeInfo;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableOrderResponse
 */
interface GetSignableOrderResponse {
    /**
     * Fee-exclusive amount to buy
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'asset_id_sell': string;
    /**
     * ExpirationTimestamp in Unix time in hours. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {GetSignableOrderResponseFeeInfo}
     * @memberof GetSignableOrderResponse
     */
    'fee_info'?: GetSignableOrderResponseFeeInfo;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'nonce': number;
    /**
     * Hash of the payload to be signed for signable order
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx order transaction to be displayed to the user
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'readable_transaction': string;
    /**
     * Message to sign with L1 wallet to confirm order request
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'signable_message': string;
    /**
     * Public stark key of the created user
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'stark_key': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'vault_id_sell': number;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationOffchainResponse
 */
interface GetSignableRegistrationOffchainResponse {
    /**
     * Hash of the payload to be signed for user registration offchain
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx Register User Offchain request to be displayed to the user
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'readable_transaction': string;
    /**
     * Message to sign with L1 wallet to register user offchain
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'signable_message': string;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationRequest
 */
interface GetSignableRegistrationRequest {
    /**
     * Ether key of user
     * @type {string}
     * @memberof GetSignableRegistrationRequest
     */
    'ether_key': string;
    /**
     * Public stark key of the user
     * @type {string}
     * @memberof GetSignableRegistrationRequest
     */
    'stark_key': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationResponse
 */
interface GetSignableRegistrationResponse {
    /**
     * Signature from authorised operator
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'operator_signature': string;
    /**
     * Hash of the payload to be signed for user registration
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx Register User request to be displayed to the user
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'readable_transaction': string;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTradeRequest
 */
interface GetSignableTradeRequest {
    /**
     * ExpirationTimestamp in Unix time in hours. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<FeeEntry>}
     * @memberof GetSignableTradeRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     * The ID of the maker order involved
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'order_id': number;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof GetSignableTradeRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableTradeResponseFeeInfo
 * Fee information
 * @export
 */
declare type GetSignableTradeResponseFeeInfo = FeeInfo;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTradeResponse
 */
interface GetSignableTradeResponse {
    /**
     * Amount to buy
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'asset_id_sell': string;
    /**
     * ExpirationTimestamp in Unix time in hours. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {GetSignableTradeResponseFeeInfo}
     * @memberof GetSignableTradeResponse
     */
    'fee_info'?: GetSignableTradeResponseFeeInfo;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'nonce': number;
    /**
     * Payload Hash
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx trade transaction to be displayed to the user
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'readable_transaction': string;
    /**
     * Message to sign with L1 wallet to confirm trade request
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'signable_message': string;
    /**
     * Public stark key of the created user
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'stark_key': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'vault_id_sell': number;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableTransferRequestToken
 * Token to transfer
 * @export
 */
declare type GetSignableTransferRequestToken = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferRequest
 */
interface GetSignableTransferRequest {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof GetSignableTransferRequest
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof GetSignableTransferRequest
     */
    'receiver': string;
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof GetSignableTransferRequest
     */
    'sender': string;
    /**
     *
     * @type {GetSignableTransferRequestToken}
     * @memberof GetSignableTransferRequest
     */
    'token': GetSignableTransferRequestToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferRequestV1
 */
interface GetSignableTransferRequestV1 {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'receiver': string;
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'sender': string;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableTransferRequestV1
     */
    'token': SignableToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type SignableTransferDetailsV2Token
 * Token to transfer
 * @export
 */
declare type SignableTransferDetailsV2Token = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface SignableTransferDetailsV2
 */
interface SignableTransferDetailsV2 {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof SignableTransferDetailsV2
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof SignableTransferDetailsV2
     */
    'receiver': string;
    /**
     *
     * @type {SignableTransferDetailsV2Token}
     * @memberof SignableTransferDetailsV2
     */
    'token': SignableTransferDetailsV2Token;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferRequestV2
 */
interface GetSignableTransferRequestV2 {
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof GetSignableTransferRequestV2
     */
    'sender_ether_key': string;
    /**
     * List of signable transfer details
     * @type {Array<SignableTransferDetailsV2>}
     * @memberof GetSignableTransferRequestV2
     */
    'signable_requests': Array<SignableTransferDetailsV2>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type SignableTransferResponseDetailsToken
 * Token in request to match in SDK implementation
 * @export
 */
declare type SignableTransferResponseDetailsToken = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface SignableTransferResponseDetails
 */
interface SignableTransferResponseDetails {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'amount': string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'asset_id': string;
    /**
     * Timestamp when this transfer will expire
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'nonce': number;
    /**
     * Hash of the payload to be signed for transfer
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx transfer request to be displayed to the user
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'readable_transaction': string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'receiver_vault_id': number;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'sender_vault_id': number;
    /**
     *
     * @type {SignableTransferResponseDetailsToken}
     * @memberof SignableTransferResponseDetails
     */
    'token': SignableTransferResponseDetailsToken;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableTransferResponseV1
 */
interface GetSignableTransferResponseV1 {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'amount': string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'asset_id': string;
    /**
     * Token in request to match in SDK implementation
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'nonce': number;
    /**
     * Hash of the payload
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx transfer transaction to be displayed to the user
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'readable_transaction': string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'receiver_vault_id': number;
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'sender_stark_key'?: string;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'sender_vault_id': number;
    /**
     * Message to sign with L1 wallet to confirm transfer request
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'signable_message': string;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferResponseV2
 */
interface GetSignableTransferResponseV2 {
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponseV2
     */
    'sender_stark_key': string;
    /**
     * Message to sign with L1 wallet to confirm transfer request
     * @type {string}
     * @memberof GetSignableTransferResponseV2
     */
    'signable_message': string;
    /**
     * List of transfer responses without the sender stark key
     * @type {Array<SignableTransferResponseDetails>}
     * @memberof GetSignableTransferResponseV2
     */
    'signable_responses': Array<SignableTransferResponseDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type GetSignableWithdrawalRequestToken
 * Token to withdraw
 * @export
 */
declare type GetSignableWithdrawalRequestToken = SignableToken;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableWithdrawalRequest
 */
interface GetSignableWithdrawalRequest {
    /**
     * Amount of the token to withdraw
     * @type {string}
     * @memberof GetSignableWithdrawalRequest
     */
    'amount': string;
    /**
     *
     * @type {GetSignableWithdrawalRequestToken}
     * @memberof GetSignableWithdrawalRequest
     */
    'token': GetSignableWithdrawalRequestToken;
    /**
     * Ethereum address of the user who is making this withdrawal
     * @type {string}
     * @memberof GetSignableWithdrawalRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableWithdrawalResponse
 */
interface GetSignableWithdrawalResponse {
    /**
     * Amount of the token we are withdrawing
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'amount': string;
    /**
     * ID of the asset to be withdrawn
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'asset_id': string;
    /**
     * Nonce of this transaction
     * @type {number}
     * @memberof GetSignableWithdrawalResponse
     */
    'nonce': number;
    /**
     * Encoded payload hash
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'payload_hash': string;
    /**
     * EIP-712 encoding of the StarkEx withdrawal request to be displayed to the user
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'readable_transaction': string;
    /**
     * Message to sign with L1 wallet to verity withdrawal request
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'signable_message': string;
    /**
     * Public stark key of this user
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'stark_key': string;
    /**
     * ID of the vault we are withdrawing from
     * @type {number}
     * @memberof GetSignableWithdrawalResponse
     */
    'vault_id': number;
    /**
     * IMX signed readable_transaction and payload_hash
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'verification_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetTransactionsResponse
 */
interface GetTransactionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetTransactionsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetTransactionsResponse
     */
    'remaining'?: number;
    /**
     * Transactions matching query parameters
     * @type {Array<Exchange>}
     * @memberof GetTransactionsResponse
     */
    'result'?: Array<Exchange>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetUsersApiResponse
 */
interface GetUsersApiResponse {
    /**
     * Accounts
     * @type {Array<string>}
     * @memberof GetUsersApiResponse
     */
    'accounts': Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListAssetsResponse
 */
interface ListAssetsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListAssetsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListAssetsResponse
     */
    'remaining': number;
    /**
     * Assets matching query parameters
     * @type {Array<AssetWithOrders>}
     * @memberof ListAssetsResponse
     */
    'result': Array<AssetWithOrders>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListBalancesResponse
 */
interface ListBalancesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListBalancesResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListBalancesResponse
     */
    'remaining': number;
    /**
     * Dictionary of tokens
     * @type {Array<Balance>}
     * @memberof ListBalancesResponse
     */
    'result': Array<Balance>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListCollectionsResponse
 */
interface ListCollectionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListCollectionsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListCollectionsResponse
     */
    'remaining': number;
    /**
     * Collections matching query parameters
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    'result': Array<Collection>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListDepositsResponse
 */
interface ListDepositsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListDepositsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListDepositsResponse
     */
    'remaining': number;
    /**
     * Deposits matching query parameters
     * @type {Array<Deposit>}
     * @memberof ListDepositsResponse
     */
    'result': Array<Deposit>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type MintToken
 * Details of the asset which has been minted
 * @export
 */
declare type MintToken = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Mint
 */
interface Mint {
    /**
     * Fee details
     * @type {Array<Fee>}
     * @memberof Mint
     */
    'fees'?: Array<Fee$1>;
    /**
     * Status of this mint
     * @type {string}
     * @memberof Mint
     */
    'status': string;
    /**
     * Timestamp this mint was initiated
     * @type {string}
     * @memberof Mint
     */
    'timestamp': string;
    /**
     *
     * @type {MintToken}
     * @memberof Mint
     */
    'token': MintToken;
    /**
     * Sequential ID of transaction in Immutable X
     * @type {number}
     * @memberof Mint
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user to whom the asset has been minted
     * @type {string}
     * @memberof Mint
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListMintsResponse
 */
interface ListMintsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListMintsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListMintsResponse
     */
    'remaining': number;
    /**
     * Mints matching query parameters
     * @type {Array<Mint>}
     * @memberof ListMintsResponse
     */
    'result': Array<Mint>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type OrderV3Buy
 * Details of the asset being bought
 * @export
 */
declare type OrderV3Buy = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface OrdersMakerTakerFee
 */
interface OrdersMakerTakerFee {
    /**
     * Number of Decimals supported the fee token
     * @type {number}
     * @memberof OrdersMakerTakerFee
     */
    'decimals'?: number;
    /**
     * Fees
     * @type {Array<OrderFeeInfo>}
     * @memberof OrdersMakerTakerFee
     */
    'fees'?: Array<OrderFeeInfo>;
    /**
     * Quantity of this asset with the sum of all fees applied to the asset
     * @type {string}
     * @memberof OrdersMakerTakerFee
     */
    'quantity_with_fees': string;
    /**
     * Symbol of the fee token
     * @type {string}
     * @memberof OrdersMakerTakerFee
     */
    'symbol'?: string;
    /**
     * Address of the ERC20 contract for the fee token
     * @type {string}
     * @memberof OrdersMakerTakerFee
     */
    'token_address'?: string;
    /**
     * Type of the fee token (ETH/ERC20)
     * @type {string}
     * @memberof OrdersMakerTakerFee
     */
    'token_type'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type OrderV3MakerFees
 * MakerFees is the information about the fees that needs to be paid by the maker (liquidity)
 * @export
 */
declare type OrderV3MakerFees = OrdersMakerTakerFee;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type OrderV3Sell
 * Details of the asset being sold
 * @export
 */
declare type OrderV3Sell = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type OrderV3TakerFees
 * TakerFees is the information about the fees that needs to be paid by the taker (liquidity)
 * @export
 */
declare type OrderV3TakerFees = OrdersMakerTakerFee;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface OrderV3
 */
interface OrderV3 {
    /**
     * Amount of the asset already sold by this order
     * @type {string}
     * @memberof OrderV3
     */
    'amount_sold': string | null;
    /**
     *
     * @type {OrderV3Buy}
     * @memberof OrderV3
     */
    'buy': OrderV3Buy;
    /**
     * Expiration timestamp of this order
     * @type {string}
     * @memberof OrderV3
     */
    'expiration_timestamp': string | null;
    /**
     * [DEPRECATED] Fee information for the order. Replaced by maker_fees / taker_fees depending on the type of order. Refer https://docs.x.immutable.com/docs/maker-taker-fees/#new-maker-taker-fields-and-the-deprecation-of-quantity_with_fees-in-buy-and-sell.
     * @type {Array<OrderFeeInfo>}
     * @memberof OrderV3
     */
    'fees'?: Array<OrderFeeInfo>;
    /**
     *
     * @type {OrderV3MakerFees}
     * @memberof OrderV3
     */
    'maker_fees'?: OrderV3MakerFees;
    /**
     * MakerTakerType
     * @type {string}
     * @memberof OrderV3
     */
    'maker_taker_type'?: string;
    /**
     * ID of the order
     * @type {number}
     * @memberof OrderV3
     */
    'order_id': number;
    /**
     *
     * @type {OrderV3Sell}
     * @memberof OrderV3
     */
    'sell': OrderV3Sell;
    /**
     * Status of the order
     * @type {string}
     * @memberof OrderV3
     */
    'status': string;
    /**
     *
     * @type {OrderV3TakerFees}
     * @memberof OrderV3
     */
    'taker_fees'?: OrderV3TakerFees;
    /**
     * Timestamp this order was created
     * @type {string}
     * @memberof OrderV3
     */
    'timestamp': string | null;
    /**
     * Updated timestamp of this order
     * @type {string}
     * @memberof OrderV3
     */
    'updated_timestamp': string | null;
    /**
     * Ethereum address of the user who submitted the order
     * @type {string}
     * @memberof OrderV3
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListOrdersResponseV3
 */
interface ListOrdersResponseV3 {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListOrdersResponseV3
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListOrdersResponseV3
     */
    'remaining': number;
    /**
     * Orders matching query parameters
     * @type {Array<OrderV3>}
     * @memberof ListOrdersResponseV3
     */
    'result': Array<OrderV3>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TokenDetails
 */
interface TokenDetails {
    /**
     * Number of decimals for token
     * @type {string}
     * @memberof TokenDetails
     */
    'decimals': string;
    /**
     * Url for the icon of the token
     * @type {string}
     * @memberof TokenDetails
     */
    'image_url': string;
    /**
     * Full name of the token (e.g. Ether)
     * @type {string}
     * @memberof TokenDetails
     */
    'name': string;
    /**
     * Quantum for token
     * @type {string}
     * @memberof TokenDetails
     */
    'quantum': string;
    /**
     * Ticker symbol for token (e.g. ETH/USDC/IMX)
     * @type {string}
     * @memberof TokenDetails
     */
    'symbol': string;
    /**
     * Address of the ERC20 contract
     * @type {string}
     * @memberof TokenDetails
     */
    'token_address': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTokensResponse
 */
interface ListTokensResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTokensResponse
     */
    'cursor': string;
    /**
     * Tokens matching query parameters
     * @type {Array<TokenDetails>}
     * @memberof ListTokensResponse
     */
    'result': Array<TokenDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TradeSide
 */
interface TradeSide {
    /**
     * The ID of the order involved in the trade
     * @type {number}
     * @memberof TradeSide
     */
    'order_id': number;
    /**
     * The amount of that order\'s asset this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'sold': string;
    /**
     * The contract address of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_address'?: string;
    /**
     * The ID of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_id'?: string;
    /**
     * The type of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TradeA
 * Side A of this trade (the buy order)
 * @export
 */
declare type TradeA = TradeSide;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TradeB
 * Side B of this trade (the sell order)
 * @export
 */
declare type TradeB = TradeSide;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Trade
 */
interface Trade {
    /**
     *
     * @type {TradeA}
     * @memberof Trade
     */
    'a': TradeA;
    /**
     *
     * @type {TradeB}
     * @memberof Trade
     */
    'b': TradeB;
    /**
     * Status of this trade
     * @type {string}
     * @memberof Trade
     */
    'status': string;
    /**
     * Time this trade occurred
     * @type {string}
     * @memberof Trade
     */
    'timestamp': string | null;
    /**
     * Sequential ID of this trade within Immutable X
     * @type {number}
     * @memberof Trade
     */
    'transaction_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTradesResponse
 */
interface ListTradesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTradesResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListTradesResponse
     */
    'remaining': number;
    /**
     * Trades matching query parameters
     * @type {Array<Trade>}
     * @memberof ListTradesResponse
     */
    'result': Array<Trade>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TransferToken
 * Token transferred by the user
 * @export
 */
declare type TransferToken = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Transfer
 */
interface Transfer {
    /**
     * Ethereum address of the user who received this transfer
     * @type {string}
     * @memberof Transfer
     */
    'receiver': string;
    /**
     * Status of the transaction
     * @type {string}
     * @memberof Transfer
     */
    'status': string;
    /**
     * Timestamp of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'timestamp': string | null;
    /**
     *
     * @type {TransferToken}
     * @memberof Transfer
     */
    'token': TransferToken;
    /**
     * Sequential transaction ID
     * @type {number}
     * @memberof Transfer
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user  who submitted this transfer
     * @type {string}
     * @memberof Transfer
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTransfersResponse
 */
interface ListTransfersResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTransfersResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListTransfersResponse
     */
    'remaining': number;
    /**
     * Transfers matching query parameters
     * @type {Array<Transfer>}
     * @memberof ListTransfersResponse
     */
    'result': Array<Transfer>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type WithdrawalToken
 * Details of the asset this user is withdrawing
 * @export
 */
declare type WithdrawalToken = Token;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Withdrawal
 */
interface Withdrawal {
    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'rollup_status': string;
    /**
     * Ethereum address of the user who requested this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'sender': string;
    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'status': string;
    /**
     * Time when this withdrawal was initiated
     * @type {string}
     * @memberof Withdrawal
     */
    'timestamp': string;
    /**
     *
     * @type {WithdrawalToken}
     * @memberof Withdrawal
     */
    'token': WithdrawalToken;
    /**
     * Sequential ID of this transaction
     * @type {number}
     * @memberof Withdrawal
     */
    'transaction_id': number;
    /**
     * Withdrawal has been transferred to user\'s Layer 1 wallet
     * @type {boolean}
     * @memberof Withdrawal
     */
    'withdrawn_to_wallet': boolean;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListWithdrawalsResponse
 */
interface ListWithdrawalsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListWithdrawalsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListWithdrawalsResponse
     */
    'remaining': number;
    /**
     * Withdrawals matching query parameters
     * @type {Array<Withdrawal>}
     * @memberof ListWithdrawalsResponse
     */
    'result': Array<Withdrawal>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataSchemaProperty
 */
interface MetadataSchemaProperty {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof MetadataSchemaProperty
     */
    'filterable': boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof MetadataSchemaProperty
     */
    'name': string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof MetadataSchemaProperty
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintFee
 */
interface MintFee {
    /**
     * Fee percentage
     * @type {number}
     * @memberof MintFee
     */
    'percentage': number;
    /**
     * Recipient wallet address
     * @type {string}
     * @memberof MintFee
     */
    'recipient': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintTokenDataV2
 */
interface MintTokenDataV2 {
    /**
     * Token metadata blueprint
     * @type {string}
     * @memberof MintTokenDataV2
     */
    'blueprint': string;
    /**
     * Token ID Note: While the Token ID is required to be a string, it still needs to be a valid uint256 as per the ERC-721 token standard.
     * @type {string}
     * @memberof MintTokenDataV2
     */
    'id': string;
    /**
     * List of mint fees
     * @type {Array<MintFee>}
     * @memberof MintTokenDataV2
     */
    'royalties'?: Array<MintFee>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintUser
 */
interface MintUser {
    /**
     * List of Mint tokens
     * @type {Array<MintTokenDataV2>}
     * @memberof MintUser
     */
    'tokens': Array<MintTokenDataV2>;
    /**
     * User wallet address
     * @type {string}
     * @memberof MintUser
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintRequest
 */
interface MintRequest {
    /**
     * Signature from authorised minter
     * @type {string}
     * @memberof MintRequest
     */
    'auth_signature': string;
    /**
     * minting contract
     * @type {string}
     * @memberof MintRequest
     */
    'contract_address': string;
    /**
     * Global contract-level royalty fees
     * @type {Array<MintFee>}
     * @memberof MintRequest
     */
    'royalties'?: Array<MintFee>;
    /**
     * Users to mint to
     * @type {Array<MintUser>}
     * @memberof MintRequest
     */
    'users': Array<MintUser>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintResultDetails
 */
interface MintResultDetails {
    /**
     * Contract address of this token
     * @type {string}
     * @memberof MintResultDetails
     */
    'contract_address': string;
    /**
     * IMX ID of this token
     * @type {string}
     * @memberof MintResultDetails
     */
    'token_id': string;
    /**
     * Mint Transaction ID
     * @type {number}
     * @memberof MintResultDetails
     */
    'tx_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintTokensResponse
 */
interface MintTokensResponse {
    /**
     * List of mint result details
     * @type {Array<MintResultDetails>}
     * @memberof MintTokensResponse
     */
    'results': Array<MintResultDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintableTokenDetails
 */
interface MintableTokenDetails {
    /**
     * Blueprint of this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'blueprint': string;
    /**
     * ID provided by the client for this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'client_token_id': string;
    /**
     * IMX Id of this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'token_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionWidgetParams
 */
interface NftprimarytransactionWidgetParams {
    /**
     * enums(light, dark)
     * @type {string}
     * @memberof NftprimarytransactionWidgetParams
     */
    'theme'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NftprimarytransactionCreateAPIRequest
 */
interface NftprimarytransactionCreateAPIRequest {
    /**
     * Contract address of the asset to be created
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'contract_address'?: string;
    /**
     * Temporary asset id
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'provider'?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'user_wallet_address'?: string;
    /**
     *
     * @type {NftprimarytransactionWidgetParams}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'widget'?: NftprimarytransactionWidgetParams;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionCreateResponse
 */
interface NftprimarytransactionCreateResponse {
    /**
     * Contract address of the asset to be created
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'contract_address'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'provider'?: string;
    /**
     * Wallet address that will receive the payment (in crypto) from the checkout provider for the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'seller_wallet_address'?: string;
    /**
     * ID of the token that has been successfully minted - should be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'transaction_id'?: string;
    /**
     * NFT purchase URL given by the checkout provider that the user can use to complete payment
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'url'?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionGetResponse
 */
interface NftprimarytransactionGetResponse {
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'contract_address'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'provider'?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'seller_wallet_address'?: string;
    /**
     * Transaction status enums(created, waitingPayment, pending, completed, failed)
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'status'?: string;
    /**
     * ID of the token that has been successfully minted - might or not be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'transaction_id'?: string;
    /**
     * Wallet address that receives the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionTransactionData
 */
interface NftprimarytransactionTransactionData {
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'contract_address'?: string;
    /**
     * Timestamp when the transaction was created
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'created_at'?: string;
    /**
     * External transaction id
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'external_id'?: string;
    /**
     * Fees to pay on this transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'fees_amount'?: number;
    /**
     * Amount of the currency specified in `from_currency` that the buyer paid for the transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'from_amount'?: number;
    /**
     * Currency that the buyer used for the transaction
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'from_currency'?: string;
    /**
     * Minting transaction ID - see mintTokens response
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'mint_id'?: string;
    /**
     * Mint status
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'mint_status'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'provider'?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'seller_wallet_address'?: string;
    /**
     * Transaction status enums(created, waitingPayment, pending, completed, failed)
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'status'?: string;
    /**
     * Amount of the currency specified in `to_currency` that the seller received from the checkout provider for the transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'to_amount'?: number;
    /**
     * Currency (crypto) that the checkout provider sent to the seller for the transaction
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'to_currency'?: string;
    /**
     * ID of the token that has been successfully minted - should be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'transaction_id'?: string;
    /**
     * Timestamp when the transaction was updated
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'updated_at'?: string;
    /**
     * Wallet address that receives the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NftprimarytransactionListTransactionsResponse
 */
interface NftprimarytransactionListTransactionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'remaining'?: number;
    /**
     * Transactions matching query parameters
     * @type {Array<NftprimarytransactionTransactionData>}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'result'?: Array<NftprimarytransactionTransactionData>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterPassportUserResult
 */
interface RegisterPassportUserResult {
    /**
     * The ether key of the user
     * @type {string}
     * @memberof RegisterPassportUserResult
     */
    'ether_key'?: string;
    /**
     * The stark key of the user
     * @type {string}
     * @memberof RegisterPassportUserResult
     */
    'stark_key'?: string;
    /**
     * The admin key of the user
     * @type {string}
     * @memberof RegisterPassportUserResult
     */
    'user_admin_key'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterUserRequest
 */
interface RegisterUserRequest {
    /**
     * User email
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email'?: string;
    /**
     * Eth signature
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'eth_signature': string;
    /**
     * The ether key of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'ether_key': string;
    /**
     * Public stark key of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterUserResponse
 */
interface RegisterUserResponse {
    /**
     * Immutable signature authorising registration
     * @type {string}
     * @memberof RegisterUserResponse
     */
    'tx_hash': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface SuccessResponse
 */
interface SuccessResponse {
    /**
     *
     * @type {string}
     * @memberof SuccessResponse
     */
    'result': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type TradesCreateTradeRequestFeeInfo
 * Fee details
 * @export
 */
declare type TradesCreateTradeRequestFeeInfo = FeeInfo;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface TradesCreateTradeRequest
 */
interface TradesCreateTradeRequest {
    /**
     * Amount to buy
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this trade
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {TradesCreateTradeRequestFeeInfo}
     * @memberof TradesCreateTradeRequest
     */
    'fee_info'?: TradesCreateTradeRequestFeeInfo;
    /**
     * Fee information
     * @type {Array<FeeEntry>}
     * @memberof TradesCreateTradeRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     * [deprecated] All orders include fees since the introduction of protocol fees
     * @type {boolean}
     * @memberof TradesCreateTradeRequest
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the trade
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'nonce': number;
    /**
     * ID of the order
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'order_id': number;
    /**
     * Public stark key of the user creating trade
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof TradesCreateTradeRequest
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the traded asset will be placed
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof TradesCreateTradeRequest
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface UpdateCollectionRequest
 */
interface UpdateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'name'?: string;
}
/**
 * Request parameters for getAsset operation in AssetsApi.
 * @export
 * @interface AssetsApiGetAssetRequest
 */
interface AssetsApiGetAssetRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof AssetsApiGetAsset
     */
    readonly tokenAddress: string;
    /**
     * Either ERC721 token ID or internal IMX ID
     * @type {string}
     * @memberof AssetsApiGetAsset
     */
    readonly tokenId: string;
    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof AssetsApiGetAsset
     */
    readonly includeFees?: boolean;
}
/**
 * Request parameters for listAssets operation in AssetsApi.
 * @export
 * @interface AssetsApiListAssetsRequest
 */
interface AssetsApiListAssetsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof AssetsApiListAssets
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'updated_at' | 'name'}
     * @memberof AssetsApiListAssets
     */
    readonly orderBy?: 'updated_at' | 'name';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who owns these assets
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly user?: string;
    /**
     * Status of these assets
     * @type {'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned'}
     * @memberof AssetsApiListAssets
     */
    readonly status?: 'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned';
    /**
     * Name of the asset to search
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly name?: string;
    /**
     * URL JSON-encoded metadata filters for these assets. Javascript example: encodeURI(JSON.stringify({\&#39;proto\&#39;:[\&#39;1147\&#39;],\&#39;quality\&#39;:[\&#39;Meteorite\&#39;]}))
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly metadata?: string;
    /**
     * Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly sellOrders?: boolean;
    /**
     * Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly buyOrders?: boolean;
    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly includeFees?: boolean;
    /**
     * Collection contract address
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly collection?: string;
    /**
     * Minimum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly updatedMinTimestamp?: string;
    /**
     * Maximum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly updatedMaxTimestamp?: string;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly auxiliaryFeeRecipients?: string;
}
/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
declare class AssetsApi extends BaseAPI {
    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {AssetsApiGetAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    getAsset(requestParameters: AssetsApiGetAssetRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Asset, any>>;
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {AssetsApiListAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    listAssets(requestParameters?: AssetsApiListAssetsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListAssetsResponse, any>>;
}
/**
 * Request parameters for getBalance operation in BalancesApi.
 * @export
 * @interface BalancesApiGetBalanceRequest
 */
interface BalancesApiGetBalanceRequest {
    /**
     * Address of the owner/user
     * @type {string}
     * @memberof BalancesApiGetBalance
     */
    readonly owner: string;
    /**
     * Token address or \&#39;eth\&#39;
     * @type {string}
     * @memberof BalancesApiGetBalance
     */
    readonly address: string;
}
/**
 * Request parameters for listBalances operation in BalancesApi.
 * @export
 * @interface BalancesApiListBalancesRequest
 */
interface BalancesApiListBalancesRequest {
    /**
     * Ethereum wallet address for user
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly owner: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof BalancesApiListBalances
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly direction?: string;
}
/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
declare class BalancesApi extends BaseAPI {
    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {BalancesApiGetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    getBalance(requestParameters: BalancesApiGetBalanceRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Balance, any>>;
    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {BalancesApiListBalancesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    listBalances(requestParameters: BalancesApiListBalancesRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListBalancesResponse, any>>;
}
/**
 * Request parameters for createCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiCreateCollectionRequest
 */
interface CollectionsApiCreateCollectionRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof CollectionsApiCreateCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof CollectionsApiCreateCollection
     */
    readonly iMXTimestamp: string;
    /**
     * create a collection
     * @type {CreateCollectionRequest}
     * @memberof CollectionsApiCreateCollection
     */
    readonly createCollectionRequest: CreateCollectionRequest;
}
/**
 * Request parameters for getCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiGetCollectionRequest
 */
interface CollectionsApiGetCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiGetCollection
     */
    readonly address: string;
}
/**
 * Request parameters for listCollectionFilters operation in CollectionsApi.
 * @export
 * @interface CollectionsApiListCollectionFiltersRequest
 */
interface CollectionsApiListCollectionFiltersRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly address: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly pageSize?: number;
    /**
     * Next page token
     * @type {string}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly nextPageToken?: string;
}
/**
 * Request parameters for listCollections operation in CollectionsApi.
 * @export
 * @interface CollectionsApiListCollectionsRequest
 */
interface CollectionsApiListCollectionsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof CollectionsApiListCollections
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'name' | 'address' | 'project_id' | 'created_at' | 'updated_at'}
     * @memberof CollectionsApiListCollections
     */
    readonly orderBy?: 'name' | 'address' | 'project_id' | 'created_at' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly direction?: string;
    /**
     * List of collections not to be included, separated by commas
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly blacklist?: string;
    /**
     * List of collections to be included, separated by commas
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly whitelist?: string;
    /**
     * Keyword to search in collection name and description
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly keyword?: string;
}
/**
 * Request parameters for updateCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiUpdateCollectionRequest
 */
interface CollectionsApiUpdateCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly address: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly iMXTimestamp: string;
    /**
     * update a collection
     * @type {UpdateCollectionRequest}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly updateCollectionRequest: UpdateCollectionRequest;
}
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
declare class CollectionsApi extends BaseAPI {
    /**
     * Create collection
     * @summary Create collection
     * @param {CollectionsApiCreateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    createCollection(requestParameters: CollectionsApiCreateCollectionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Collection, any>>;
    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters: CollectionsApiGetCollectionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Collection, any>>;
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {CollectionsApiListCollectionFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionFilters(requestParameters: CollectionsApiListCollectionFiltersRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CollectionFilter, any>>;
    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters?: CollectionsApiListCollectionsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListCollectionsResponse, any>>;
    /**
     * Update collection
     * @summary Update collection
     * @param {CollectionsApiUpdateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    updateCollection(requestParameters: CollectionsApiUpdateCollectionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Collection, any>>;
}
/**
 * Request parameters for getDeposit operation in DepositsApi.
 * @export
 * @interface DepositsApiGetDepositRequest
 */
interface DepositsApiGetDepositRequest {
    /**
     * Deposit ID
     * @type {string}
     * @memberof DepositsApiGetDeposit
     */
    readonly id: string;
}
/**
 * Request parameters for getSignableDeposit operation in DepositsApi.
 * @export
 * @interface DepositsApiGetSignableDepositRequest
 */
interface DepositsApiGetSignableDepositRequest {
    /**
     * Get details of signable deposit
     * @type {GetSignableDepositRequest}
     * @memberof DepositsApiGetSignableDeposit
     */
    readonly getSignableDepositRequest: GetSignableDepositRequest;
}
/**
 * Request parameters for listDeposits operation in DepositsApi.
 * @export
 * @interface DepositsApiListDepositsRequest
 */
interface DepositsApiListDepositsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof DepositsApiListDeposits
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this deposit
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly user?: string;
    /**
     * Status of this deposit
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly assetId?: string;
    /**
     * Token address of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenName?: string;
    /**
     * Min quantity for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly metadata?: string;
}
/**
 * DepositsApi - object-oriented interface
 * @export
 * @class DepositsApi
 * @extends {BaseAPI}
 */
declare class DepositsApi extends BaseAPI {
    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {DepositsApiGetDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    getDeposit(requestParameters: DepositsApiGetDepositRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Deposit, any>>;
    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {DepositsApiGetSignableDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    getSignableDeposit(requestParameters: DepositsApiGetSignableDepositRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableDepositResponse, any>>;
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {DepositsApiListDepositsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    listDeposits(requestParameters?: DepositsApiListDepositsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListDepositsResponse, any>>;
}
/**
 * Request parameters for createExchange operation in ExchangesApi.
 * @export
 * @interface ExchangesApiCreateExchangeRequest
 */
interface ExchangesApiCreateExchangeRequest {
    /**
     * req
     * @type {CreateExchangeAndURLAPIRequest}
     * @memberof ExchangesApiCreateExchange
     */
    readonly createExchangeAPIRequest: CreateExchangeAndURLAPIRequest;
}
/**
 * Request parameters for createExchangeTransfer operation in ExchangesApi.
 * @export
 * @interface ExchangesApiCreateExchangeTransferRequest
 */
interface ExchangesApiCreateExchangeTransferRequest {
    /**
     * Transaction ID
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly id: string;
    /**
     * Create a transfer
     * @type {CreateTransferRequestV1}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly createTransferRequest: CreateTransferRequestV1;
    /**
     * eth address
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly authorization?: string;
}
/**
 * Request parameters for getExchange operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangeRequest
 */
interface ExchangesApiGetExchangeRequest {
    /**
     * Exchange ID
     * @type {string}
     * @memberof ExchangesApiGetExchange
     */
    readonly id: string;
}
/**
 * Request parameters for getExchangeSignableTransfer operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangeSignableTransferRequest
 */
interface ExchangesApiGetExchangeSignableTransferRequest {
    /**
     * Transaction ID
     * @type {string}
     * @memberof ExchangesApiGetExchangeSignableTransfer
     */
    readonly id: string;
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequestV1}
     * @memberof ExchangesApiGetExchangeSignableTransfer
     */
    readonly getSignableTransferRequest: GetSignableTransferRequestV1;
}
/**
 * Request parameters for getExchanges operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangesRequest
 */
interface ExchangesApiGetExchangesRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof ExchangesApiGetExchanges
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'id' | 'status' | 'exchange' | 'amount' | 'transfer_id'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly orderBy?: 'id' | 'status' | 'exchange' | 'amount' | 'transfer_id';
    /**
     * Direction to sort
     * @type {'asc' | 'desc'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly direction?: 'asc' | 'desc';
    /**
     * Transaction ID
     * @type {number}
     * @memberof ExchangesApiGetExchanges
     */
    readonly id?: number;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly walletAddress?: string;
    /**
     * Transaction status
     * @type {'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly status?: 'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut';
    /**
     * Provider name
     * @type {'moonpay' | 'layerswap'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly provider?: 'moonpay' | 'layerswap';
    /**
     * Transfer ID
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly transferId?: string;
}
/**
 * ExchangesApi - object-oriented interface
 * @export
 * @class ExchangesApi
 * @extends {BaseAPI}
 */
declare class ExchangesApi extends BaseAPI {
    /**
     * Receive wallet_address, provider, type and widget information to create a base exchange transaction and return widget URL
     * @summary Create an exchange with URL
     * @param {ExchangesApiCreateExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    createExchange(requestParameters: ExchangesApiCreateExchangeRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ExchangeCreateExchangeAndURLResponse, any>>;
    /**
     * Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @summary Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @param {ExchangesApiCreateExchangeTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    createExchangeTransfer(requestParameters: ExchangesApiCreateExchangeTransferRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateTransferResponseV1, any>>;
    /**
     * Get an exchange by ID
     * @summary Get an exchange by ID
     * @param {ExchangesApiGetExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchange(requestParameters: ExchangesApiGetExchangeRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Exchange, any>>;
    /**
     * Send a request for signable-transfer-details (offramp)
     * @summary Send a request for signable-transfer-details (offramp)
     * @param {ExchangesApiGetExchangeSignableTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchangeSignableTransfer(requestParameters: ExchangesApiGetExchangeSignableTransferRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableTransferResponseV1, any>>;
    /**
     * Returns a list of exchanges based on the request
     * @summary Returns a list of exchanges based on the request
     * @param {ExchangesApiGetExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchanges(requestParameters?: ExchangesApiGetExchangesRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetTransactionsResponse, any>>;
}
/**
 * Request parameters for addMetadataSchemaToCollection operation in MetadataApi.
 * @export
 * @interface MetadataApiAddMetadataSchemaToCollectionRequest
 */
interface MetadataApiAddMetadataSchemaToCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly address: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly iMXTimestamp: string;
    /**
     * add metadata schema to a collection
     * @type {AddMetadataSchemaToCollectionRequest}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest;
}
/**
 * Request parameters for getMetadataSchema operation in MetadataApi.
 * @export
 * @interface MetadataApiGetMetadataSchemaRequest
 */
interface MetadataApiGetMetadataSchemaRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiGetMetadataSchema
     */
    readonly address: string;
}
/**
 * Request parameters for updateMetadataSchemaByName operation in MetadataApi.
 * @export
 * @interface MetadataApiUpdateMetadataSchemaByNameRequest
 */
interface MetadataApiUpdateMetadataSchemaByNameRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly address: string;
    /**
     * Metadata schema name
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly name: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly iMXTimestamp: string;
    /**
     * update metadata schema
     * @type {MetadataSchemaRequest}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly metadataSchemaRequest: MetadataSchemaRequest;
}
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
declare class MetadataApi extends BaseAPI {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {MetadataApiAddMetadataSchemaToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    addMetadataSchemaToCollection(requestParameters: MetadataApiAddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<SuccessResponse, any>>;
    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {MetadataApiGetMetadataSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadataSchema(requestParameters: MetadataApiGetMetadataSchemaRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<MetadataSchemaProperty[], any>>;
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {MetadataApiUpdateMetadataSchemaByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    updateMetadataSchemaByName(requestParameters: MetadataApiUpdateMetadataSchemaByNameRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<SuccessResponse, any>>;
}
/**
 * Request parameters for getAListOfMetadataRefreshes operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetAListOfMetadataRefreshesRequest
 */
interface MetadataRefreshesApiGetAListOfMetadataRefreshesRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthAddress: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly cursor?: string;
    /**
     * Collection address
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly collectionAddress?: string;
}
/**
 * Request parameters for getMetadataRefreshErrors operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetMetadataRefreshErrorsRequest
 */
interface MetadataRefreshesApiGetMetadataRefreshErrorsRequest {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly refreshId: string;
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthAddress: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly cursor?: string;
}
/**
 * Request parameters for getMetadataRefreshResults operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetMetadataRefreshResultsRequest
 */
interface MetadataRefreshesApiGetMetadataRefreshResultsRequest {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly refreshId: string;
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthAddress: string;
}
/**
 * Request parameters for requestAMetadataRefresh operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiRequestAMetadataRefreshRequest
 */
interface MetadataRefreshesApiRequestAMetadataRefreshRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthAddress: string;
    /**
     * Create metadata refresh request
     * @type {CreateMetadataRefreshRequest}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly createMetadataRefreshRequest: CreateMetadataRefreshRequest;
}
/**
 * MetadataRefreshesApi - object-oriented interface
 * @export
 * @class MetadataRefreshesApi
 * @extends {BaseAPI}
 */
declare class MetadataRefreshesApi extends BaseAPI {
    /**
     * Get a list of metadata refreshes
     * @param {MetadataRefreshesApiGetAListOfMetadataRefreshesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getAListOfMetadataRefreshes(requestParameters: MetadataRefreshesApiGetAListOfMetadataRefreshesRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetMetadataRefreshes, any>>;
    /**
     * Get metadata refresh errors
     * @param {MetadataRefreshesApiGetMetadataRefreshErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getMetadataRefreshErrors(requestParameters: MetadataRefreshesApiGetMetadataRefreshErrorsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetMetadataRefreshErrorsResponse, any>>;
    /**
     * Get metadata refresh results
     * @param {MetadataRefreshesApiGetMetadataRefreshResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getMetadataRefreshResults(requestParameters: MetadataRefreshesApiGetMetadataRefreshResultsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetMetadataRefreshResponse, any>>;
    /**
     * Request metadata refresh for provided tokens
     * @param {MetadataRefreshesApiRequestAMetadataRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    requestAMetadataRefresh(requestParameters: MetadataRefreshesApiRequestAMetadataRefreshRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateMetadataRefreshResponse, any>>;
}
/**
 * Request parameters for getMint operation in MintsApi.
 * @export
 * @interface MintsApiGetMintRequest
 */
interface MintsApiGetMintRequest {
    /**
     * Mint ID. This is the transaction_id returned from listMints
     * @type {string}
     * @memberof MintsApiGetMint
     */
    readonly id: string;
}
/**
 * Request parameters for getMintableTokenDetailsByClientTokenId operation in MintsApi.
 * @export
 * @interface MintsApiGetMintableTokenDetailsByClientTokenIdRequest
 */
interface MintsApiGetMintableTokenDetailsByClientTokenIdRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof MintsApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenAddress: string;
    /**
     * ERC721 token ID
     * @type {string}
     * @memberof MintsApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenId: string;
}
/**
 * Request parameters for listMints operation in MintsApi.
 * @export
 * @interface MintsApiListMintsRequest
 */
interface MintsApiListMintsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof MintsApiListMints
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'token_id' | 'created_at' | 'updated_at'}
     * @memberof MintsApiListMints
     */
    readonly orderBy?: 'transaction_id' | 'token_id' | 'created_at' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this mint
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly user?: string;
    /**
     * Status of this mint
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenId?: string;
    /**
     * Token Name of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenName?: string;
    /**
     * Token address of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenAddress?: string;
    /**
     * Min quantity for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly metadata?: string;
}
/**
 * Request parameters for mintTokens operation in MintsApi.
 * @export
 * @interface MintsApiMintTokensRequest
 */
interface MintsApiMintTokensRequest {
    /**
     * details of tokens to mint
     * @type {Array<MintRequest>}
     * @memberof MintsApiMintTokens
     */
    readonly mintTokensRequestV2: Array<MintRequest>;
}
/**
 * MintsApi - object-oriented interface
 * @export
 * @class MintsApi
 * @extends {BaseAPI}
 */
declare class MintsApi extends BaseAPI {
    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {MintsApiGetMintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    getMint(requestParameters: MintsApiGetMintRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Mint[], any>>;
    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {MintsApiGetMintableTokenDetailsByClientTokenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    getMintableTokenDetailsByClientTokenId(requestParameters: MintsApiGetMintableTokenDetailsByClientTokenIdRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<MintableTokenDetails, any>>;
    /**
     * Get information about token mints. If you want to get information about tokens that have already been minted, use the listAssets endpoint.
     * @summary Get a list of mints
     * @param {MintsApiListMintsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    listMints(requestParameters?: MintsApiListMintsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListMintsResponse, any>>;
    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {MintsApiMintTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    mintTokens(requestParameters: MintsApiMintTokensRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<MintTokensResponse, any>>;
}
/**
 * Request parameters for createNftPrimary operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiCreateNftPrimaryRequest
 */
interface NftCheckoutPrimaryApiCreateNftPrimaryRequest {
    /**
     * req
     * @type {NftprimarytransactionCreateAPIRequest}
     * @memberof NftCheckoutPrimaryApiCreateNftPrimary
     */
    readonly createAPIRequest: NftprimarytransactionCreateAPIRequest;
}
/**
 * Request parameters for getCurrenciesNFTCheckoutPrimary operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest
 */
interface NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest {
    /**
     * Provider name
     * @type {'moonpay'}
     * @memberof NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimary
     */
    readonly provider?: 'moonpay';
    /**
     * Flag if limits should be included in the response or not
     * @type {boolean}
     * @memberof NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimary
     */
    readonly includeLimits?: boolean;
}
/**
 * Request parameters for getNftPrimaryTransaction operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest
 */
interface NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest {
    /**
     * Transaction id
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransaction
     */
    readonly transactionId: string;
}
/**
 * Request parameters for getNftPrimaryTransactions operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest
 */
interface NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'status' | 'amount' | 'mint_id'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly orderBy?: 'transaction_id' | 'status' | 'amount' | 'mint_id';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly direction?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly transactionId?: string;
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly contractAddress?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly sellerWalletAddress?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly userWalletAddress?: string;
    /**
     * Transaction status
     * @type {'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly status?: 'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed';
    /**
     * Checkout provider name
     * @type {'moonpay'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly provider?: 'moonpay';
    /**
     * Minting transaction ID - see mintTokens response
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly mintId?: string;
}
/**
 * Request parameters for registerNftPrimarySalesContract operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest
 */
interface NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest {
    /**
     * req
     * @type {ContractCreateAPIRequest}
     * @memberof NftCheckoutPrimaryApiRegisterNftPrimarySalesContract
     */
    readonly createAPIRequest: ContractCreateAPIRequest;
}
/**
 * NftCheckoutPrimaryApi - object-oriented interface
 * @export
 * @class NftCheckoutPrimaryApi
 * @extends {BaseAPI}
 */
declare class NftCheckoutPrimaryApi extends BaseAPI {
    /**
     * Creates a transaction representing minting an NFT with a card payment.
     * @summary Create NFT primary sale transaction
     * @param {NftCheckoutPrimaryApiCreateNftPrimaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    createNftPrimary(requestParameters: NftCheckoutPrimaryApiCreateNftPrimaryRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<NftprimarytransactionCreateResponse, any>>;
    /**
     * Returns a list of supported currencies and their limits
     * @summary Get currencies with limits
     * @param {NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getCurrenciesNFTCheckoutPrimary(requestParameters?: NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CurrencyWithLimits, any>>;
    /**
     * given a transaction id, returns the corresponding transaction representing a mint executed from a card payment
     * @summary Get NFT primary sale transaction by id
     * @param {NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getNftPrimaryTransaction(requestParameters: NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<NftprimarytransactionGetResponse, any>>;
    /**
     * Returns a list of NFT primary sales transactions
     * @summary Get a list of NFT primary sales transactions
     * @param {NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getNftPrimaryTransactions(requestParameters?: NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<NftprimarytransactionListTransactionsResponse, any>>;
    /**
     * Registers a new contract for use in the minting with fiat card flow
     * @summary Executes NFT primary sales contract registration
     * @param {NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    registerNftPrimarySalesContract(requestParameters: NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ContractCreateResponse, any>>;
}
/**
 * Request parameters for cancelOrderV3 operation in OrdersApi.
 * @export
 * @interface OrdersApiCancelOrderV3Request
 */
interface OrdersApiCancelOrderV3Request {
    /**
     * Order ID to cancel
     * @type {string}
     * @memberof OrdersApiCancelOrderV3
     */
    readonly id: string;
    /**
     * cancel an order
     * @type {CancelOrderRequest}
     * @memberof OrdersApiCancelOrderV3
     */
    readonly cancelOrderRequest: CancelOrderRequest;
    /**
     * eth address
     * @type {string}
     * @memberof OrdersApiCancelOrderV3
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof OrdersApiCancelOrderV3
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof OrdersApiCancelOrderV3
     */
    readonly authorization?: string;
}
/**
 * Request parameters for createOrderV3 operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateOrderV3Request
 */
interface OrdersApiCreateOrderV3Request {
    /**
     * create an order
     * @type {CreateOrderRequestV3}
     * @memberof OrdersApiCreateOrderV3
     */
    readonly createOrderRequest: CreateOrderRequestV3;
    /**
     * eth address
     * @type {string}
     * @memberof OrdersApiCreateOrderV3
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof OrdersApiCreateOrderV3
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof OrdersApiCreateOrderV3
     */
    readonly authorization?: string;
}
/**
 * Request parameters for getOrderV3 operation in OrdersApi.
 * @export
 * @interface OrdersApiGetOrderV3Request
 */
interface OrdersApiGetOrderV3Request {
    /**
     * Order ID
     * @type {string}
     * @memberof OrdersApiGetOrderV3
     */
    readonly id: string;
    /**
     * Set flag to true to include fee body for the order
     * @type {boolean}
     * @memberof OrdersApiGetOrderV3
     */
    readonly includeFees?: boolean;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof OrdersApiGetOrderV3
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof OrdersApiGetOrderV3
     */
    readonly auxiliaryFeeRecipients?: string;
}
/**
 * Request parameters for getSignableCancelOrderV3 operation in OrdersApi.
 * @export
 * @interface OrdersApiGetSignableCancelOrderV3Request
 */
interface OrdersApiGetSignableCancelOrderV3Request {
    /**
     * get a signable cancel order
     * @type {GetSignableCancelOrderRequest}
     * @memberof OrdersApiGetSignableCancelOrderV3
     */
    readonly getSignableCancelOrderRequest: GetSignableCancelOrderRequest;
}
/**
 * Request parameters for getSignableOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiGetSignableOrderRequest
 */
interface OrdersApiGetSignableOrderRequest {
    /**
     * get a signable order v3
     * @type {GetSignableOrderRequestV3}
     * @memberof OrdersApiGetSignableOrder
     */
    readonly getSignableOrderRequestV3: GetSignableOrderRequestV3;
}
/**
 * Request parameters for listOrdersV3 operation in OrdersApi.
 * @export
 * @interface OrdersApiListOrdersV3Request
 */
interface OrdersApiListOrdersV3Request {
    /**
     * Page size of the result
     * @type {number}
     * @memberof OrdersApiListOrdersV3
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at'}
     * @memberof OrdersApiListOrdersV3
     */
    readonly orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this order
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly user?: string;
    /**
     * Status of this order
     * @type {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'}
     * @memberof OrdersApiListOrdersV3
     */
    readonly status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive';
    /**
     * Filter orders to include those with created_at timestamps after this time, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly minTimestamp?: string;
    /**
     * Filter orders to include those with created_at timestamps before this time, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly maxTimestamp?: string;
    /**
     * Filter orders to include those with updated_at timestamps after this time, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly updatedMinTimestamp?: string;
    /**
     * Filter orders to include those with updated_at timestamps before this time, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly updatedMaxTimestamp?: string;
    /**
     * Token type of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyTokenType?: string;
    /**
     * ERC721 Token ID of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyTokenId?: string;
    /**
     * Internal IMX ID of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyAssetId?: string;
    /**
     * Token address of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyTokenAddress?: string;
    /**
     * Token name of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyTokenName?: string;
    /**
     * Min quantity for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyMinQuantity?: string;
    /**
     * Max quantity for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyMaxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly buyMetadata?: string;
    /**
     * Token type of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellTokenType?: string;
    /**
     * ERC721 Token ID of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellTokenId?: string;
    /**
     * Internal IMX ID of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellAssetId?: string;
    /**
     * Token address of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellTokenAddress?: string;
    /**
     * Token name of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellTokenName?: string;
    /**
     * Min quantity for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellMinQuantity?: string;
    /**
     * Max quantity for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellMaxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly sellMetadata?: string;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof OrdersApiListOrdersV3
     */
    readonly auxiliaryFeeRecipients?: string;
    /**
     * Set flag to true to include fee object for orders
     * @type {boolean}
     * @memberof OrdersApiListOrdersV3
     */
    readonly includeFees?: boolean;
}
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
declare class OrdersApi extends BaseAPI {
    /**
     * Cancel an order (V3)
     * @summary Cancel an order (V3)
     * @param {OrdersApiCancelOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    cancelOrderV3(requestParameters: OrdersApiCancelOrderV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<CancelOrderResponse, any>>;
    /**
     * Create an order using the v3 orderbook.
     * @summary Create an order (V3)
     * @param {OrdersApiCreateOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createOrderV3(requestParameters: OrdersApiCreateOrderV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateOrderResponse, any>>;
    /**
     * Get an order (V3)
     * @summary Get an order (V3)
     * @param {OrdersApiGetOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrderV3(requestParameters: OrdersApiGetOrderV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<OrderV3, any>>;
    /**
     * Generate a signable cancel order message (V3)
     * @summary Generate a signable cancel order message (V3)
     * @param {OrdersApiGetSignableCancelOrderV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getSignableCancelOrderV3(requestParameters: OrdersApiGetSignableCancelOrderV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableCancelOrderResponse, any>>;
    /**
     * Generate a signable order request (V3)
     * @summary Generate a signable order request (V3)
     * @param {OrdersApiGetSignableOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getSignableOrder(requestParameters: OrdersApiGetSignableOrderRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableOrderResponse, any>>;
    /**
     * Get a list of orders (V3)
     * @summary Get a list of orders (V3)
     * @param {OrdersApiListOrdersV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listOrdersV3(requestParameters?: OrdersApiListOrdersV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<ListOrdersResponseV3, any>>;
}
/**
 * Request parameters for createProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiCreateProjectRequest
 */
interface ProjectsApiCreateProjectRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiCreateProject
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiCreateProject
     */
    readonly iMXTimestamp: string;
    /**
     * create a project
     * @type {CreateProjectRequest}
     * @memberof ProjectsApiCreateProject
     */
    readonly createProjectRequest: CreateProjectRequest;
}
/**
 * Request parameters for getProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectRequest
 */
interface ProjectsApiGetProjectRequest {
    /**
     * Project ID
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly id: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly iMXTimestamp: string;
}
/**
 * Request parameters for getProjects operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectsRequest
 */
interface ProjectsApiGetProjectsRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly iMXTimestamp: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof ProjectsApiGetProjects
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly direction?: string;
}
/**
 * Request parameters for getSdkVersion operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetSdkVersionRequest
 */
interface ProjectsApiGetSdkVersionRequest {
    /**
     * Runtime Details
     * @type {string}
     * @memberof ProjectsApiGetSdkVersion
     */
    readonly details: string;
    /**
     * SDK Version
     * @type {string}
     * @memberof ProjectsApiGetSdkVersion
     */
    readonly version?: string;
    /**
     * Runtime ID
     * @type {string}
     * @memberof ProjectsApiGetSdkVersion
     */
    readonly id?: string;
}
/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
declare class ProjectsApi extends BaseAPI {
    /**
     * Create a project
     * @summary Create a project
     * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    createProject(requestParameters: ProjectsApiCreateProjectRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateProjectResponse, any>>;
    /**
     * Get a project
     * @summary Get a project
     * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getProject(requestParameters: ProjectsApiGetProjectRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Project, any>>;
    /**
     * Get projects
     * @summary Get projects
     * @param {ProjectsApiGetProjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getProjects(requestParameters: ProjectsApiGetProjectsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetProjectsResponse, any>>;
    /**
     * Checks the SDK Version of caller against the current SDK Version and returns a message.
     * @summary Checks the SDK Version of caller against the current SDK Version
     * @param {ProjectsApiGetSdkVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getSdkVersion(requestParameters: ProjectsApiGetSdkVersionRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ApiSDKVersionCheckResponse, any>>;
}
/**
 * Request parameters for getToken operation in TokensApi.
 * @export
 * @interface TokensApiGetTokenRequest
 */
interface TokensApiGetTokenRequest {
    /**
     * Token Contract Address
     * @type {string}
     * @memberof TokensApiGetToken
     */
    readonly address: string;
}
/**
 * Request parameters for listTokens operation in TokensApi.
 * @export
 * @interface TokensApiListTokensRequest
 */
interface TokensApiListTokensRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof TokensApiListTokens
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'contract_address' | 'name' | 'symbol'}
     * @memberof TokensApiListTokens
     */
    readonly orderBy?: 'contract_address' | 'name' | 'symbol';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly direction?: string;
    /**
     * Contract address of the token
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly address?: string;
    /**
     * Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly symbols?: string;
}
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
declare class TokensApi extends BaseAPI {
    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {TokensApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getToken(requestParameters: TokensApiGetTokenRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<TokenDetails, any>>;
    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {TokensApiListTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listTokens(requestParameters?: TokensApiListTokensRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListTokensResponse, any>>;
}
/**
 * Request parameters for createTradeV3 operation in TradesApi.
 * @export
 * @interface TradesApiCreateTradeV3Request
 */
interface TradesApiCreateTradeV3Request {
    /**
     * create a trade
     * @type {TradesCreateTradeRequest}
     * @memberof TradesApiCreateTradeV3
     */
    readonly createTradeRequest: TradesCreateTradeRequest;
    /**
     * eth address
     * @type {string}
     * @memberof TradesApiCreateTradeV3
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TradesApiCreateTradeV3
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof TradesApiCreateTradeV3
     */
    readonly authorization?: string;
}
/**
 * Request parameters for getSignableTrade operation in TradesApi.
 * @export
 * @interface TradesApiGetSignableTradeRequest
 */
interface TradesApiGetSignableTradeRequest {
    /**
     * get a signable trade
     * @type {GetSignableTradeRequest}
     * @memberof TradesApiGetSignableTrade
     */
    readonly getSignableTradeRequest: GetSignableTradeRequest;
}
/**
 * Request parameters for getTradeV3 operation in TradesApi.
 * @export
 * @interface TradesApiGetTradeV3Request
 */
interface TradesApiGetTradeV3Request {
    /**
     * Trade ID
     * @type {string}
     * @memberof TradesApiGetTradeV3
     */
    readonly id: string;
}
/**
 * Request parameters for listTradesV3 operation in TradesApi.
 * @export
 * @interface TradesApiListTradesV3Request
 */
interface TradesApiListTradesV3Request {
    /**
     * Party A\&#39;s (buy order) token type of currency used to buy
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly partyATokenType?: string;
    /**
     * Party A\&#39;s (buy order) token address of currency used to buy
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly partyATokenAddress?: string;
    /**
     * Party B\&#39;s (sell order) token type of NFT sold - always ERC721
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly partyBTokenType?: string;
    /**
     * Party B\&#39;s (sell order) collection address of NFT sold
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly partyBTokenAddress?: string;
    /**
     * Party B\&#39;s (sell order) token id of NFT sold
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly partyBTokenId?: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof TradesApiListTradesV3
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'created_at' | 'transaction_id' | 'party_a_sold_quantity' | 'party_b_sold_quantity' | 'timestamp' | 'updated_timestamp'}
     * @memberof TradesApiListTradesV3
     */
    readonly orderBy?: 'created_at' | 'transaction_id' | 'party_a_sold_quantity' | 'party_b_sold_quantity' | 'timestamp' | 'updated_timestamp';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly direction?: string;
    /**
     * Minimum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-06-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-06-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TradesApiListTradesV3
     */
    readonly maxTimestamp?: string;
}
/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
declare class TradesApi extends BaseAPI {
    /**
     * Create a Trade.
     * @summary Create a Trade (V3)
     * @param {TradesApiCreateTradeV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    createTradeV3(requestParameters: TradesApiCreateTradeV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateTradeResponse, any>>;
    /**
     * Generate a signable trade message (V3)
     * @summary Generate a signable trade message (V3)
     * @param {TradesApiGetSignableTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getSignableTrade(requestParameters: TradesApiGetSignableTradeRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableTradeResponse, any>>;
    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {TradesApiGetTradeV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getTradeV3(requestParameters: TradesApiGetTradeV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<Trade, any>>;
    /**
     * Get a list of trades (V3)
     * @summary Get a list of trades (V3)
     * @param {TradesApiListTradesV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    listTradesV3(requestParameters?: TradesApiListTradesV3Request, options?: AxiosRequestConfig): Promise<AxiosResponse<ListTradesResponse, any>>;
}
/**
 * Request parameters for createTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiCreateTransferRequest
 */
interface TransfersApiCreateTransferRequest {
    /**
     * Create transfer
     * @type {CreateTransferRequest}
     * @memberof TransfersApiCreateTransfer
     */
    readonly createTransferRequestV2: CreateTransferRequest;
    /**
     * eth address
     * @type {string}
     * @memberof TransfersApiCreateTransfer
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TransfersApiCreateTransfer
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof TransfersApiCreateTransfer
     */
    readonly authorization?: string;
}
/**
 * Request parameters for createTransferV1 operation in TransfersApi.
 * @export
 * @interface TransfersApiCreateTransferV1Request
 */
interface TransfersApiCreateTransferV1Request {
    /**
     * Create transfer
     * @type {CreateTransferRequestV1}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly createTransferRequest: CreateTransferRequestV1;
    /**
     * eth address
     * @type {string}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly xImxEthAddress?: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly xImxEthSignature?: string;
    /**
     * Authorization header
     * @type {string}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly authorization?: string;
}
/**
 * Request parameters for getSignableTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiGetSignableTransferRequest
 */
interface TransfersApiGetSignableTransferRequest {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequestV2}
     * @memberof TransfersApiGetSignableTransfer
     */
    readonly getSignableTransferRequestV2: GetSignableTransferRequestV2;
}
/**
 * Request parameters for getSignableTransferV1 operation in TransfersApi.
 * @export
 * @interface TransfersApiGetSignableTransferV1Request
 */
interface TransfersApiGetSignableTransferV1Request {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequest}
     * @memberof TransfersApiGetSignableTransferV1
     */
    readonly getSignableTransferRequest: GetSignableTransferRequest;
}
/**
 * Request parameters for getTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiGetTransferRequest
 */
interface TransfersApiGetTransferRequest {
    /**
     * Transfer ID
     * @type {string}
     * @memberof TransfersApiGetTransfer
     */
    readonly id: string;
}
/**
 * Request parameters for listTransfers operation in TransfersApi.
 * @export
 * @interface TransfersApiListTransfersRequest
 */
interface TransfersApiListTransfersRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof TransfersApiListTransfers
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key'}
     * @memberof TransfersApiListTransfers
     */
    readonly orderBy?: 'transaction_id' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this transfer
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly user?: string;
    /**
     * Ethereum address of the user who received this transfer
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly receiver?: string;
    /**
     * Status of this transfer
     * @type {'success' | 'failure'}
     * @memberof TransfersApiListTransfers
     */
    readonly status?: 'success' | 'failure';
    /**
     * Minimum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly assetId?: string;
    /**
     * Token address of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenName?: string;
    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly metadata?: string;
}
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
declare class TransfersApi extends BaseAPI {
    /**
     * Create a new transfer request. Use https://docs.x.immutable.com/reference#/operations/getSignableTransfer to get request body params.
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {TransfersApiCreateTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(requestParameters: TransfersApiCreateTransferRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateTransferResponseV2, any>>;
    /**
     * Create a new transfer request. Use https://docs.x.immutable.com/reference#/operations/getSignableTransferV1 to get request body params.
     * @summary Creates a transfer of tokens between two parties
     * @param {TransfersApiCreateTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransferV1(requestParameters: TransfersApiCreateTransferV1Request, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateTransferResponseV1, any>>;
    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {TransfersApiGetSignableTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSignableTransfer(requestParameters: TransfersApiGetSignableTransferRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableTransferResponseV2, any>>;
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {TransfersApiGetSignableTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSignableTransferV1(requestParameters: TransfersApiGetSignableTransferV1Request, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableTransferResponseV1, any>>;
    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {TransfersApiGetTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getTransfer(requestParameters: TransfersApiGetTransferRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Transfer, any>>;
    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {TransfersApiListTransfersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listTransfers(requestParameters?: TransfersApiListTransfersRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListTransfersResponse, any>>;
}
/**
 * Request parameters for getSignableRegistration operation in UsersApi.
 * @export
 * @interface UsersApiGetSignableRegistrationRequest
 */
interface UsersApiGetSignableRegistrationRequest {
    /**
     * Register User
     * @type {GetSignableRegistrationRequest}
     * @memberof UsersApiGetSignableRegistration
     */
    readonly getSignableRegistrationRequest: GetSignableRegistrationRequest;
}
/**
 * Request parameters for getSignableRegistrationOffchain operation in UsersApi.
 * @export
 * @interface UsersApiGetSignableRegistrationOffchainRequest
 */
interface UsersApiGetSignableRegistrationOffchainRequest {
    /**
     * Register User Offchain
     * @type {GetSignableRegistrationRequest}
     * @memberof UsersApiGetSignableRegistrationOffchain
     */
    readonly getSignableRegistrationRequest: GetSignableRegistrationRequest;
}
/**
 * Request parameters for getUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersRequest
 */
interface UsersApiGetUsersRequest {
    /**
     * User
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly user: string;
}
/**
 * Request parameters for registerPassportUser operation in UsersApi.
 * @export
 * @interface UsersApiRegisterPassportUserRequest
 */
interface UsersApiRegisterPassportUserRequest {
    /**
     * Authorization header
     * @type {string}
     * @memberof UsersApiRegisterPassportUser
     */
    readonly authorization: string;
    /**
     * Register Passport User
     * @type {ApiRegisterPassportUserRequest}
     * @memberof UsersApiRegisterPassportUser
     */
    readonly registerPassportUserRequest: ApiRegisterPassportUserRequest;
}
/**
 * Request parameters for registerUser operation in UsersApi.
 * @export
 * @interface UsersApiRegisterUserRequest
 */
interface UsersApiRegisterUserRequest {
    /**
     * Register User
     * @type {RegisterUserRequest}
     * @memberof UsersApiRegisterUser
     */
    readonly registerUserRequest: RegisterUserRequest;
}
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
declare class UsersApi extends BaseAPI {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {UsersApiGetSignableRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSignableRegistration(requestParameters: UsersApiGetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableRegistrationResponse, any>>;
    /**
     * Get encoded details to allow clients to register the user offchain
     * @summary Get encoded details to allow clients to register the user offchain
     * @param {UsersApiGetSignableRegistrationOffchainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSignableRegistrationOffchain(requestParameters: UsersApiGetSignableRegistrationOffchainRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableRegistrationOffchainResponse, any>>;
    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {UsersApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsers(requestParameters: UsersApiGetUsersRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetUsersApiResponse, any>>;
    /**
     * Registers a passport user
     * @summary Registers a passport user
     * @param {UsersApiRegisterPassportUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    registerPassportUser(requestParameters: UsersApiRegisterPassportUserRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<RegisterPassportUserResult, any>>;
    /**
     * Registers a user
     * @summary Registers a user
     * @param {UsersApiRegisterUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    registerUser(requestParameters: UsersApiRegisterUserRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<RegisterUserResponse, any>>;
}
/**
 * Request parameters for createWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiCreateWithdrawalRequest
 */
interface WithdrawalsApiCreateWithdrawalRequest {
    /**
     * eth address
     * @type {string}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly xImxEthSignature: string;
    /**
     * create a withdrawal
     * @type {CreateWithdrawalRequest}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly createWithdrawalRequest: CreateWithdrawalRequest;
}
/**
 * Request parameters for getSignableWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiGetSignableWithdrawalRequest
 */
interface WithdrawalsApiGetSignableWithdrawalRequest {
    /**
     * get details of signable withdrawal
     * @type {GetSignableWithdrawalRequest}
     * @memberof WithdrawalsApiGetSignableWithdrawal
     */
    readonly getSignableWithdrawalRequest: GetSignableWithdrawalRequest;
}
/**
 * Request parameters for getWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiGetWithdrawalRequest
 */
interface WithdrawalsApiGetWithdrawalRequest {
    /**
     * Withdrawal ID
     * @type {string}
     * @memberof WithdrawalsApiGetWithdrawal
     */
    readonly id: string;
}
/**
 * Request parameters for listWithdrawals operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiListWithdrawalsRequest
 */
interface WithdrawalsApiListWithdrawalsRequest {
    /**
     * Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @type {boolean}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly withdrawnToWallet?: boolean;
    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly rollupStatus?: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly user?: string;
    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly assetId?: string;
    /**
     * Token address of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenName?: string;
    /**
     * Min quantity for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly metadata?: string;
}
/**
 * WithdrawalsApi - object-oriented interface
 * @export
 * @class WithdrawalsApi
 * @extends {BaseAPI}
 */
declare class WithdrawalsApi extends BaseAPI {
    /**
     * Creates a withdrawal. Use https://docs.x.immutable.com/reference#/operations/getSignableWithdrawal to get request body params.
     * @summary Creates a withdrawal of a token
     * @param {WithdrawalsApiCreateWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    createWithdrawal(requestParameters: WithdrawalsApiCreateWithdrawalRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateWithdrawalResponse, any>>;
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {WithdrawalsApiGetSignableWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    getSignableWithdrawal(requestParameters: WithdrawalsApiGetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSignableWithdrawalResponse, any>>;
    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {WithdrawalsApiGetWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    getWithdrawal(requestParameters: WithdrawalsApiGetWithdrawalRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Withdrawal, any>>;
    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {WithdrawalsApiListWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    listWithdrawals(requestParameters?: WithdrawalsApiListWithdrawalsRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<ListWithdrawalsResponse, any>>;
}

/**
 * Parameter required to create an Order
 */
interface UnsignedOrderRequest {
    /**
     * The amount of tokens that will be bought for this order
     */
    buy: TokenAmount;
    /**
     * The amount of tokens that will be sold for this order
     */
    sell: TokenAmount;
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     */
    expiration_timestamp?: number;
    /**
     * Inclusion of either maker or taker fees
     */
    fees?: Array<FeeEntry>;
}
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedTransferRequest = TokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
};
/**
 * Parameter required to Mint tokens
 */
declare type UnsignedMintRequest = Omit<MintRequest, 'auth_signature'>;
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedExchangeTransferRequest = ExchangeTokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * Exchange transaction ID
     */
    transactionID: string;
};

/**
 * Parameter required to create a batchNftTransfer
 */
interface NftTransferDetails {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * The token ID
     */
    tokenId: string;
    /**
     * The token contract address
     */
    tokenAddress: string;
}

/**
 * The configuration for the Ethereum network
 */
interface EthConfiguration {
    coreContractAddress: string;
    registrationContractAddress: string;
    chainID: number;
}
/**
 * The configuration for the ImmutableX client
 */
interface ImmutableXConfiguration {
    /**
     * The configuration for the API client
     */
    apiConfiguration: Configuration;
    /**
     * The configuration for the Ethereum network
     */
    ethConfiguration: EthConfiguration;
}

interface IMXProvider {
    /**
     * Get the Signer address
     *
     * @return {Promise<string>} Returns a promise that resolves with the signer's address
     */
    getAddress(): Promise<string>;
    /**
     * Register a User to Immutable X if they are not already registered
     *
     * @return {Promise<RegisterUserResponse>} Returns a promise that resolves with the user registration response
     */
    registerOffchain(): Promise<RegisterUserResponse>;
    /**
     *  Checks if a User is registered off-chain
     *
     *  @return {Promise<boolean>} Returns a promise that resolves with true if the User is registered with IMX, false otherwise
     */
    isRegisteredOffchain(): Promise<boolean>;
    /**
     * Checks if a User is registered on-chain
     *
     * @return {Promise<boolean>} Returns a promise that resolves with true if the User is registered, false otherwise
     */
    isRegisteredOnchain(): Promise<boolean>;
    /**
     * Create an Order
     *
     * @param {UnsignedOrderRequest} request The unsigned order request to create an order
     * @return {Promise<CreateOrderResponse>} Returns a promise that resolves with the created Order
     */
    createOrder(request: UnsignedOrderRequest): Promise<CreateOrderResponse>;
    /**
     * Cancel an Order
     *
     * @param {GetSignableCancelOrderRequest} request The signable cancel order request
     * @return {Promise<CancelOrderResponse>} Returns a promise that resolves with the cancelled Order
     */
    cancelOrder(request: GetSignableCancelOrderRequest): Promise<CancelOrderResponse>;
    /**
     * Create a Trade
     *
     * @param {GetSignableTradeRequest} request The signable trade request
     * @return {Promise<CreateTradeResponse>} Returns a promise that resolves with the created Trade
     */
    createTrade(request: GetSignableTradeRequest): Promise<CreateTradeResponse>;
    /**
     * Create a new Transfer request
     *
     * @param {UnsignedTransferRequest} request The unsigned transfer request
     * @return {Promise<CreateTransferResponseV1>} Returns a promise that resolves with the created Transfer
     */
    transfer(request: UnsignedTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Create a batch of NFT transfer requests
     *
     * @param {Array<NftTransferDetails>} request An array of NFT transfer details
     * @return {Promise<CreateTransferResponse>} Resolves a promise that resolves with the list of Transfer IDs
     */
    batchNftTransfer(request: Array<NftTransferDetails>): Promise<CreateTransferResponse>;
    /**
     * Create a new Exchange transaction
     *
     * @param {UnsignedExchangeTransferRequest} request The unsigned exchange transfer request
     * @return {Promise<CreateTransferResponseV1>} Returns a promise that resolves with the created Exchange Transaction
     */
    exchangeTransfer(request: UnsignedExchangeTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Deposit either ETH, ERC20 or ERC721 tokens
     *
     * @param {TokenAmount} request The token type amount in its corresponding unit
     * @return {Promise<TransactionResponse>} Returns a promise that resolves with the transaction
     */
    deposit(deposit: TokenAmount): Promise<TransactionResponse>;
    /**
     * Create a Withdrawal
     *
     * @param {TokenAmount} request The token type amount in its corresponding unit
     * @return {Promise<CreateWithdrawalResponse>} Returns a promise that resolves with the created Withdrawal
     */
    prepareWithdrawal(request: TokenAmount): Promise<CreateWithdrawalResponse>;
    /**
     * Completes a Withdrawal
     *
     * @param {string} starkPublicKey The stark public key
     * @param {AnyToken} token The token to withdraw
     * @return {Promise<TransactionResponse>} Returns a promise that resolves with the transaction
     */
    completeWithdrawal(starkPublicKey: string, token: AnyToken): Promise<TransactionResponse>;
}

declare enum Environment {
    PRODUCTION = "production",
    SANDBOX = "sandbox"
}
declare class ImmutableConfiguration {
    readonly environment: Environment;
    readonly rateLimitingKey?: string;
    readonly apiKey?: string;
    readonly publishableKey?: string;
    constructor(options: {
        environment: Environment;
    });
}
type ImmutableConfigurationWithRequireableFields<T> = ImmutableConfiguration & (T extends {
    apiKey: 'required';
} ? Required<{
    apiKey: string;
}> : {}) & (T extends {
    publishableKey: 'required';
} ? Required<{
    publishableKey: string;
}> : {});
type ImmutableConfigurationWithOmitableFields<T> = (T extends {
    apiKey: 'omit';
} ? Omit<ImmutableConfigurationWithRequireableFields<T>, 'apiKey'> : ImmutableConfigurationWithRequireableFields<T>);
interface ModuleConfiguration<T> {
    baseConfig: ImmutableConfigurationWithOmitableFields<T>;
    overrides?: T;
}

interface ImxOverrides {
    immutableXConfig: ImmutableXConfiguration;
}
interface ImxModuleConfiguration extends ModuleConfiguration<ImxOverrides> {
}

declare class ImmutableXClient {
    private immutableX;
    depositsApi: DepositsApi;
    mintsApi: MintsApi;
    ordersApi: OrdersApi;
    tokensApi: TokensApi;
    tradesApi: TradesApi;
    transfersApi: TransfersApi;
    exchangeApi: ExchangesApi;
    nftCheckoutPrimaryApi: NftCheckoutPrimaryApi;
    usersApi: UsersApi;
    withdrawalsApi: WithdrawalsApi;
    balanceApi: BalancesApi;
    assetApi: AssetsApi;
    collectionApi: CollectionsApi;
    metadataApi: MetadataApi;
    metadataRefreshesApi: MetadataRefreshesApi;
    projectsApi: ProjectsApi;
    constructor(config: ImxModuleConfiguration);
    /**
     * Get details of a Deposit with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Deposit
     * @throws {@link index.IMXError}
     */
    getDeposit(request: DepositsApiGetDepositRequest): Promise<Deposit>;
    /**
     * Get a list of Deposits
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Deposits
     * @throws {@link index.IMXError}
     */
    listDeposits(request?: DepositsApiListDepositsRequest): Promise<ListDepositsResponse>;
    /**
     * Get Stark keys for a registered User
     * @param ethAddress - the eth address of the User
     * @returns a promise that resolves with the requested User
     * @throws {@link index.IMXError}
     */
    getUser(ethAddress: string): Promise<GetUsersApiResponse>;
    /**
     * Get details of an Asset
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Asset
     * @throws {@link index.IMXError}
     */
    getAsset(request: AssetsApiGetAssetRequest): Promise<Asset>;
    /**
     * Get a list of Assets
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Assets
     * @throws {@link index.IMXError}
     */
    listAssets(request?: AssetsApiListAssetsRequest): Promise<ListAssetsResponse>;
    /**
     * Create a Collection
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Collection
     * @throws {@link index.IMXError}
     */
    createCollection(ethSigner: Signer, request: CreateCollectionRequest): Promise<Collection>;
    /**
     * Get details of a Collection at the given address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Collection
     * @throws {@link index.IMXError}
     */
    getCollection(request: CollectionsApiGetCollectionRequest): Promise<Collection>;
    /**
     * Get a list of Collection filters
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collection Filters
     * @throws {@link index.IMXError}
     */
    listCollectionFilters(request: CollectionsApiListCollectionFiltersRequest): Promise<CollectionFilter>;
    /**
     * Get a list of Collections
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collections
     * @throws {@link index.IMXError}
     */
    listCollections(request?: CollectionsApiListCollectionsRequest): Promise<ListCollectionsResponse>;
    /**
     * Update a Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated Collection
     * @throws {@link index.IMXError}
     */
    updateCollection(ethSigner: Signer, collectionAddress: string, request: UpdateCollectionRequest): Promise<Collection>;
    /**
     * Add metadata schema to Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    addMetadataSchemaToCollection(ethSigner: Signer, collectionAddress: string, request: AddMetadataSchemaToCollectionRequest): Promise<SuccessResponse>;
    /**
     * Get Metadata schema
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Metadata schema
     * @throws {@link index.IMXError}
     */
    getMetadataSchema(request: MetadataApiGetMetadataSchemaRequest): Promise<MetadataSchemaProperty[]>;
    /**
     * Update metadata schema by name
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param name - the Metadata schema name
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    updateMetadataSchemaByName(ethSigner: Signer, collectionAddress: string, name: string, request: MetadataSchemaRequest): Promise<SuccessResponse>;
    /**
     * Get a list of metadata refreshes
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refreshes
     * @throws {@link index.IMXError}
     */
    listMetadataRefreshes(ethSigner: Signer, collectionAddress?: string, pageSize?: number, cursor?: string): Promise<GetMetadataRefreshes>;
    /**
     * Get a list of metadata refresh errors
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refresh errors
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshErrors(ethSigner: Signer, refreshId: string, pageSize?: number, cursor?: string): Promise<GetMetadataRefreshErrorsResponse>;
    /**
     * Get a list of metadata refresh results
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @returns a promise that resolves with the requested metadata refresh results
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshResults(ethSigner: Signer, refreshId: string): Promise<GetMetadataRefreshResponse>;
    /**
     * Request a metadata refresh
     * @param ethSigner - the L1 signer
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested metadata refresh
     * @throws {@link index.IMXError}
     */
    createMetadataRefresh(ethSigner: Signer, request: CreateMetadataRefreshRequest): Promise<CreateMetadataRefreshResponse>;
    /**
     * Create a Project
     * @param ethSigner - the L1 signer
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the created Project
     * @throws {@link index.IMXError}
     */
    createProject(ethSigner: Signer, request: CreateProjectRequest): Promise<CreateProjectResponse>;
    /**
     * Get a Project
     * @param ethSigner - the L1 signer
     * @param id - the Project ID
     * @returns a promise that resolves with the requested Project
     * @throws {@link index.IMXError}
     */
    getProject(ethSigner: Signer, id: string): Promise<Project>;
    /**
     * Get Projects owned by the given User
     * @param ethSigner - the L1 signer
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @param orderBy - the property to sort by
     * @param direction - direction to sort (asc/desc)
     * @returns a promise that resolves with the requested Projects
     * @throws {@link index.IMXError}
     */
    getProjects(ethSigner: Signer, pageSize?: number, cursor?: string, orderBy?: string, direction?: string): Promise<GetProjectsResponse>;
    /**
     * Get the token Balances of the User
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Balance
     * @throws {@link index.IMXError}
     */
    getBalance(request: BalancesApiGetBalanceRequest): Promise<Balance>;
    /**
     * Get a list of Balances for given User
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Balances
     * @throws {@link index.IMXError}
     */
    listBalances(request: BalancesApiListBalancesRequest): Promise<ListBalancesResponse>;
    /**
     * Get details of a Mint with the given ID
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Mint
     * @throws {@link index.IMXError}
     */
    getMint(request: MintsApiGetMintRequest): Promise<Mint[]>;
    /**
     * Get a list of Mints
     * @param request optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Mints
     * @throws {@link index.IMXError}
     */
    listMints(request?: MintsApiListMintsRequest): Promise<ListMintsResponse>;
    /**
     * Mint tokens in a batch with fees
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the minted tokens
     * @throws {@link index.IMXError}
     */
    mint(ethSigner: Signer, request: UnsignedMintRequest): Promise<MintTokensResponse>;
    /**
     * Get a list of Withdrawals
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Withdrawals
     * @throws {@link index.IMXError}
     */
    listWithdrawals(request?: WithdrawalsApiListWithdrawalsRequest): Promise<ListWithdrawalsResponse>;
    /**
     * Get details of Withdrawal with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Withdrawal
     * @throws {@link index.IMXError}
     */
    getWithdrawal(request: WithdrawalsApiGetWithdrawalRequest): Promise<Withdrawal>;
    /**
     * Get details of an Order with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Order
     * @throws {@link index.IMXError}
     */
    getOrder(request: OrdersApiGetOrderV3Request): Promise<OrderV3>;
    /**
     * Get a list of Orders
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Orders
     * @throws {@link index.IMXError}
     */
    listOrders(request?: OrdersApiListOrdersV3Request): Promise<ListOrdersResponseV3>;
    /**
     * Get details of a Trade with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Trade
     * @throws {@link index.IMXError}
     */
    getTrade(request: TradesApiGetTradeV3Request): Promise<Trade>;
    /**
     * Get a list of Trades
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Trades
     * @throws {@link index.IMXError}
     */
    listTrades(request?: TradesApiListTradesV3Request): Promise<ListTradesResponse>;
    /**
     * Get details of a Token
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Token
     * @throws {@link index.IMXError}
     */
    getToken(request: TokensApiGetTokenRequest): Promise<TokenDetails>;
    /**
     * Get a list of Tokens
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Tokens
     * @throws {@link index.IMXError}
     */
    listTokens(request?: TokensApiListTokensRequest): Promise<ListTokensResponse>;
    /**
     * Get details of a Transfer with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Transfer
     * @throws {@link index.IMXError}
     */
    getTransfer(request: TransfersApiGetTransferRequest): Promise<Transfer>;
    /**
     * Get a list of Transfers
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Transfers
     * @throws {@link index.IMXError}
     */
    listTransfers(request?: TransfersApiListTransfersRequest): Promise<ListTransfersResponse>;
    /**
     * Create a new Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transaction
     * @throws {@link index.IMXError}
     */
    createExchange(request: ExchangesApiCreateExchangeRequest): Promise<ExchangeCreateExchangeAndURLResponse>;
    /**
     * Get an Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the Exchange Transaction
     * @throws {@link index.IMXError}
     */
    getExchange(request: ExchangesApiGetExchangeRequest): Promise<Exchange>;
    /**
     * Get Exchange transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with Exchange Transactions
     * @throws {@link index.IMXError}
     */
    getExchanges(request: ExchangesApiGetExchangesRequest): Promise<GetTransactionsResponse>;
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of Eth/Stark signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transfer
     * @throws {@link index.IMXError}
     */
    exchangeTransfer(walletConnection: WalletConnection, request: UnsignedExchangeTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Create a new nft primary transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created nft primary Transaction
     * @throws {@link index.IMXError}
     */
    createNftPrimary(request: NftCheckoutPrimaryApiCreateNftPrimaryRequest): Promise<NftprimarytransactionCreateResponse>;
    /**
     * Get nft primary supported currencies and their limits
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary Currencies
     * @throws {@link index.IMXError}
     */
    getCurrenciesNFTCheckoutPrimary(request: NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest): Promise<CurrencyWithLimits>;
    /**
     * Get nft primary transaction by transaction id
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransaction(request: NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest): Promise<NftprimarytransactionGetResponse>;
    /**
     * Get list of nft primary transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransactions(request: NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest): Promise<NftprimarytransactionListTransactionsResponse>;
}

type UserProfile = {
    email?: string;
    nickname?: string;
    sub: string;
};
declare enum Networks {
    PRODUCTION = "mainnet",
    SANDBOX = "sepolia"
}
interface OidcConfiguration {
    clientId: string;
    logoutRedirectUri?: string;
    logoutMode?: 'redirect' | 'silent';
    redirectUri: string;
    scope?: string;
    audience?: string;
}
interface PassportOverrides {
    network: Networks;
    authenticationDomain: string;
    magicPublishableApiKey: string;
    magicProviderId: string;
    passportDomain: string;
    imxPublicApiDomain: string;
    immutableXClient: ImmutableXClient;
    zkEvmRpcUrl: string;
    relayerUrl: string;
    indexerMrBasePath: string;
    orderBookMrBasePath: string;
    passportMrBasePath: string;
}
interface PassportModuleConfiguration extends ModuleConfiguration<PassportOverrides>, OidcConfiguration {
    /**
     * This flag indicates that Passport is being used in a cross-sdk bridge scenario
     * and not directly on the web.
     */
    crossSdkBridgeEnabled?: boolean;
}
type DeviceConnectResponse = {
    code: string;
    deviceCode: string;
    url: string;
    interval: number;
};

/**
 * ProviderErrors should take priority over RpcErrorCodes
 * https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 * https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
declare enum ProviderErrorCode {
    USER_REJECTED_REQUEST = 4001,
    UNAUTHORIZED = 4100,
    UNSUPPORTED_METHOD = 4200,
    DISCONNECTED = 4900
}
declare enum RpcErrorCode {
    RPC_SERVER_ERROR = -32000,
    INVALID_REQUEST = -32600,
    METHOD_NOT_FOUND = -32601,
    INVALID_PARAMS = -32602,
    INTERNAL_ERROR = -32603,
    PARSE_ERROR = -32700,
    TRANSACTION_REJECTED = -32003
}
declare class JsonRpcError extends Error {
    readonly message: string;
    readonly code: ProviderErrorCode | RpcErrorCode;
    constructor(code: ProviderErrorCode | RpcErrorCode, message: string);
}

interface RequestArguments {
    method: string;
    params?: Array<any>;
}
type JsonRpcRequestPayload = RequestArguments & {
    jsonrpc?: string;
    id?: string | number;
};
interface JsonRpcRequestCallback {
    (err: JsonRpcError | null, result?: JsonRpcResponsePayload | (JsonRpcResponsePayload | null)[] | null): void;
}
interface JsonRpcResponsePayload {
    result?: Array<any> | null;
    error?: JsonRpcError | null;
    jsonrpc?: string;
    id?: string | number;
}
type Provider = {
    request: (request: RequestArguments) => Promise<any>;
    sendAsync: (request: JsonRpcRequestPayload | JsonRpcRequestPayload[], callback: JsonRpcRequestCallback) => void;
    send: (request: string | JsonRpcRequestPayload | JsonRpcRequestPayload[], callbackOrParams?: JsonRpcRequestCallback | Array<any>, callback?: JsonRpcRequestCallback) => void;
    on: (event: string, listener: (...args: any[]) => void) => void;
    removeListener: (event: string, listener: (...args: any[]) => void) => void;
    isPassport: boolean;
};

declare class Passport {
    private readonly authManager;
    private readonly config;
    private readonly confirmationScreen;
    private readonly immutableXClient;
    private readonly magicAdapter;
    private readonly multiRollupApiClients;
    private readonly passportImxProviderFactory;
    private readonly passportEventEmitter;
    constructor(passportModuleConfiguration: PassportModuleConfiguration);
    /**
     * @deprecated The method `login` with an argument of `{ useCachedSession: true }` should be used in conjunction with
     * `connectImx` instead.
     */
    connectImxSilent(): Promise<IMXProvider | null>;
    connectImx(): Promise<IMXProvider>;
    connectEvm(): Provider;
    /**
     *
     * Initiates the authorisation flow.
     *
     * @param options.useCachedSession = false - If true, and no active session exists, then the user will not be
     * prompted to log in and the Promise will resolve with a null value.
     * @returns {Promise<UserProfile | null>} the user profile if the user is logged in, otherwise null
     */
    login(options?: {
        useCachedSession: boolean;
    }): Promise<UserProfile | null>;
    loginCallback(): Promise<void>;
    loginWithDeviceFlow(): Promise<DeviceConnectResponse>;
    loginWithDeviceFlowCallback(deviceCode: string, interval: number, timeoutMs?: number): Promise<UserProfile>;
    loginWithPKCEFlow(): string;
    loginWithPKCEFlowCallback(authorizationCode: string, state: string): Promise<UserProfile>;
    logout(): Promise<void>;
    /**
     * Logs the user out of Passport when using device flow authentication.
     *
     * @returns {Promise<string>} The device flow end session endpoint. Consumers are responsible for
     * opening this URL in the same browser that was used to log the user in.
     */
    logoutDeviceFlow(): Promise<string>;
    /**
     * This method should only be called from the logout redirect uri
     * when logout mode is 'silent'.
     */
    logoutSilentCallback(url: string): Promise<void>;
    getUserInfo(): Promise<UserProfile | undefined>;
    getIdToken(): Promise<string | undefined>;
    getAccessToken(): Promise<string | undefined>;
    getLinkedAddresses(): Promise<string[]>;
}

/**
 * Enum representing different chain IDs.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain ID for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain ID for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain ID for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain ID for Ethereum.
 * @property {number} SEPOLIA - The chain ID for Sepolia.
 */
declare enum ChainId {
    IMTBL_ZKEVM_MAINNET = 13371,
    IMTBL_ZKEVM_TESTNET = 13473,
    IMTBL_ZKEVM_DEVNET = 13433,
    ETHEREUM = 1,
    SEPOLIA = 11155111
}
/**
 * Enum representing different chain names.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain name for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain name for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain name for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain name for Ethereum.
 * @property {number} SEPOLIA - The chain name for Sepolia.
 */
declare enum ChainName {
    ETHEREUM = "Ethereum",
    SEPOLIA = "Sepolia",
    IMTBL_ZKEVM_TESTNET = "Immutable zkEVM Test",
    IMTBL_ZKEVM_DEVNET = "Immutable zkEVM Dev",
    IMTBL_ZKEVM_MAINNET = "Immutable zkEVM"
}

/**
 * Represents information about a token.
 * @interface TokenInfo
 * @property {string} name - The name of the token.
 * @property {string} symbol - The symbol of the token.
 * @property {number} decimals - The number of decimal places the token supports.
 * @property {string | undefined} [address] - The address of the token.
 * @property {string | undefined} [icon] - The URL of the token's icon.
 */
interface TokenInfo {
    name: string;
    symbol: string;
    decimals: number;
    address?: string;
    icon?: string;
}

/**
 * Interface representing the parameters for {@link Checkout.getBalance}.
 * @property {Web3Provider} provider - The provider used to get the balance.
 * @property {string} walletAddress - The wallet address.
 * @property {string | undefined} contractAddress - The contract address of the token.
 */
interface GetBalanceParams {
    provider: Web3Provider;
    walletAddress: string;
    contractAddress?: string;
}
/**
 * Interface representing the result of {@link Checkout.getBalance}.
 * @property {BigNumber} balance - The balance of the wallet for the token.
 * @property {string} formattedBalance - The formatted balance of the wallet for the token.
 * @property {TokenInfo} token - The token information.
 */
interface GetBalanceResult {
    balance: BigNumber;
    formattedBalance: string;
    token: TokenInfo;
}
/**
 * Interface representing the parameters for {@link Checkout.getAllBalances}.
 * @property {Web3Provider} provider - The provider used to get the balances.
 * @property {string} walletAddress - The wallet address.
 * @property {ChainId} chainId - The ID of the network.
 */
interface GetAllBalancesParams {
    provider: Web3Provider;
    walletAddress: string;
    chainId: ChainId;
}
/**
 * Interface representing the result of {@link Checkout.getAllBalances}.
 * @property {GetBalanceResult[]} balances - The array of balances of the wallet for every token.
 */
interface GetAllBalancesResult {
    balances: GetBalanceResult[];
}

interface OrderFee {
    amount: FeeToken | FeePercentage;
    recipient: string;
}
interface FeeToken {
    token: string;
}
interface FeePercentage {
    percentageDecimal: number;
}

type BuyResult = BuyResultSuccess | BuyResultFailed | BuyResultInsufficientFunds;
/**
 * Represents the result of {@link Checkout.buy}
 * @property {CheckoutStatus.SUCCESS} status
 * @property {SmartCheckoutSufficient} smartCheckoutResult
 */
type BuyResultSuccess = {
    /** The status to indicate success */
    status: CheckoutStatus.SUCCESS;
    /** The sufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutSufficient;
};
/**
 * Represents the result of {@link Checkout.buy}
 * @property {CheckoutStatus.FAILED} status
 * @property {string} transactionHash
 * @property {string} reason
 * @property {SmartCheckoutSufficient} smartCheckoutResult
 */
type BuyResultFailed = {
    /** The status to indicate failure */
    status: CheckoutStatus.FAILED;
    /** The transaction hash of the failed transaction */
    transactionHash: string;
    /** The reason for the failure */
    reason: string;
    /** The sufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutSufficient;
};
/**
 * Represents the result of {@link Checkout.buy}
 * @property {CheckoutStatus.INSUFFICIENT_FUNDS} status
 * @property {SmartCheckoutInsufficient} smartCheckoutResult
 */
type BuyResultInsufficientFunds = {
    /** The status to indicate insufficient funds */
    status: CheckoutStatus.INSUFFICIENT_FUNDS;
    /** The insufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutInsufficient;
};
type SellResult = SellResultSuccess | SellResultFailed | SellResultInsufficientFunds;
/**
 * Represents the result of {@link Checkout.sell}
 * @property {CheckoutStatus.SUCCESS} status
 * @property {string[]} orderIds
 * @property {SmartCheckoutSufficient} smartCheckoutResult
 */
type SellResultSuccess = {
    /** The status to indicate success */
    status: CheckoutStatus.SUCCESS;
    /** The orders' ids */
    orderIds: string[];
    /** The sufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutSufficient;
};
/**
 * Represents the result of {@link Checkout.sell}
 * @property {CheckoutStatus.FAILED} status
 * @property {string} transactionHash
 * @property {string} reason
 * @property {SmartCheckoutSufficient} smartCheckoutResult
 */
type SellResultFailed = {
    /** The status to indicate failure */
    status: CheckoutStatus.FAILED;
    /** The transaction hash of the failed transaction */
    transactionHash: string;
    /** The reason for the failure */
    reason: string;
    /** The sufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutSufficient;
};
/**
 * Represents the result of {@link Checkout.sell}
 * @property {CheckoutStatus.INSUFFICIENT_FUNDS} status
 * @property {SmartCheckoutInsufficient} smartCheckoutResult
 */
type SellResultInsufficientFunds = {
    /** The status to indicate insufficient funds */
    status: CheckoutStatus.INSUFFICIENT_FUNDS;
    /** The insufficient result of smart checkout */
    smartCheckoutResult: SmartCheckoutInsufficient;
};
type CancelResult = CancelResultSuccess | CancelResultFailed;
/**
 * Represents the result of {@link Checkout.cancel}
 * @property {CheckoutStatus.SUCCESS} status
 */
type CancelResultSuccess = {
    /** The status to indicate success */
    status: CheckoutStatus.SUCCESS;
};
/**
 * Represents the result of {@link Checkout.cancel}
 * @property {CheckoutStatus.FAILED} status
 * @property {string} transactionHash
 * @property {string} reason
 */
type CancelResultFailed = {
    /** The status to indicate failure */
    status: CheckoutStatus.FAILED;
    /** The transaction hash of the failed transaction */
    transactionHash: string;
    /** The reason for the failure */
    reason: string;
};
/**
 * An enum representing the checkout status types
 * @enum {string}
 * @property {string} SUCCESS - If checkout succeeded as the transactions were able to be processed
 * @property {string} FAILED - If checkout failed due to transactions not settling on chain
 * @property {string} INSUFFICIENT_FUNDS - If checkout failed due to insufficient funds
 */
declare enum CheckoutStatus {
    SUCCESS = "SUCCESS",
    FAILED = "FAILED",
    INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"
}
/**
 * The type representing the order to buy
 * @property {string} orderId
 * @property {Array<OrderFee>} takerFees
 */
type BuyOrder = {
    /** the id of the order to buy */
    id: string;
    /** array of order fees to apply to the order */
    takerFees?: OrderFee[];
};
/**
 * The type representing the sell order to create a listing from
 * @property {SellToken} sellToken
 * @property {BuyToken} buyToken
 * @property {OrderFee[]} makerFees
 */
type SellOrder = {
    /** the token to be listed for sale */
    sellToken: SellToken;
    /** the token info of the price of the item */
    buyToken: BuyToken;
    /** option array of makerFees to be applied to the listing */
    makerFees?: OrderFee[];
};
/**
 * Represents the token that the item can be bought with once listed for sale.
 * NativeBuyToken or ERC20BuyToken {@link Checkout.smartCheckout}.
 */
type BuyToken = NativeBuyToken | ERC20BuyToken;
/**
 * Represents a native buy token
 * @property {ItemType} type
 * @property {string} amount
 */
type NativeBuyToken = {
    /** The type indicate this is a native token. */
    type: ItemType.NATIVE;
    /** The amount of native token. */
    amount: string;
};
/**
 * Represents a ERC20 buy token
 * @property {ItemType} type
 * @property {string} amount
 * @property {string} contractAddress
 */
type ERC20BuyToken = {
    /** The type indicate this is a ERC20 token. */
    type: ItemType.ERC20;
    /** The amount of native token. */
    amount: string;
    /** The contract address of the ERC20. */
    contractAddress: string;
};
/**
 * The SellToken type
 * @property {string} id
 * @property {string} collectionAddress
 */
type SellToken = {
    /**  The ERC721 token id */
    id: string;
    /** The ERC721 collection address */
    collectionAddress: string;
};
/**
 * Interface representing the parameters for {@link Checkout.smartCheckout}
 * @property {Web3Provider} provider
 * @property {ItemRequirement[]} itemRequirements
 * @property {FulfillmentTransaction | GasAmount} transactionOrGasAmount
 */
interface SmartCheckoutParams {
    /** The provider to use for smart checkout. */
    provider: Web3Provider;
    /** The item requirements for the transaction. */
    itemRequirements: (NativeItemRequirement | ERC20ItemRequirement | ERC721ItemRequirement)[];
    /** The transaction or gas amount. */
    transactionOrGasAmount: FulfillmentTransaction | GasAmount;
}
/**
 * Represents a native item requirement for a transaction.
 * @property {ItemType.NATIVE} type
 * @property {string} amount
 */
type NativeItemRequirement = {
    /** The type to indicate this is a native item requirement. */
    type: ItemType.NATIVE;
    /** The amount of the item. */
    amount: string;
};
/**
 * Represents an ERC20 item requirement for a transaction.
 * @property {ItemType.ERC20} type
 * @property {string} amount
 * @property {string} contractAddress
 * @property {string} spenderAddress
 */
type ERC20ItemRequirement = {
    /** The type to indicate this is a ERC20 item requirement. */
    type: ItemType.ERC20;
    /** The amount of the item. */
    contractAddress: string;
    /** The contract address of the ERC20. */
    amount: string;
    /** The contract address of the approver. */
    spenderAddress: string;
};
/**
 * Represents an ERC721 item requirement for a transaction.
 * @property {ItemType.ERC721} type
 * @property {string} contractAddress
 * @property {string} id
 * @property {string} spenderAddress
 */
type ERC721ItemRequirement = {
    /** The type to indicate this is a ERC721 item requirement. */
    type: ItemType.ERC721;
    /** The contract address of the ERC721 collection. */
    contractAddress: string;
    /** The ID of this ERC721 in the collection. */
    id: string;
    /** The contract address of the approver. */
    spenderAddress: string;
};
/**
 * An enum representing the item types
 * @enum {string}
 * @property {string} NATIVE - If the item is a native token.
 * @property {string} ERC20 - If the item is an ERC20 token.
 * @property {string} ERC721 - If the item is an ERC721 token.
 */
declare enum ItemType {
    NATIVE = "NATIVE",
    ERC20 = "ERC20",
    ERC721 = "ERC721"
}
/**
 * An enum representing transaction or gas types
 * @enum {string}
 * @property {string} TRANSACTION - If the type is a transaction
 * @property {string} GAS - If the type is the gas amount
 */
declare enum TransactionOrGasType {
    TRANSACTION = "TRANSACTION",
    GAS = "GAS"
}
/**
 * The fulfillment transaction which contains the transaction to send.
 * @property {TransactionOrGasType} type
 * @property {TransactionRequest} transaction
 */
type FulfillmentTransaction = {
    /** The type to indicate this is a fulfillment transaction. */
    type: TransactionOrGasType.TRANSACTION;
    /** The transaction to send. */
    transaction: TransactionRequest;
};
/**
 * The gas amount which contains the gas token and the gas limit.
 * @property {TransactionOrGasType} type
 * @property {GasToken} gasToken
 */
type GasAmount = {
    /** The type to indicate this is a gas amount. */
    type: TransactionOrGasType.GAS;
    /** The gas token. */
    gasToken: GasToken;
};
/**
 * Represents the gas token which is either a native token or an ERC20 token.
 */
type GasToken = NativeGas | ERC20Gas;
/**
 * An enum representing the gas token types
 * @enum {string}
 * @property {string} NATIVE - If the gas token is a native token.
 * @property {string} ERC20 - If the gas token is an ERC20 token.
 */
declare enum GasTokenType {
    NATIVE = "NATIVE",
    ERC20 = "ERC20"
}
/**
 * Represents a native gas token.
 * @property {GasTokenType} type
 * @property {BigNumber} limit
 */
type NativeGas = {
    /** The type to indicate this is a native gas token. */
    type: GasTokenType.NATIVE;
    /** The gas limit. */
    limit: BigNumber;
};
/**
 * Represents an ERC20 gas token.
 * @property {GasTokenType} type
 * @property {string} contractAddress
 * @property {BigNumber} limit
 */
type ERC20Gas = {
    /** The type to indicate this is an ERC20 gas token. */
    type: GasTokenType.ERC20;
    /** The contract address of the ERC20. */
    contractAddress: string;
    /** The gas limit. */
    limit: BigNumber;
};
/**
 * The type representing the result of {@link Checkout.smartCheckout}.
 */
type SmartCheckoutResult = SmartCheckoutSufficient | SmartCheckoutInsufficient;
/**
 * Represents the result of {@link Checkout.smartCheckout} when smart checkout is sufficient.
 * @property {boolean} sufficient
 * @property {TransactionRequirement[]} transactionRequirements
 */
type SmartCheckoutSufficient = {
    /** Indicates that smart checkout determined the user had sufficient funds. */
    sufficient: true;
    /** The transaction requirements smart checkout determined were required for the transaction. */
    transactionRequirements: TransactionRequirement[];
};
/**
 * Represents the result of {@link Checkout.smartCheckout} when smart checkout is insufficient.
 * @property {boolean} sufficient
 * @property {TransactionRequirement[]} transactionRequirements
 * @property {SmartCheckoutRouter} router
 */
type SmartCheckoutInsufficient = {
    /** Indicates that smart checkout determined the user has insufficient funds */
    sufficient: false;
    /** The transaction requirements smart checkout determined were required for the transaction. */
    transactionRequirements: TransactionRequirement[];
    /** The type containing the funding routes the user can take to fulfill the transaction requirements */
    router: SmartCheckoutRouter;
};
/**
 * Represents the routing outcome for a transaction.
 * @property {AvailableRoutingOptions} availableRoutingOptions
 * @property {RoutingOutcome} routingOutcome
 */
type SmartCheckoutRouter = {
    /** The routing options available to the user */
    availableRoutingOptions: AvailableRoutingOptions;
    /** The routing outcome for the transaction which includes the funding routes if routes were found */
    routingOutcome: RoutingOutcome;
};
/**
 * An enum representing the routing outcome types
 * @enum {string}
 * @property {string} ROUTES_FOUND - If funding routes were found for the transaction.
 * @property {string} NO_ROUTES_FOUND - If no funding routes were found for the transaction.
 * @property {string} NO_ROUTE_OPTIONS - If no routing options were available for the transaction.
 */
declare enum RoutingOutcomeType {
    ROUTES_FOUND = "ROUTES_FOUND",
    NO_ROUTES_FOUND = "NO_ROUTES_FOUND",
    NO_ROUTE_OPTIONS = "NO_ROUTE_OPTIONS"
}
type RoutingOutcome = RoutesFound | NoRoutesFound | NoRouteOptions;
/**
 * Represents a routing outcome where funding routes were found.
 * @property {RoutingOutcomeType.ROUTES_FOUND} type
 * @property {AvailableRoutingOptions} fundingRoutes
 */
type RoutesFound = {
    /** Indicates that funding routes were found for the transaction. */
    type: RoutingOutcomeType.ROUTES_FOUND;
    /** The funding routes found for the transaction. */
    fundingRoutes: FundingRoute[];
};
/**
 * Represents a routing outcome where no funding routes were found.
 * @property {RoutingOutcomeType.NO_ROUTES_FOUND} type
 * @property {string} message
 */
type NoRoutesFound = {
    /** Indicates that no funding routes were found for the transaction. */
    type: RoutingOutcomeType.NO_ROUTES_FOUND;
    /** The message indicating why no funding routes were found. */
    message: string;
};
/**
 * Represents a routing outcome where no routing options were available for the transaction.
 * @property {RoutingOutcomeType.NO_ROUTE_OPTIONS} type
 * @property {string} message
 */
type NoRouteOptions = {
    /** Indicates that no routing options were available for the transaction. */
    type: RoutingOutcomeType.NO_ROUTE_OPTIONS;
    /** The message indicating why no routing options were available. */
    message: string;
};
/**
 * Represents a funding route
 * @property {number} priority
 * @property {FundingStep[]} steps
 */
type FundingRoute = {
    /** The priority of the route */
    priority: number;
    /** The steps associated with this funding route */
    steps: FundingStep[];
};
/**
 * Represents a fee
 * @property {BigNumber} amount
 * @property {string} formatted
 * @property {TokenInfo | undefined} token
 */
type Fee = {
    /** The amount of the fee */
    amount: BigNumber;
    /** The formatted amount of the fee */
    formattedAmount: string;
    /** The token info for the fee */
    token?: TokenInfo;
};
type FundingStep = BridgeFundingStep | SwapFundingStep | OnRampFundingStep;
/**
 * Represents a bridge funding route
 * @property {FundingStepType.BRIDGE} type
 * @property {number} chainId
 * @property {FundingItem} fundingItem
 * @property {BridgeFees} fees
 */
type BridgeFundingStep = {
    /** Indicates that this is a bridge funding step */
    type: FundingStepType.BRIDGE;
    /** The chain id the bridge should be executed on */
    chainId: number;
    /** The funding item for the bridge */
    fundingItem: FundingItem;
    /** The fees for the bridge */
    fees: BridgeFees;
};
/**
 * Represents the fees for a bridge funding step
 * @property {Fee} approvalGasFees
 * @property {Fee} bridgeGasFees
 * @property {Fee[]} bridgeFees
 */
type BridgeFees = {
    /** The approval gas fees for the bridge */
    approvalGasFees: Fee;
    /** The bridge gas fees for the bridge */
    bridgeGasFees: Fee;
    /** Additional bridge fees for the bridge */
    bridgeFees: Fee[];
};
/**
 * Represents a swap funding route
 * @property {FundingStepType.SWAP} type
 * @property {number} chainId
 * @property {FundingItem} fundingItem
 * @property {SwapFees} fees
 */
type SwapFundingStep = {
    /** Indicates that this is a swap funding step */
    type: FundingStepType.SWAP;
    /** The chain id the swap should be executed on */
    chainId: number;
    /** The funding item for the swap */
    fundingItem: FundingItem;
    /** The fees for the swap */
    fees: SwapFees;
};
/**
 * Represents the fees for a swap funding step
 * @property {Fee} approvalGasFees
 * @property {Fee} swapGasFees
 * @property {Fee[]} swapFees
 */
type SwapFees = {
    /** The approval gas fees for the swap */
    approvalGasFees: Fee;
    /** The swap gas fees for the swap */
    swapGasFees: Fee;
    /** Additional swap fees for the swap */
    swapFees: Fee[];
};
/**
 * Represents an onramp funding route
 * @property {FundingStepType.ONRAMP} type
 * @property {number} chainId
 * @property {FundingItem} fundingItem
 */
type OnRampFundingStep = {
    /** Indicates that this is an onramp funding step */
    type: FundingStepType.ONRAMP;
    /** The chain id the onramp should provide funds to */
    chainId: number;
    /** The item to be onramped */
    fundingItem: FundingItem;
};
/**
 * An enum representing the funding step types
 * @enum {string}
 * @property {string} BRIDGE - If the funding step is a bridge.
 * @property {string} SWAP - If the funding step is a swap.
 * @property {string} ONRAMP - If the funding step is an onramp.
 */
declare enum FundingStepType {
    BRIDGE = "BRIDGE",
    SWAP = "SWAP",
    ONRAMP = "ONRAMP"
}
/**
 * Represents a funding item
 * @property {ItemType.NATIVE | ItemType.ERC20} type
 * @property {FundsRequired} fundsRequired
 * @property {UserBalance} userBalance
 * @property {TokenInfo} token
 */
type FundingItem = {
    /** The type of the funding item */
    type: ItemType.NATIVE | ItemType.ERC20;
    /** The amount of funds required of this funding item */
    fundsRequired: FundsRequired;
    /** The current user balance of this funding item */
    userBalance: UserBalance;
    /** The token info for the funding item */
    token: TokenInfo;
};
/**
 * Represents the funds required of a funding item
 * @property {BigNumber} amount
 * @property {string} formattedAmount
 */
type FundsRequired = {
    /** The amount of funds required */
    amount: BigNumber;
    /** The formatted amount of funds required */
    formattedAmount: string;
};
/**
 * Represents the user balance of a funding item
 * @property {BigNumber} balance
 * @property {string} formattedBalance
 */
type UserBalance = {
    /** The balance of the funding item */
    balance: BigNumber;
    /** The formatted balance of the funding item */
    formattedBalance: string;
};
/**
 * Represents the transaction requirement for a transaction.
 * @property {ItemType} type
 * @property {boolean} sufficient
 * @property {ItemBalance} required
 * @property {ItemBalance} current
 * @property {BalanceDelta} delta
 */
type TransactionRequirement = {
    /** The type of the transaction requirement. */
    type: ItemType;
    /** If the user address has sufficient funds to cover the transaction. */
    sufficient: boolean;
    /** The required item balance. */
    required: ItemBalance;
    /** The current item balance. */
    current: ItemBalance;
    /** The delta between the required and current balances. */
    delta: BalanceDelta;
};
/**
 * Represents the balance for either a native or ERC20 token.
 * @property {ItemType.NATIVE | ItemType.ERC20} type
 * @property {BigNumber} balance
 * @property {string} formattedBalanc
 * @property {TokenInfo} token
 */
type TokenBalance = {
    /** Type to indicate this is a native or ERC20 token. */
    type: ItemType.NATIVE | ItemType.ERC20;
    /** The balance of the item. */
    balance: BigNumber;
    /** The formatted balance of the item. */
    formattedBalance: string;
    /**  The token info of the item. */
    token: TokenInfo;
};
/**
 * Represents the balance for an ERC721.
 * @property {ItemType.ERC721} type
 * @property {BigNumber} balance
 * @property {string} formattedBalance
 * @property {string} contractAddress
 * @property {string} id
 */
type ERC721Balance = {
    /** Type to indicate this is an ERC721 token. */
    type: ItemType.ERC721;
    /** The balance of the item. */
    balance: BigNumber;
    /** The formatted balance of the item. */
    formattedBalance: string;
    /** The contract address of the ERC721 collection. */
    contractAddress: string;
    /** The ID of the ERC721 in the collection */
    id: string;
};
/**
 * Type representing the balance of an item.
 */
type ItemBalance = ERC721Balance | TokenBalance;
/**
 * Represents the delta between two balances.
 * @property {BigNumber} balance
 * @property {string} formattedBalance
 */
type BalanceDelta = {
    /** The delta of the balance. */
    balance: BigNumber;
    /** The formatted balance of the delta. */
    formattedBalance: string;
};
/**
 * A type representing the Smart Checkout routing options available for a user
 * if they are configured and enabled (not geo-blocked etc.)
 * @property {boolean | undefined} onRamp
 * @property {boolean | undefined} swap
 * @property {boolean | undefined} bridge
 */
type AvailableRoutingOptions = {
    /** If the user can use onramp */
    onRamp?: boolean;
    /** If the user can use swap */
    swap?: boolean;
    /** If the user can use bridge */
    bridge?: boolean;
};

/**
 * Interface representing the parameters for {@link Checkout.buy}
 * @property {Web3Provider} provider - The provider to use for the buy.
 * @property {Array<BuyOrder>} orders - The orders to buy
 * Currently only processes the first order in the array until batch processing is supported.
 */
interface BuyParams {
    provider: Web3Provider;
    orders: Array<BuyOrder>;
}

/**
 * Interface representing the parameters for {@link Checkout.cancel}
 * @property {Web3Provider} provider - The provider to use for the cancel.
 * @property {string[]} orderIds - The order IDs to cancel.
 * Currently only processes the first order in the array until batch processing is supported.
 */
interface CancelParams {
    provider: Web3Provider;
    orderIds: string[];
}

type ExchangeContracts = {
    multicall: string;
    coreFactory: string;
    quoterV2: string;
    peripheryRouter: string;
    secondaryFee: string;
};
/**
 * Type representing an ERC20 token
 * @property {string} type - The token type, used to discriminate between {@link ERC20} and {@link Native}
 * @property {number} chainId - The chain ID
 * @property {string} address - The token address
 * @property {number} decimals - The token decimals
 * @property {string | undefined} symbol - The token symbol or undefined if it is not available
 * @property {string | undefined} name - The token name or undefined if it is not available
 */
type ERC20 = {
    type: 'erc20';
    chainId: number;
    address: string;
    decimals: number;
    symbol?: string;
    name?: string;
};
/**
 * Type representing a native token
 * @property {string} type - The token type, used to discriminate between {@link ERC20} and {@link Native}
 * @property {number} chainId - The chain ID
 * @property {number} decimals - The token decimals
 * @property {string | undefined} symbol - The token symbol or undefined if it is not available
 * @property {string | undefined} name - The token name or undefined if it is not available
 */
type Native = {
    type: 'native';
    chainId: number;
    decimals: number;
    symbol?: string;
    name?: string;
};
/**
 * Type representing the overrides for the {@link Exchange} module
 * @property {string} rpcURL - The RPC URL for the chain
 * @property {ExchangeContracts} exchangeContracts - The DEX contract addresses
 * @property {ERC20[]} commonRoutingTokens - The tokens used to find available pools for a swap
 * @property {Native} nativeToken - The native token of the chain
 * @property {ERC20} wrappedNativeToken - The wrapped native token of the chain
 */
type ExchangeOverrides = {
    rpcURL: string;
    exchangeContracts: ExchangeContracts;
    commonRoutingTokens: ERC20[];
    nativeToken: Native;
    wrappedNativeToken: ERC20;
};

interface CheckoutOverrides {
}
interface CheckoutFeatureConfiguration {
    enable: boolean;
}
/**
 * A type representing the on-ramp configurations for the checkout SDK.
 * @property {boolean} enable - To enable on-ramp feature in Checkout sdk.
*/
interface CheckoutOnRampConfiguration extends CheckoutFeatureConfiguration {
}
/**
 * A type representing the swap configurations for the checkout SDK.
 * @property {boolean} enable - To enable swap feature in Checkout sdk.
*/
interface CheckoutSwapConfiguration extends CheckoutFeatureConfiguration {
}
/**
 * A type representing the bridge configurations for the checkout SDK.
 * @property {boolean} enable - To enable bridge feature in Checkout sdk.
*/
interface CheckoutBridgeConfiguration extends CheckoutFeatureConfiguration {
}
/**
 * A type representing checkout SDK configurations.
 * @property {CheckoutOnRampConfiguration} onRamp - To configure the on-ramp feature.
 * @property {CheckoutSwapConfiguration} swap - To configure the swap feature.
 * @property {CheckoutBridgeConfiguration} bridge - To configure the bridge feature.
 * @property {Passport} passport - To enable passport wallet integration.
*/
interface CheckoutModuleConfiguration extends ModuleConfiguration<CheckoutOverrides> {
    onRamp?: CheckoutOnRampConfiguration;
    swap?: CheckoutSwapConfiguration;
    bridge?: CheckoutBridgeConfiguration;
    passport?: Passport;
}
/**
 * A type representing various remotely defined configurations which are
 * accessible via the Checkout config and configured based on the Environment.
 * @property {DexConfig} dex
 * @property {OnRampConfig} onramp
 * @property {BridgeConfig} bridge
 * @property {AllowedNetworkConfig[]} allowedNetworks
 * @property {GasEstimateTokenConfig | undefined} gasEstimateTokens
 * @property {ImxAddressConfig | undefined} imxAddressMapping
 */
type RemoteConfiguration = {
    /** The config used for the DEX. */
    dex: DexConfig;
    /** The config used for the OnRamp */
    onramp: OnRampConfig;
    /** The config used for the Bridge. */
    bridge: BridgeConfig;
    /** An array representing the allowed networks. */
    allowedNetworks: AllowedNetworkConfig[];
    /** The config for the tokens used to estimate gas. */
    gasEstimateTokens?: GasEstimateTokenConfig;
    /** The IMX address mappings across available networks. */
    imxAddressMapping?: ImxAddressConfig;
};
/**
 * A type representing the fee structure for an OnRamp provider
 * @property {string | undefined} minPercentage
 * @property {string | undefined} maxPercentage
 * @property {string | undefined} feePercentage
 */
type OnRampProviderFees = {
    /** The minimum percentage fee shown if a fee range is provided */
    minPercentage?: string;
    /** The maximum percentage fee shown if a fee range is provided */
    maxPercentage?: string;
    /** The specific fee percentage shown if there is no range provided */
    feePercentage?: string;
};
/**
 * A type representing the configuration for the OnRamp for a specific provider.
 * @property {string} publishableApiKey
 * @property {TokenInfo[]} tokens
 * @property {OnRampProviderFees} fees
 */
type OnRampProviderConfig = {
    /** The on ramp provider publishable api-key */
    publishableApiKey: string;
    /** The allowed tokens for the OnRamp provider */
    tokens: TokenInfo[];
    /** The on ramp provider transaction fees */
    fees: OnRampProviderFees;
};
/**
 * A type representing the configuration for the OnRamp.
 * @property {OnRampProviderConfig} transak
 */
type OnRampConfig = {
    /** OnRamp config for Transak provider */
    [key: string]: OnRampProviderConfig;
};
/**
 * A type representing the configuration for the DEX.
 * @property {ExchangeOverrides | undefined} overrides
 * @property {TokenInfo[] | undefined} tokens
 */
type DexConfig = {
    /** The DEX overrides. */
    overrides?: ExchangeOverrides;
    /** An array of tokens compatible with the DEX. */
    tokens?: TokenInfo[];
};
/**
 * A type representing the configuration for the Bridge.
 * @property {TokenInfo[] | undefined} tokens
 */
type BridgeConfig = {
    /** An array of tokens compatible with the Bridge. */
    tokens?: TokenInfo[];
};
/**
 * A type representing an allowed network.
 * @property {number} chainId
 */
type AllowedNetworkConfig = {
    /** The network chain id. */
    chainId: number;
};
/**
 * A type representing the IMX address mappings across available networks.
 * @type {{ [chainId: string]: string }}
 */
type ImxAddressConfig = {
    [chainId: string]: string;
};
/**
 * A type representing the required information to estimate gas for a transaction.
 * @type {{ [key: string]: { bridgeToL2Addresses?: GasEstimateBridgeToL2TokenConfig, swapAddresses?: GasEstimateSwapTokenConfig } }}
 * - A map of addresses for estimating gas keyed by the network chain id.
 * @property {GasEstimateBridgeToL2TokenConfig | undefined} bridgeToL2Addresses
 * @property {GasEstimateSwapTokenConfig | undefined} swapAddresses
 */
type GasEstimateTokenConfig = {
    [key: string]: {
        /** The type representing the addresses for a bridge to layer 2 gas estimate. */
        bridgeToL2Addresses?: GasEstimateBridgeToL2TokenConfig;
        /** The type representing the addresses for a swap gas estimate */
        swapAddresses?: GasEstimateSwapTokenConfig;
    };
};
/**
 * A type representing the config for a bridge to layer 2 gas estimate.
 * @property {string | 'NATIVE'} gasTokenAddress
 * @property {string} fromAddress
 */
type GasEstimateBridgeToL2TokenConfig = {
    /**  The address of the gas token. */
    gasTokenAddress: string | 'NATIVE';
    /** The address of the token being bridged. */
    fromAddress: string;
};
/**
 * A type representing the config for a swap gas estimate.
 * @property {string} inAddress
 * @property {string} outAddress
 */
type GasEstimateSwapTokenConfig = {
    /** The in token address. */
    inAddress: string;
    /** The out token address. */
    outAddress: string;
};
/**
 * A type representing all the feature flags available.
 * @property {TokenInfo[] | undefined} allowed -
 * @property {boolean | undefined} blockscout -
 */
type ChainTokensConfig = {
    /** List of allowed tokens for a given chain. */
    allowed?: TokenInfo[];
    /** Feature flag to enable/disable blockscout integration. */
    blockscout?: boolean;
};

/**
 * Interface representing the params of {@link Checkout.connect}.
 * @property {Web3Provider} provider - The provider used to connect to the network.
 */
interface ConnectParams {
    provider: Web3Provider;
}
/**
 * Interface representing the result of {@link Checkout.connect}.
 * @property {Web3Provider} provider - The provider used to connect to the network.
 */
interface ConnectResult {
    provider: Web3Provider;
}
/**
 * Interface representing the params of {@link Checkout.checkIsWalletConnected}.
 * @property {Web3Provider} provider - The provider used to connect to the network.
 */
interface CheckConnectionParams {
    provider: Web3Provider;
}
/**
 * Interface representing the result of {@link Checkout.checkIsWalletConnected}.
 * @property {boolean} isConnected - A boolean indicating the connection status of th Web3 provider.
 * @property {string} walletAddress - The wallet address used to check the connection.
 */
interface CheckConnectionResult {
    isConnected: boolean;
    walletAddress: string;
}

/**
 * An enum representing the type of gas estimate.
 * @enum {string}
 * @property {string} BRIDGE_TO_L2 - The gas estimate type for a bridge to L2 transaction.
 * @property {string} SWAP - The gas estimate type for a swap transaction.
 */
declare enum GasEstimateType {
    BRIDGE_TO_L2 = "BRIDGE_TO_L2",
    SWAP = "SWAP"
}
/**
 * Represents the parameters for estimating gas usage, which can be either
 * GasEstimateBridgeToL2Params or GasEstimateSwapParams {@link Checkout.gasEstimate}.
 * @typedef {GasEstimateBridgeToL2Params | GasEstimateSwapParams} GasEstimateParams
 */
type GasEstimateParams = GasEstimateBridgeToL2Params | GasEstimateSwapParams;
/**
 * An interface representing the parameters for estimating gas for a bridge to L2 transaction {@link Checkout.gasEstimate}.
 * @param {GasEstimateType.BRIDGE_TO_L2} gasEstimateType - The type of gas estimate.
 * @param {boolean} isSpendingCapApprovalRequired - Whether or not spending cap approval is required.
 */
interface GasEstimateBridgeToL2Params {
    gasEstimateType: GasEstimateType.BRIDGE_TO_L2;
    isSpendingCapApprovalRequired: boolean;
}
/**
 * An interface representing the parameters for a gas estimate swap {@link Checkout.gasEstimate}.
 * @interface
 * @property {GasEstimateType.SWAP} gasEstimateType - The type of gas estimate, which is always "swap".
 */
interface GasEstimateSwapParams {
    gasEstimateType: GasEstimateType.SWAP;
}
/**
 * An interface representing the result of a gas estimate for a swap transaction {@link Checkout.gasEstimate}.
 * @interface GasEstimateSwapResult
 * @property {GasEstimateType.SWAP} gasEstimateType - The type of gas estimate, which is always "SWAP".
 * @property {TokenAmountEstimate} gasFee - The estimated gas fee for the swap transaction.
 */
interface GasEstimateSwapResult {
    gasEstimateType: GasEstimateType.SWAP;
    gasFee: TokenAmountEstimate;
}
/**
 * An interface representing the result of a gas estimate for a bridge to L2 transaction {@link Checkout.gasEstimate}.
 * @interface GasEstimateBridgeToL2Result
 * @property {GasEstimateType.BRIDGE_TO_L2} gasEstimateType - The type of gas estimate.
 * @property {TokenAmountEstimate} gasFee - The estimated gas fee for the transaction.
 * @property {TokenAmountEstimate} bridgeFee - The estimated bridge fee for the transaction.
 * @property {boolean} bridgeable - A boolean indicating whether the transaction is bridgeable.
 */
interface GasEstimateBridgeToL2Result {
    gasEstimateType: GasEstimateType.BRIDGE_TO_L2;
    gasFee: TokenAmountEstimate;
    bridgeFee: TokenAmountEstimate;
    bridgeable: boolean;
}
interface TokenAmountEstimate {
    estimatedAmount?: BigNumber;
    token?: TokenInfo;
}

/**
 * Represents information about a network.
 * @interface NetworkInfo
 * @property {string} name - The name of the network.
 * @property {number} chainId - The chain ID of the network.
 * @property {TokenInfo} nativeCurrency - Information about the native currency of the network.
 * @property {boolean} isSupported - Indicates whether the network is supported.
 */
interface NetworkInfo {
    name: string;
    chainId: number;
    nativeCurrency: TokenInfo;
    isSupported: boolean;
}

/**
 * Interface representing the parameters for {@link Checkout.switchNetwork}.
 * @property {Web3Provider} provider - The provider to connect to the network.
 * @property {ChainId} chainId - The ID of the network to switch to.
 */
interface SwitchNetworkParams {
    provider: Web3Provider;
    chainId: ChainId;
}
/**
 * Represents the result of switching the network in a Web3 application {@link Checkout.switchNetwork}.
 * @interface SwitchNetworkResult
 * @property {NetworkInfo} network - The information about the switched network.
 * @property {Web3Provider} provider - The Web3 provider for the switched network.
 */
interface SwitchNetworkResult {
    network: NetworkInfo;
    provider: Web3Provider;
}
/**
 * * Interface representing the parameters for {@link Checkout.getNetworkInfo}.
 * @property {Web3Provider} provider - The provider to connect to the network.
 */
interface GetNetworkParams {
    provider: Web3Provider;
}
/**
 * * Interface representing the parameters for {@link Checkout.getNetworkAllowList}.
 * @property {NetworkFilterTypes} type - The type of allow list filter to apply.
 * @property {NetworkFilter[]} [exclude] - The list of networks to exclude from the allow list.
 */
interface GetNetworkAllowListParams {
    type: NetworkFilterTypes;
    exclude?: NetworkFilter[];
}
/**
 * Interface representing the result of {@link Checkout.getNetworkAllowList}.
 * @property {NetworkInfo[]} networks - The list of allowed networks.
 */
interface GetNetworkAllowListResult {
    networks: NetworkInfo[];
}
/**
 * Enum representing the types of filters that can be applied to get the allow list of networks.
 */
declare enum NetworkFilterTypes {
    ALL = "all"
}
/**
 * Interface representing a filter for filtering a specific network.
 * @property {ChainId} chainId - The ID of the network to allow or disallow.
 */
interface NetworkFilter {
    chainId: ChainId;
}
type NetworkDetails = {
    chainIdHex: string;
    chainName: string;
    rpcUrls: string[];
    nativeCurrency: TokenInfo;
    blockExplorerUrls?: string[];
};
type NetworkMap = Map<ChainId, NetworkDetails>;

/**
 * Interface representing the parameters for {@link Checkout.sell}
 * @property {Web3Provider} provider - The provider to use for the sell.
 * @property {Array<SellOrder>} orders - An array of sell orders to execute.
 * Currently only processes the first order in the array until batch processing is supported.
 */
interface SellParams {
    provider: Web3Provider;
    orders: Array<SellOrder>;
}

/**
 * Interface representing the parameters for {@link Checkout.getTokenAllowList}.
 * @property {TokenFilterTypes} type - The type of token to retrieve.
 * @property {ChainId}  chainId - The ID of the blockchain network.
 * @property {TokenFilter[]} [exclude] - The tokens to exclude from the list.
 */
interface GetTokenAllowListParams {
    type: TokenFilterTypes;
    chainId: ChainId;
    exclude?: TokenFilter[];
}
/**
 * Interface representing the result of {@link Checkout.getTokenAllowList}.
 * @property {TokenInfo[]} tokens - The list of tokens allowed for the specified params.
 */
interface GetTokenAllowListResult {
    tokens: TokenInfo[];
}
/**
 * Enum representing the types of token filters available.
 */
declare enum TokenFilterTypes {
    ALL = "all",
    SWAP = "swap",
    BRIDGE = "bridge",
    ONRAMP = "onramp"
}
/**
 * Interface representing a token filter that can be used to exclude certain tokens.
 * @property {string} address - The token contract address.
 */
interface TokenFilter {
    address: string;
}

/**
 * Interface representing the parameters for {@link Checkout.sendTransaction}.
 * @property {Web3Provider} provider - The provider to connect to the network.
 * @property {TransactionRequest} transaction - The transaction to send.
 */
interface SendTransactionParams {
    provider: Web3Provider;
    transaction: TransactionRequest;
}
/**
 * Interface representing the result of {@link Checkout.sendTransaction}.
 * @property {TransactionResponse} transactionResponse - The response of the transaction.
 */
interface SendTransactionResult {
    transactionResponse: TransactionResponse;
}

/**
 * Enum representing the names of different wallet providers.
 */
declare enum WalletProviderName {
    PASSPORT = "passport",
    METAMASK = "metamask"
}
/**
 * Interface for the parameters required to create a wallet provider {@link Checkout.createProvider}.
 * @interface CreateProviderParams
 * @property {WalletProviderName} walletProviderName - The wallet provider name to create a provider for.
 */
interface CreateProviderParams {
    walletProviderName: WalletProviderName;
}
/**
 * Represents the result of creating a Web3 provider {@link Checkout.createProvider}.
 * @property {Web3Provider} provider - The created Web3 provider.
 * @property {WalletProviderName} walletProviderName - The wallet provider name of the provider that was created.
 */
type CreateProviderResult = {
    provider: Web3Provider;
    walletProviderName: WalletProviderName;
};

/**
 * Interface representing a wallet filter to be used in {@link GetWalletAllowListParams}.
 * @property {WalletProviderName} walletProviderName - The wallet provider name to filter wallets by.
 */
interface WalletFilter {
    walletProviderName: WalletProviderName;
}
/**
 * Interface representing the parameters for {@link Checkout.getWalletAllowList}.
 * @property {WalletFilterTypes} type - The type of wallets to filter by.
 * @property {WalletFilter[]} [exclude] - An optional list of wallet filters to exclude from the allowed wallets list.
 */
interface GetWalletAllowListParams {
    type: WalletFilterTypes;
    exclude?: WalletFilter[];
}
/**
 * Interface representing information about a wallet used in {@link GetWalletAllowListResult}.
 * @property {WalletProviderName} walletProviderName - The wallet provider name for the wallet.
 * @property {string | undefined} description - A description of the wallet.
 * @property {string | undefined} icon - The URL/data:image of an icon for the wallet.
 */
interface WalletInfo {
    walletProviderName: WalletProviderName;
    description?: string;
    icon?: string;
}
/**
 * Interface representing the result of {@link Checkout.getWalletAllowList}.
 * @property {WalletInfo[]} wallets - A list of {@link WalletInfo} objects representing the allowed wallets.
 */
interface GetWalletAllowListResult {
    wallets: WalletInfo[];
}
/**
 * Enum representing the platform filters used in {@link GetWalletAllowListParams}.
 */
declare enum WalletFilterTypes {
    ALL = "all"
}

/**
 * An enum representing the type of exchange.
 * @enum {string}
 * @property {string} ONRAMP - The exchange type for transacting.
 */
declare enum ExchangeType {
    ONRAMP = "onramp"
}
/**
 * Interface representing the result of {@link Checkout.createFiatRampUrl}.
 * @property {ExchangeType} exchangeType - The ExchangeType specified.
 * @property {Web3Provider} web3Provider - The Web3Provider used to exchange.
 * @property {string | undefined} tokenAmount - The token amount specified as input.
 * @property {string | undefined} tokenAddress - The token address specified as input.
 * @property {Passport | undefined} passport - The Passport instance specified as input.
 */
interface FiatRampParams {
    exchangeType: ExchangeType;
    web3Provider: Web3Provider;
    tokenAmount?: string;
    tokenAddress?: string;
    passport?: any;
}

type RemoteConfigParams = {
    isDevelopment: boolean;
    isProduction: boolean;
};
declare class RemoteConfigFetcher {
    private isDevelopment;
    private isProduction;
    private configCache;
    private tokensCache;
    private version;
    constructor(params: RemoteConfigParams);
    private static makeHttpRequest;
    private getEndpoint;
    private loadConfig;
    private loadConfigTokens;
    getConfig(key?: keyof RemoteConfiguration): Promise<RemoteConfiguration | RemoteConfiguration[keyof RemoteConfiguration] | undefined>;
    getTokensConfig(chainId: ChainId): Promise<ChainTokensConfig>;
}

declare class CheckoutConfiguration {
    readonly isDevelopment: boolean;
    readonly isProduction: boolean;
    readonly isOnRampEnabled: boolean;
    readonly isSwapEnabled: boolean;
    readonly isBridgeEnabled: boolean;
    readonly remote: RemoteConfigFetcher;
    readonly environment: Environment;
    readonly networkMap: NetworkMap;
    constructor(config: CheckoutModuleConfiguration);
}

interface FiatRampWidgetParams {
    exchangeType: ExchangeType;
    isPassport: boolean;
    walletAddress?: string;
    tokenAmount?: string;
    tokenSymbol?: string;
    email?: string;
}
declare class FiatRampService {
    readonly config: CheckoutConfiguration;
    /**
     * Constructs a new instance of the FiatRampService class.
     * @param {CheckoutConfiguration} config - The config required for the FiatRampService.
     */
    constructor(config: CheckoutConfiguration);
    feeEstimate(): Promise<OnRampProviderFees>;
    createWidgetUrl(params: FiatRampWidgetParams): Promise<string>;
    private getTransakWidgetUrl;
}

type AvailabilityService = {
    checkDexAvailability: () => Promise<boolean>;
};

/**
 * Enum representing the themes for the widgets.
 */
declare enum WidgetTheme {
    LIGHT = "light",
    DARK = "dark"
}

/**
 * Widget Configuration represents the shared configuration options for the Checkout Widgets.
 * @property {WidgetTheme | undefined} theme
 */
type WidgetConfiguration = {
    /** The theme of the Checkout Widget (default: "DARK") */
    theme?: WidgetTheme;
};

/**
 * Enum representing the events emitted by the widgets.
 */
declare enum IMTBLWidgetEvents {
    IMTBL_WIDGETS_PROVIDER = "imtbl-widgets-provider",
    IMTBL_CONNECT_WIDGET_EVENT = "imtbl-connect-widget",
    IMTBL_WALLET_WIDGET_EVENT = "imtbl-wallet-widget",
    IMTBL_SWAP_WIDGET_EVENT = "imtbl-swap-widget",
    IMTBL_BRIDGE_WIDGET_EVENT = "imtbl-bridge-widget",
    IMTBL_ONRAMP_WIDGET_EVENT = "imtbl-onramp-widget",
    IMTBL_SALE_WIDGET_EVENT = "imtbl-sale-widget"
}
/**
 * Enum for events raised for about provider objects
 */
declare enum ProviderEventType {
    PROVIDER_UPDATED = "PROVIDER_UPDATED"
}
/**
 * Payload type for the PROVIDER_UPDATED event
 */
type ProviderUpdated = {
    provider: Web3Provider;
};

/**
 * Enum representing possible Connect Widget event types.
 */
declare enum ConnectEventType {
    CLOSE_WIDGET = "close-widget",
    SUCCESS = "success",
    FAILURE = "failure"
}
/**
 * Represents a successful connection.
 * @property {Web3Provider} provider
 * @property {WalletProviderName | undefined} walletProviderName
 */
type ConnectionSuccess = {
    /** The connected provider. */
    provider: Web3Provider;
    /** The wallet provider name of the connected provider. */
    walletProviderName: WalletProviderName | undefined;
};
/**
 * Represents a connection failure with a reason.
 * @property {string} reason
 */
type ConnectionFailed = {
    /** The reason for the failed connection. */
    reason: string;
};

/**
 * Enum representing possible Wallet Widget event types.
 */
declare enum WalletEventType {
    CLOSE_WIDGET = "close-widget",
    NETWORK_SWITCH = "network-switch",
    DISCONNECT_WALLET = "disconnect-wallet"
}
/**
 * Represents an event that is triggered when the user switches the network in their wallet.
 * @property {string} network
 * @property {number} chainId
 * @property {Web3Provider} provider
 */
type WalletNetworkSwitch = {
    /**  The name of the network that the user switched to. */
    network: string;
    /**  The chain ID of the network that the user switched to. */
    chainId: number;
    /** The Web3 provider object for the switched network. */
    provider: Web3Provider;
};
/**
 * Represents an event that is triggered when a wallet is disconnected.
 */
type WalletDisconnect = {};

/**
 * Enum representing possible Swap Widget event types.
 */
declare enum SwapEventType {
    CLOSE_WIDGET = "close-widget",
    SUCCESS = "success",
    FAILURE = "failure",
    REJECTED = "rejected"
}
/**
 * Represents a successful swap transaction.
 * @property {string} transactionHash
 */
type SwapSuccess = {
    /** The hash of the successful transaction. */
    transactionHash: string;
};
/**
 * Type representing a Swap Widget with type FAILURE.
 * @property {string} reason
 * @property {number} timestamp
 */
type SwapFailed = {
    /** The reason why the swap failed. */
    reason: string;
    /** The timestamp of the failed swap. */
    timestamp: number;
};
/**
 * Type representing a Swap Widget with type REJECTED.
 * @property {string} reason -
 * @property {number} timestamp -
 */
type SwapRejected = {
    /** The reason why the swap failed. */
    reason: string;
    /** The timestamp of the failed swap. */
    timestamp: number;
};

/**
 * Enum representing possible Sale Widget event types.
 */
declare enum SaleEventType {
    CLOSE_WIDGET = "close-widget",
    SUCCESS = "success",
    FAILURE = "failure",
    REJECTED = "rejected",
    TRANSACTION_SUCCESS = "transaction-success"
}
/**
 * Represents a successful Sale transaction.
 * @property {Array} transactions -
 */
type SaleSuccess = {
    /** The executed transactions */
    transactions: {
        method: string;
        hash: string | undefined;
    }[];
    [key: string]: unknown;
};
/**
 * Type representing a Sale Widget with type FAILURE.
 * @property {string} reason
 * @property {number} timestamp
 * @property {Array} transactions
 */
type SaleFailed = {
    /** The reason why the swap failed. */
    reason: string;
    /** The timestamp of the failed swap. */
    timestamp: number;
    /** The executed transactions */
    transactions: {
        method: string;
        hash: string | undefined;
    }[];
};
/**
 * Type representing a Sale Widget with type TRANSACTION_SUCCESS.
 * @property {Object} transactions
 */
type SaleTransactionSuccess = {
    /** The executed transactions */
    transactions: {
        method: string;
        hash: string | undefined;
    }[];
};

/**
 * Enum of possible Bridge Widget event types.
 */
declare enum BridgeEventType {
    CLOSE_WIDGET = "close-widget",
    SUCCESS = "success",
    FAILURE = "failure"
}
/**
 * Represents a successful bridge transaction.
 * @property {string} transactionHash
 */
type BridgeSuccess = {
    /** The hash of the successful transaction. */
    transactionHash: string;
};
/**
 * Represents a failed bridge transaction.
 * @property {string} reason
 * @property {number} timestamp
 */
type BridgeFailed = {
    /** The reason for the failed transaction. */
    reason: string;
    /** The timestamp of the failed transaction. */
    timestamp: number;
};

/**
 * Enum representing different types of orchestration events.
 */
declare enum OrchestrationEventType {
    REQUEST_CONNECT = "request-connect",
    REQUEST_WALLET = "request-wallet",
    REQUEST_SWAP = "request-swap",
    REQUEST_BRIDGE = "request-bridge",
    REQUEST_ONRAMP = "request-onramp"
}
/**
 * Represents the connect event object when the connect widget is requested.
 * @property {string} walletProviderName
 */
type RequestConnectEvent = {
    /** The wallet provider name. */
    walletProviderName: string;
};
/**
 * Represents the wallet event object when the wallet widget is requested.
 * @property {string} walletProviderName
 */
type RequestWalletEvent = {
    /** The wallet provider name. */
    walletProviderName: string;
};
/**
 * Represents the swap event object when the swap widget is requested.
 * @property {string} fromTokenAddress
 * @property {string} toTokenAddress
 * @property {string} amount
 */
type RequestSwapEvent = {
    /** The address of the token to swap from. */
    fromTokenAddress: string;
    /** The address of the token to swap to. */
    toTokenAddress: string;
    /** The amount of from tokens to swap. */
    amount: string;
};
/**
 * Represents the bridge event object when the bridge widget is requested.
 * @property {string} tokenAddress
 * @property {string} amount
 */
type RequestBridgeEvent = {
    /** The address of the token to bridge. */
    tokenAddress: string;
    /** The amount of tokens to bridge. */
    amount: string;
};
/**
 * Represents the onramp event object when the onramp widget is requested.
 * @property {string} tokenAddress
 * @property {string} amount
 */
type RequestOnrampEvent = {
    /** The address of the token to be used for onramp. */
    tokenAddress: string;
    /** The amount of tokens to onramp. */
    amount: string;
};
type OrchestrationEventData = RequestConnectEvent | RequestWalletEvent | RequestSwapEvent | RequestBridgeEvent | RequestOnrampEvent;

/**
 * Enum of possible OnRamp Widget event types.
 */
declare enum OnRampEventType {
    CLOSE_WIDGET = "close-widget",
    SUCCESS = "success",
    FAILURE = "failure"
}
/**
 * Represents a successful on-ramp transaction.
 * @property {string} transactionHash
 */
type OnRampSuccess = {
    /** The transaction hash of the successful transaction. */
    transactionHash: string;
};
/**
 * Type representing a On-ramp Widget with type FAILURE.
 * @property {string} reason
 * @property {number} timestamp
 */
type OnRampFailed = {
    /** The reason why the on-ramp failed. */
    reason: string;
    /** The timestamp of the failed transaction. */
    timestamp: number;
};

declare enum ConnectTargetLayer {
    LAYER1 = "LAYER1",
    LAYER2 = "LAYER2"
}
type ConnectWidgetParams = {};

/**
 * Bridge Widget parameters
 * @property {string | undefined} fromContractAddress
 * @property {string | undefined} amount
 * @property {WalletProviderName | undefined} walletProviderName
 */
type BridgeWidgetParams = {
    /** The contract address of the token to bridge from, used to populate the bridge form token field */
    fromContractAddress?: string;
    /** The formatted amount to bridge, used to populate the bridge form amount field */
    amount?: string;
    /** The wallet provider name to use for the bridge widget */
    walletProviderName?: WalletProviderName;
};

/**
 * Wallet Widget parameters
 * @property {WalletProviderName | undefined} walletProviderName
 */
type WalletWidgetParams = {
    /** The wallet provider name to use for the wallet widget */
    walletProviderName?: WalletProviderName;
};

/**
 * Swap Widget parameters
 * @property {string | undefined} amount
 * @property {string | undefined} fromContractAddress
 * @property {string | undefined} toContractAddress
 * @property {WalletProviderName | undefined} walletProviderName
 */
type SwapWidgetParams = {
    /** The formatted amount to swap, used to populate the swap from amount field */
    amount?: string;
    /** The contract address of the token to swap from */
    fromContractAddress?: string;
    /** The contract address of the token to swap to */
    toContractAddress?: string;
    /** The wallet provider name to use for the swap widget */
    walletProviderName?: WalletProviderName;
};

/**
 * OnRamp Widget parameters
 * @property {string | undefined} contractAddress
 * @property {string | undefined} amount
 * @property {WalletProviderName | undefined} walletProviderName
 */
type OnRampWidgetParams = {
    /** The contract address of the token to onramp */
    contractAddress?: string;
    /** The formatted amount to onramp, used to populate the onramp form amount field */
    amount?: string;
    /** The wallet provider name to use for the onramp widget */
    walletProviderName?: WalletProviderName;
};

/**
 * Sale Widget parameters
 * @property {string} amount
 * @property {string} environmentId
 * @property {string} fromContractAddress
 * @property {SaleItem[]} items
 * @property {WalletProviderName | undefined} walletProviderName
 */
type SaleWidgetParams = {
    /** The total price to pay for the items in the sale */
    amount?: string;
    environmentId?: string;
    fromContractAddress?: string;
    /** The list of products to be purchased */
    items?: SaleItem[];
    /** The wallet provider name to default to if no web3Provider is passed */
    walletProviderName?: WalletProviderName;
};
/**
 * A product to be purchased
 * @property {string} productId
 * @property {number} qty
 * @property {string} name
 * @property {string} image
 * @property {string} description
 */
type SaleItem = {
    /** The id of the product */
    productId: string;
    /** The quantity to be purchased */
    qty: number;
    /** The name of the item */
    name: string;
    /** The image url of the item */
    image: string;
    /** The description of the item */
    description: string;
};

/**
 * Connect Widget Configuration represents the configuration options for the Connect Widget.
 */
type ConnectWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Bridge Widget Configuration represents the configuration options for the Bridge Widget.
 */
type BridgeWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Wallet Widget Configuration represents the configuration options for the Wallet Widget.
 */
type WalletWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Swap Widget Configuration represents the configuration options for the Swap Widget.
 */
type SwapWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Onramp Widget Configuration represents the configuration options for the Onramp Widget.
 */
type OnrampWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Sale Widget Configuration represents the configuration options for the Sale Widget.
 */
type SaleWidgetConfiguration = {} & WidgetConfiguration;

/**
 * Enum representing the list of widget types.
 */
declare enum WidgetType {
    CONNECT = "connect",
    WALLET = "wallet",
    SWAP = "swap",
    BRIDGE = "bridge",
    ONRAMP = "onramp",
    SALE = "sale"
}
/**
 * Widget properties definition for each widget. Used for creating and updating widgets
 */
type WidgetProperties<T extends WidgetType> = {
    config?: WidgetConfigurations[T];
    provider?: Web3Provider;
};
type WidgetConfigurations = {
    [WidgetType.CONNECT]: ConnectWidgetConfiguration;
    [WidgetType.WALLET]: WalletWidgetConfiguration;
    [WidgetType.SWAP]: SwapWidgetConfiguration;
    [WidgetType.BRIDGE]: BridgeWidgetConfiguration;
    [WidgetType.ONRAMP]: OnrampWidgetConfiguration;
    [WidgetType.SALE]: SaleWidgetConfiguration;
};
type WidgetParameters = {
    [WidgetType.CONNECT]: ConnectWidgetParams;
    [WidgetType.WALLET]: WalletWidgetParams;
    [WidgetType.SWAP]: SwapWidgetParams;
    [WidgetType.BRIDGE]: BridgeWidgetParams;
    [WidgetType.ONRAMP]: OnRampWidgetParams;
    [WidgetType.SALE]: SaleWidgetParams;
};
/**
 * Represents all the possible event types that are emitted by the widgets.
 */
type WidgetEventTypes = {
    [WidgetType.CONNECT]: ConnectEventType | OrchestrationEventType;
    [WidgetType.WALLET]: WalletEventType | OrchestrationEventType;
    [WidgetType.SWAP]: SwapEventType | OrchestrationEventType;
    [WidgetType.BRIDGE]: BridgeEventType | OrchestrationEventType;
    [WidgetType.ONRAMP]: OnRampEventType | OrchestrationEventType;
    [WidgetType.SALE]: SaleEventType | OrchestrationEventType;
};
type OrchestrationMapping = {
    [OrchestrationEventType.REQUEST_CONNECT]: RequestConnectEvent;
    [OrchestrationEventType.REQUEST_WALLET]: RequestWalletEvent;
    [OrchestrationEventType.REQUEST_SWAP]: RequestSwapEvent;
    [OrchestrationEventType.REQUEST_BRIDGE]: RequestBridgeEvent;
    [OrchestrationEventType.REQUEST_ONRAMP]: RequestOnrampEvent;
};
type ProviderEventMapping = {
    [ProviderEventType.PROVIDER_UPDATED]: ProviderUpdated;
};
/**
 * Mapping of widget type, to each of it's events and then each event's payload
 * Update this whenever a new event is created and used by a widget
 * Each widget also has all of the orchestration events
*/
type WidgetEventData = {
    [WidgetType.CONNECT]: {
        [ConnectEventType.SUCCESS]: ConnectionSuccess;
        [ConnectEventType.FAILURE]: ConnectionFailed;
        [ConnectEventType.CLOSE_WIDGET]: {};
    } & OrchestrationMapping & ProviderEventMapping;
    [WidgetType.WALLET]: {
        [WalletEventType.NETWORK_SWITCH]: WalletNetworkSwitch;
        [WalletEventType.DISCONNECT_WALLET]: WalletDisconnect;
        [WalletEventType.CLOSE_WIDGET]: {};
    } & OrchestrationMapping & ProviderEventMapping;
    [WidgetType.SWAP]: {
        [SwapEventType.SUCCESS]: SwapSuccess;
        [SwapEventType.FAILURE]: SwapFailed;
        [SwapEventType.REJECTED]: SwapRejected;
        [SwapEventType.CLOSE_WIDGET]: {};
    } & OrchestrationMapping & ProviderEventMapping;
    [WidgetType.BRIDGE]: {
        [BridgeEventType.SUCCESS]: BridgeSuccess;
        [BridgeEventType.FAILURE]: BridgeFailed;
        [BridgeEventType.CLOSE_WIDGET]: {};
    } & OrchestrationMapping & ProviderEventMapping;
    [WidgetType.ONRAMP]: {
        [OnRampEventType.SUCCESS]: OnRampSuccess;
        [OnRampEventType.FAILURE]: OnRampFailed;
        [OnRampEventType.CLOSE_WIDGET]: {};
    } & OrchestrationMapping & ProviderEventMapping;
    [WidgetType.SALE]: {
        [SaleEventType.SUCCESS]: SaleSuccess;
        [SaleEventType.FAILURE]: SaleFailed;
        [SaleEventType.REJECTED]: any;
        [SaleEventType.CLOSE_WIDGET]: {};
        [SaleEventType.TRANSACTION_SUCCESS]: SaleTransactionSuccess;
    } & OrchestrationMapping & ProviderEventMapping;
};
/**
 * Represents an event emitted by a widget. The event type should match the event data
 */
/**
 * Represents an event emitted by a widget.
 * @template T - The widget type
 * @template KEventName - The widget event name.
 * @property {KEventName} type - The type of the event.
 * @property {WidgetEventData[T][KEventName]} data - The data associated with the widget event.
 */
type WidgetEvent<T extends WidgetType, KEventName extends keyof WidgetEventData[T]> = {
    type: KEventName;
    data: WidgetEventData[T][KEventName];
};
/**
 * Represents an event emitted by a widget.
 * @template KEventName - The orchestration event name.
 * @property {KEventName} type
 * @property {OrchestrationMapping[KEventName]} data
 */
type OrchestrationEvent<KEventName extends keyof OrchestrationMapping> = {
    /** The type of the event. */
    type: KEventName;
    /** The data associated with the event. */
    data: OrchestrationMapping[KEventName];
};
/**
 * Represents an event emitted by a widget.
 * @template KEventName - The provider event name.
 * @property {KEventName} type
 * @property {ProviderEventMapping[KEventName]} data
 */
type ProviderEvent<KEventName extends keyof ProviderEventMapping> = {
    /** The type of the event. */
    type: KEventName;
    /** The data associated with the event. */
    data: ProviderEventMapping[KEventName];
};
interface IWidgetsFactory {
    /**
     * Create a new widget instance.
     * @param type widget type to instantiate.
     * @param props widget configurations and provider.
     */
    create<T extends WidgetType>(type: T, props?: WidgetProperties<T>): Widget<T>;
    /**
     * Update the widgets provider instance.
     * @param provider the provider instance to update all widgets.
     */
    updateProvider(provider: Web3Provider): void;
}
/**
 * Widget interface. Every widget implements this interface.
 */
interface Widget<T extends WidgetType> {
    /**
     * Mount a widget to a DOM ref element.
     * @param id ID of the DOM element where the widget will be mounted.
     * @param params widget parameters.
     */
    mount(id: string, params?: WidgetParameters[T]): void;
    /**
     * Unmount a widget and reset parameters
     */
    unmount(): void;
    /**
     * Update the widget properties
     * @param props Widget specific properties including configuration
     */
    update(props: WidgetProperties<T>): void;
    /**
     * Add a listener for a widget event.
     * @param event Widget specific event name.
     * @param callback function to execute when the event is received.
     */
    addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
    /**
     * Removes an event listener for a widget event.
     * @param type Widget specific event name.
     */
    removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
}
/**
 * Represents the version of the Checkout Widgets to use defaults to (0.1.9-alpha)
 * @property {number} major
 * @property {number | undefined} minor
 * @property {number | undefined} patch
 * @property {'alpha' | undefined} prerelease
 * @property {number | undefined} build
 *
 * @example
 * { major: 0 } - use default version 0.1.9-alpha
 * { major: 1 } - use version 1.x.x, pickup all new minor and patch versions released
 * { major: 1, minor: 1 } - use version 1.1.x, pickup all new patch versions released
 * { major: 1, minor: 2, patch: 3 } - use version 1.2.3 specifically
 */
type SemanticVersion = {
    /** The major version of the widgets, must specify a major version even if it is 0. */
    major: number;
    /** The minor version of the widgets, leaving this blank will use the latest minor based on major */
    minor?: number;
    /** The patch version of the widgets, leaving this blank will use the latest minor based on minor */
    patch?: number;
    /** The prerelease version of the widgets, can only be 'alpha'. Do not use in production. */
    prerelease?: 'alpha';
    /** The build version of the widgets. Do not use in production. */
    build?: number;
};
/**
 * Represents the global configuration options for the Checkout Widgets.
 * @property {WidgetTheme | undefined} theme
 * @property {Environment | undefined} environment
 * @property {SemanticVersion | undefined} version
 * @property {boolean | undefined} isOnRampEnabled
 * @property {boolean | undefined} isSwapEnabled
 * @property {boolean | undefined} isBridgeEnabled
 */
type CheckoutWidgetsConfig = {
    /** The theme of the Checkout Widget (default: "DARK") */
    theme?: WidgetTheme;
    /** The environment configuration (default: "SANDBOX") */
    environment?: Environment;
    /** The version of the checkout widgets js file to use (default: "0.1.x") */
    version?: SemanticVersion;
    /** Enable on-ramp top-up method (default: "true") */
    isOnRampEnabled?: boolean;
    /** Enable swap top-up method (default: "true") */
    isSwapEnabled?: boolean;
    /** Enable bridge top-up method (default: "true") */
    isBridgeEnabled?: boolean;
};

/**
 * Represents the configuration options for instantiating the Checkout Widgets factory.
 * @property {WidgetConfiguration} config - global configuration options for the widgets.
 * @property {SemanticVersion | undefined} version - version of the Checkout widgets bundle (default latest version will be used).
 */
type WidgetsInit = {
    config: WidgetConfiguration;
    version?: SemanticVersion;
};

declare class Checkout {
    private readOnlyProviders;
    readonly config: CheckoutConfiguration;
    readonly fiatRampService: FiatRampService;
    readonly availability: AvailabilityService;
    readonly passport?: Passport;
    /**
     * Constructs a new instance of the CheckoutModule class.
     * @param {CheckoutModuleConfiguration} [config=SANDBOX_CONFIGURATION] - The configuration object for the CheckoutModule.
     */
    constructor(config?: CheckoutModuleConfiguration);
    /**
     * Loads the widgets bundle and initiate the widgets factory.
     * @param {WidgetsInit} init - The initialisation parameters for loading the widgets bundle and applying configuration
     */
    widgets(init: WidgetsInit): Promise<ImmutableCheckoutWidgets.WidgetsFactory>;
    /**
     * Creates a provider using the given parameters.
     * @param {CreateProviderParams} params - The parameters for creating the provider.
     * @returns {Promise<CreateProviderResult>} A promise that resolves to the created provider.
     */
    createProvider(params: CreateProviderParams): Promise<CreateProviderResult>;
    /**
     * Checks if a wallet is connected to the specified provider.
     * @param {CheckConnectionParams} params - The parameters for checking the wallet connection.
     * @returns {Promise<CheckConnectionResult>} - A promise that resolves to the result of the check.
     */
    checkIsWalletConnected(params: CheckConnectionParams): Promise<CheckConnectionResult>;
    /**
     * Connects to a blockchain network using the specified provider.
     * @param {ConnectParams} params - The parameters for connecting to the network.
     * @returns {Promise<ConnectResult>} A promise that resolves to an object containing the provider and network information.
     * @throws {Error} If the provider is not valid or if there is an error connecting to the network.
     */
    connect(params: ConnectParams): Promise<ConnectResult>;
    /**
     * Switches the network for the current wallet provider.
     * @param {SwitchNetworkParams} params - The parameters for switching the network.
     * @returns {Promise<SwitchNetworkResult>} - A promise that resolves to the result of switching the network.
     */
    switchNetwork(params: SwitchNetworkParams): Promise<SwitchNetworkResult>;
    /**
     * Retrieves the balance of a wallet address.
     * @param {GetBalanceParams} params - The parameters for retrieving the balance.
     * @returns {Promise<GetBalanceResult>} - A promise that resolves to the balance result.
     */
    getBalance(params: GetBalanceParams): Promise<GetBalanceResult>;
    /**
     * Retrieves the balances of all tokens for a given wallet address on a specific chain.
     * @param {GetAllBalancesParams} params - The parameters for retrieving the balances.
     * @returns {Promise<GetAllBalancesResult>} - A promise that resolves to the result of retrieving the balances.
     */
    getAllBalances(params: GetAllBalancesParams): Promise<GetAllBalancesResult>;
    /**
     * Retrieves the supported networks based on the provided parameters.
     * @param {GetNetworkAllowListParams} params - The parameters for retrieving the network allow list.
     * @returns {Promise<GetNetworkAllowListResult>} - A promise that resolves to the network allow list result.
     */
    getNetworkAllowList(params: GetNetworkAllowListParams): Promise<GetNetworkAllowListResult>;
    /**
     * Retrieves the supported tokens based on the provided parameters.
     * @param {GetTokenAllowListParams} params - The parameters for retrieving the token allow list.
     * @returns {Promise<GetTokenAllowListResult>} - A promise that resolves to the token allow list result.
     */
    getTokenAllowList(params: GetTokenAllowListParams): Promise<GetTokenAllowListResult>;
    /**
     * Retrieves the default supported wallets based on the provided parameters.
     * @param {GetWalletAllowListParams} params - The parameters for retrieving the wallet allow list.
     * @returns {Promise<GetWalletAllowListResult>} - A promise that resolves to the wallet allow list result.
     */
    getWalletAllowList(params: GetWalletAllowListParams): Promise<GetWalletAllowListResult>;
    /**
     * Sends a transaction using the specified provider and transaction parameters.
     * @param {SendTransactionParams} params - The parameters for sending the transaction.
     * @returns {Promise<SendTransactionResult>} A promise that resolves to the result of the transaction.
     */
    sendTransaction(params: SendTransactionParams): Promise<SendTransactionResult>;
    /**
     * Retrieves network information using the specified provider.
     * @param {GetNetworkParams} params - The parameters for retrieving network information.
     * @returns {Promise<NetworkInfo>} A promise that resolves to the network information.
     */
    getNetworkInfo(params: GetNetworkParams): Promise<NetworkInfo>;
    /**
     * Determines the requirements for performing a buy.
     * @param {BuyParams} params - The parameters for the buy.
    */
    buy(params: BuyParams): Promise<BuyResult>;
    /**
     * Determines the requirements for performing a sell.
     * @param {SellParams} params - The parameters for the sell.
     * Only currently actions the first order in the array until we support batch processing.
     * Only currently actions the first fee in the fees array of each order until we support multiple fees.
    */
    sell(params: SellParams): Promise<SellResult>;
    /**
     * Cancels a sell.
     * @param {CancelParams} params - The parameters for the cancel.
     */
    cancel(params: CancelParams): Promise<CancelResult>;
    /**
     * Determines the transaction requirements to complete a purchase.
     * @params {SmartCheckoutParams} params - The parameters for smart checkout.
     */
    smartCheckout(params: SmartCheckoutParams): Promise<SmartCheckoutResult>;
    /**
     * Checks if the given object is a Web3 provider.
     * @param {Web3Provider} web3Provider - The object to check.
     * @returns {boolean} - True if the object is a Web3 provider, false otherwise.
     */
    static isWeb3Provider(web3Provider: Web3Provider): boolean;
    /**
     * Estimates the gas required for a swap or bridge transaction.
     * @param {GasEstimateParams} params - The parameters for the gas estimation.
     * @returns {Promise<GasEstimateSwapResult | GasEstimateBridgeToL2Result>} - A promise that resolves to the gas estimation result.
     */
    gasEstimate(params: GasEstimateParams): Promise<GasEstimateSwapResult | GasEstimateBridgeToL2Result>;
    /**
     * Creates and returns a URL for the fiat ramp widget.
     * @param {FiatRampParams} params - The parameters for creating the url.
     * @returns {Promise<string>} - A promise that resolves to a string url.
     */
    createFiatRampUrl(params: FiatRampParams): Promise<string>;
    /**
     * Fetches fiat ramp fee estimations.
     * @returns {Promise<OnRampProviderFees>} - A promise that resolves to OnRampProviderFees.
     */
    getExchangeFeeEstimate(): Promise<OnRampProviderFees>;
    /**
     * Fetches Swap widget availability.
     * @returns {Promise<boolean>} - A promise that resolves to a boolean.
     */
    isSwapAvailable(): Promise<boolean>;
}

/**
 * Declares global interfaces and namespaces for the application.
 * @global
 * @namespace ImmutableCheckoutWidgets
 * */
declare global {
    namespace ImmutableCheckoutWidgets {
        class WidgetsFactory implements IWidgetsFactory {
            constructor(sdk: Checkout, config: CheckoutWidgetsConfig);
            create<T extends WidgetType>(type: T, props?: WidgetProperties<T>): Widget<T>;
            updateProvider(provider: Web3Provider): void;
        }
        class Connect<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
        class Bridge<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
        class Wallet<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
        class Swap<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
        class OnRamp<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
        class Sale<T extends WidgetType> implements Widget<T> {
            constructor(sdk: Checkout, props: WidgetProperties<T>);
            mount(id: string, params?: WidgetParameters[T]): void;
            unmount(): void;
            update(props: WidgetProperties<T>): void;
            addListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName, callback: (data: WidgetEventData[T][KEventName]) => void): void;
            removeListener<KEventName extends keyof WidgetEventData[T]>(type: KEventName): void;
        }
    }
}

/**
 * Enum representing different types of errors that can occur during the checkout process.
 */
declare enum CheckoutErrorType {
    WEB3_PROVIDER_ERROR = "WEB3_PROVIDER_ERROR",
    PROVIDER_ERROR = "PROVIDER_ERROR",
    DEFAULT_PROVIDER_ERROR = "DEFAULT_PROVIDER_ERROR",
    CONNECT_PROVIDER_ERROR = "CONNECT_PROVIDER_ERROR",
    GET_BALANCE_ERROR = "GET_BALANCE_ERROR",
    GET_INDEXER_BALANCE_ERROR = "GET_INDEXER_BALANCE_ERROR",
    GET_ERC20_BALANCE_ERROR = "GET_ERC20_BALANCE_ERROR",
    GET_ERC721_BALANCE_ERROR = "GET_ERC721_BALANCE_ERROR",
    GET_NETWORK_INFO_ERROR = "GET_NETWORK_INFO_ERROR",
    METAMASK_PROVIDER_ERROR = "METAMASK_PROVIDER_ERROR",
    CHAIN_NOT_SUPPORTED_ERROR = "CHAIN_NOT_SUPPORTED_ERROR",
    PROVIDER_REQUEST_MISSING_ERROR = "PROVIDER_REQUEST_MISSING_ERROR",
    PROVIDER_REQUEST_FAILED_ERROR = "PROVIDER_REQUEST_FAILED_ERROR",
    USER_REJECTED_REQUEST_ERROR = "USER_REJECTED_REQUEST_ERROR",
    TRANSACTION_FAILED = "TRANSACTION_FAILED",
    INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
    UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT",
    INVALID_GAS_ESTIMATE_TYPE = "INVALID_GAS_ESTIMATE_TYPE",
    UNSUPPORTED_TOKEN_TYPE_ERROR = "UNSUPPORTED_TOKEN_TYPE_ERROR",
    UNSUPPORTED_BALANCE_REQUIREMENT_ERROR = "UNSUPPORTED_BALANCE_REQUIREMENT_ERROR",
    GET_ORDER_LISTING_ERROR = "GET_ORDER_LISTING_ERROR",
    CANCEL_ORDER_LISTING_ERROR = "CANCEL_ORDER_LISTING_ERROR",
    PREPARE_ORDER_LISTING_ERROR = "PREPARE_ORDER_LISTING_ERROR",
    CREATE_ORDER_LISTING_ERROR = "CREATE_ORDER_LISTING_ERROR",
    FULFILL_ORDER_LISTING_ERROR = "FULFILL_ORDER_LISTING_ERROR",
    SWITCH_NETWORK_UNSUPPORTED = "SWITCH_NETWORK_UNSUPPORTED",
    GET_ERC20_ALLOWANCE_ERROR = "GET_ERC20_ALLOWANCE_ERROR",
    GET_ERC721_ALLOWANCE_ERROR = "GET_ERC721_ALLOWANCE_ERROR",
    EXECUTE_APPROVAL_TRANSACTION_ERROR = "EXECUTE_APPROVAL_TRANSACTION_ERROR",
    EXECUTE_FULFILLMENT_TRANSACTION_ERROR = "EXECUTE_FULFILLMENT_TRANSACTION_ERROR",
    SIGN_MESSAGE_ERROR = "SIGN_MESSAGE_ERROR",
    BRIDGE_GAS_ESTIMATE_ERROR = "BRIDGE_GAS_ESTIMATE_ERROR",
    ORDER_FEE_ERROR = "ORDER_FEE_ERROR",
    ITEM_REQUIREMENTS_ERROR = "ITEM_REQUIREMENTS_ERROR",
    API_ERROR = "API_ERROR",
    ORDER_EXPIRED_ERROR = "ORDER_EXPIRED_ERROR",
    WIDGETS_SCRIPT_LOAD_ERROR = "WIDGETS_SCRIPT_LOAD_ERROR"
}
/**
 * Represents an error object with a specific type, optional message, and optional data.
 * @property {CheckoutErrorType} type
 * @property {string | undefined} [message]
 * @property {Object.<string, string> | undefined} [data]
 */
type ErrorType = {
    /** The type of the error. */
    type: CheckoutErrorType;
    /** The error message. */
    message?: string;
    /** Additional data associated with the error. */
    data?: {
        [key: string]: string;
    };
};

/**
 * Base URL for the checkout API based on the environment.
 * @property {string} DEVELOPMENT - The base URL for the development environment.
 * @property {string} SANDBOX - The base URL for the sandbox environment.
 * @property {string} PRODUCTION - The base URL for the production environment.
 */
declare const CHECKOUT_API_BASE_URL: {
    [x: string]: string;
    sandbox: string;
    production: string;
};

export { AllowedNetworkConfig, AvailableRoutingOptions, BalanceDelta, BridgeEventType, BridgeFailed, BridgeFundingStep, BridgeSuccess, BridgeWidgetConfiguration, BridgeWidgetParams, BuyOrder, BuyParams, BuyResult, BuyResultFailed, BuyResultInsufficientFunds, BuyResultSuccess, BuyToken, CHECKOUT_API_BASE_URL, CancelParams, CancelResult, CancelResultFailed, CancelResultSuccess, ChainId, ChainName, CheckConnectionParams, CheckConnectionResult, Checkout, CheckoutBridgeConfiguration, CheckoutConfiguration, CheckoutErrorType, CheckoutModuleConfiguration, CheckoutOnRampConfiguration, CheckoutStatus, CheckoutSwapConfiguration, CheckoutWidgetsConfig, ConnectEventType, ConnectParams, ConnectResult, ConnectTargetLayer, ConnectWidgetConfiguration, ConnectWidgetParams, ConnectionFailed, ConnectionSuccess, CreateProviderParams, CreateProviderResult, DexConfig, ERC20ItemRequirement, ERC721Balance, ERC721ItemRequirement, ErrorType, ExchangeType, Fee, FeePercentage, FeeToken, FiatRampParams, FulfillmentTransaction, FundingItem, FundingRoute, FundingStep, FundingStepType, GasAmount, GasEstimateBridgeToL2Result, GasEstimateParams, GasEstimateSwapResult, GasEstimateTokenConfig, GasEstimateType, GasToken, GasTokenType, GetAllBalancesParams, GetAllBalancesResult, GetBalanceParams, GetBalanceResult, GetNetworkAllowListParams, GetNetworkAllowListResult, GetNetworkParams, GetTokenAllowListParams, GetTokenAllowListResult, GetWalletAllowListParams, GetWalletAllowListResult, IMTBLWidgetEvents, IWidgetsFactory, ItemBalance, ItemType, NativeItemRequirement, NetworkFilter, NetworkFilterTypes, NetworkInfo, NoRouteOptions, NoRoutesFound, OnRampEventType, OnRampFailed, OnRampFundingStep, OnRampProviderFees, OnRampSuccess, OnRampWidgetParams, OnrampWidgetConfiguration, OrchestrationEvent, OrchestrationEventData, OrchestrationEventType, OrderFee, ProviderEvent, ProviderEventType, ProviderUpdated, RemoteConfiguration, RequestBridgeEvent, RequestConnectEvent, RequestOnrampEvent, RequestSwapEvent, RequestWalletEvent, RoutesFound, RoutingOutcome, RoutingOutcomeType, SaleEventType, SaleFailed, SaleItem, SaleSuccess, SaleTransactionSuccess, SaleWidgetConfiguration, SaleWidgetParams, SellOrder, SellParams, SellResult, SellResultFailed, SellResultInsufficientFunds, SellResultSuccess, SellToken, SemanticVersion, SendTransactionParams, SendTransactionResult, SmartCheckoutInsufficient, SmartCheckoutParams, SmartCheckoutResult, SmartCheckoutRouter, SmartCheckoutSufficient, SwapEventType, SwapFailed, SwapFundingStep, SwapRejected, SwapSuccess, SwapWidgetConfiguration, SwapWidgetParams, SwitchNetworkParams, SwitchNetworkResult, TokenAmountEstimate, TokenBalance, TokenFilter, TokenFilterTypes, TokenInfo, TransactionOrGasType, TransactionRequirement, WalletDisconnect, WalletEventType, WalletFilter, WalletFilterTypes, WalletInfo, WalletNetworkSwitch, WalletProviderName, WalletWidgetConfiguration, WalletWidgetParams, Widget, WidgetConfiguration, WidgetConfigurations, WidgetEvent, WidgetEventData, WidgetEventTypes, WidgetParameters, WidgetProperties, WidgetTheme, WidgetType };
