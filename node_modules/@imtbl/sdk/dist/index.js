import globalAxios$1, { isAxiosError as isAxiosError$1, AxiosError as AxiosError$1, HttpStatusCode as HttpStatusCode$2 } from 'axios';
import { ImmutableX, Config, IMXError, createStarkSigner, generateLegacyStarkPrivateKey, TransfersApi, OrdersApi as OrdersApi$1, UsersApi, Contracts, TradesApi, ExchangesApi, WithdrawalsApi, MintsApi, DepositsApi, EncodingApi, TokensApi as TokensApi$1 } from '@imtbl/core-sdk';
import { UserManager, User, InMemoryWebStorage, WebStorageStateStore } from 'oidc-client-ts';
import jwt_decode from 'jwt-decode';
import * as crypto from 'crypto';
import { Magic } from 'magic-sdk';
import { OpenIdExtension } from '@magic-ext/oidc';
import { JsonRpcProvider, Web3Provider } from '@ethersproject/providers';
import { BigNumber as BigNumber$1, ethers, providers, constants as constants$1, ContractFactory, utils as utils$1, Contract as Contract$1 } from 'ethers';
import BN$2 from 'bn.js';
import * as encUtils from 'enc-utils';
import { EventEmitter } from 'events';
import { walletContracts } from '@0xsequence/abi';
import { v1 } from '@0xsequence/core';
import FormData$2 from 'form-data';
import { Seaport as Seaport$1 } from '@opensea/seaport-js';
import { parseUnits } from '@ethersproject/units';
import { BigNumber as BigNumber$2 } from '@ethersproject/bignumber';
import detectEthereumProvider from '@metamask/detect-provider';
import * as Uniswap from '@uniswap/sdk-core';
import { TradeType, Percent } from '@uniswap/sdk-core';
import assert from 'assert';
import { FeeAmount, Route, SwapQuoter, Pool, Trade, toHex as toHex$1, encodeRouteToPath } from '@uniswap/v3-sdk';
import { keccak256 as keccak256$1 } from '@ethersproject/solidity';
import { SwapRouter, PaymentsExtended } from '@uniswap/router-sdk';

var Environment$1;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment$1 || (Environment$1 = {}));
class ImmutableConfiguration {
    environment;
    rateLimitingKey;
    apiKey;
    publishableKey;
    constructor(options) {
        this.environment = options.environment;
    }
}
const API_KEY_PREFIX = 'sk_imapik-';
const PUBLISHABLE_KEY_PREFIX = 'pk_imapik-';
const addApiKeyToAxiosHeader = (apiKey) => {
    if (!apiKey.startsWith(API_KEY_PREFIX)) {
        throw new Error('Invalid API key. Create your api key in Immutable developer hub. https://hub.immutable.com');
    }
    globalAxios$1.defaults.headers.common['x-immutable-api-key'] = apiKey;
};
const addPublishableKeyToAxiosHeader = (publishableKey) => {
    if (!publishableKey.startsWith(PUBLISHABLE_KEY_PREFIX)) {
        throw new Error('Invalid Publishable key. Create your Publishable key in Immutable developer hub.'
            + ' https://hub.immutable.com');
    }
    globalAxios$1.defaults.headers.common['x-immutable-publishable-key'] = publishableKey;
};
const addRateLimitingKeyToAxiosHeader = (rateLimitingKey) => {
    globalAxios$1.defaults.headers.common['x-api-key'] = rateLimitingKey;
};

var config = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get Environment () { return Environment$1; },
    ImmutableConfiguration: ImmutableConfiguration,
    addApiKeyToAxiosHeader: addApiKeyToAxiosHeader,
    addPublishableKeyToAxiosHeader: addPublishableKeyToAxiosHeader,
    addRateLimitingKeyToAxiosHeader: addRateLimitingKeyToAxiosHeader
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$1 = class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH$1 = "https://api.sandbox.immutable.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
let BaseAPI$1 = class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH$1, axios = globalAxios$1) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
let RequiredError$1 = class RequiredError extends Error {
    field;
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL$1 = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists$1 = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError$1(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject$1 = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams$1(urlSearchParams, parameter, key = "") {
    if (parameter == null)
        return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams$1(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams$1(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams$1 = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams$1(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded$1 = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString$1 = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction$1 = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || axios.defaults.baseURL || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
const ActivitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (chainName, activityId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getActivity', 'chainName', chainName);
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists$1('getActivity', 'activityId', activityId);
            const localVarPath = `/v1/chains/{chain_name}/activities/{activity_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"activity_id"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities: async (chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listActivities', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/activities`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }
            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {string} chainName The name of chain
         * @param {string} fromUpdatedAt From indexed at including given date
         * @param {string} [toUpdatedAt] To indexed at including given date
         * @param {string} [contractAddress] The contract address of the collection
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityHistory: async (chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listActivityHistory', 'chainName', chainName);
            // verify required parameter 'fromUpdatedAt' is not null or undefined
            assertParamExists$1('listActivityHistory', 'fromUpdatedAt', fromUpdatedAt);
            const localVarPath = `/v1/chains/{chain_name}/activity-history`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = (toUpdatedAt instanceof Date) ?
                    toUpdatedAt.toISOString() :
                    toUpdatedAt;
            }
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
const ActivitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(chainName, activityId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(chainName, activityId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, transactionHash, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {string} chainName The name of chain
         * @param {string} fromUpdatedAt From indexed at including given date
         * @param {string} [toUpdatedAt] To indexed at including given date
         * @param {string} [contractAddress] The contract address of the collection
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivityHistory(chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivityHistory(chainName, fromUpdatedAt, toUpdatedAt, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
const ActivitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActivitiesApiFp(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(requestParameters, options) {
            return localVarFp.getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities(requestParameters, options) {
            return localVarFp.listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List activities sorted by updated_at timestamp ascending, useful for time based data replication
         * @summary List history of activities
         * @param {ActivitiesApiListActivityHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityHistory(requestParameters, options) {
            return localVarFp.listActivityHistory(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.toUpdatedAt, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI$1 {
    /**
     * Get a single activity by ID
     * @summary Get a single activity by ID
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivity(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all activities
     * @summary List all activities
     * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivities(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List activities sorted by updated_at timestamp ascending, useful for time based data replication
     * @summary List history of activities
     * @param {ActivitiesApiListActivityHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivityHistory(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivityHistory(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.toUpdatedAt, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ChainsApi - axios parameter creator
 * @export
 */
const ChainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains: async (pageCursor, pageSize, options = {}) => {
            const localVarPath = `/v1/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainsApi - functional programming interface
 * @export
 */
const ChainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChains(pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChains(pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ChainsApi - factory interface
 * @export
 */
const ChainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChainsApiFp(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains(requestParameters = {}, options) {
            return localVarFp.listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
class ChainsApi extends BaseAPI$1 {
    /**
     * List supported chains
     * @summary List supported chains
     * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainsApi
     */
    listChains(requestParameters = {}, options) {
        return ChainsApiFp(this.configuration).listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
const CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getCollection', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getCollection', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {Array<string>} [contractAddress] List of contract addresses to filter by
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollections', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner: async (accountAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/collections`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata: async (contractAddress, chainName, refreshCollectionMetadataRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'chainName', chainName);
            // verify required parameter 'refreshCollectionMetadataRequest' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'refreshCollectionMetadataRequest', refreshCollectionMetadataRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshCollectionMetadataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
const CollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(contractAddress, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {Array<string>} [contractAddress] List of contract addresses to filter by
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
const CollectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CollectionsApiFp(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(requestParameters, options) {
            return localVarFp.getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(requestParameters, options) {
            return localVarFp.listCollections(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner(requestParameters, options) {
            return localVarFp.listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata(requestParameters, options) {
            return localVarFp.refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends BaseAPI$1 {
    /**
     * Get collection by contract address
     * @summary Get collection by contract address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters, options) {
        return CollectionsApiFp(this.configuration).getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all collections
     * @summary List all collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollections(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List collections by NFT owner account address
     * @summary List collections by NFT owner
     * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionsByNFTOwner(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh collection metadata
     * @summary Refresh collection metadata
     * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    refreshCollectionMetadata(requestParameters, options) {
        return CollectionsApiFp(this.configuration).refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MetadataApi - axios parameter creator
 * @export
 */
const MetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (chainName, contractAddress, metadataId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists$1('getMetadata', 'metadataId', metadataId);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/{metadata_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadata: async (chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listMetadata', 'contractAddress', contractAddress);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadataForChain: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listMetadataForChain', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID: async (chainName, contractAddress, refreshMetadataByIDRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'contractAddress', contractAddress);
            // verify required parameter 'refreshMetadataByIDRequest' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'refreshMetadataByIDRequest', refreshMetadataByIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/refresh-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshMetadataByIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {RefreshNFTMetadataByTokenIDRequest} refreshNFTMetadataByTokenIDRequest the request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadataByTokenID: async (contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshNFTMetadataByTokenID', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshNFTMetadataByTokenID', 'chainName', chainName);
            // verify required parameter 'refreshNFTMetadataByTokenIDRequest' is not null or undefined
            assertParamExists$1('refreshNFTMetadataByTokenID', 'refreshNFTMetadataByTokenIDRequest', refreshNFTMetadataByTokenIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "x-immutable-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshNFTMetadataByTokenIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetadataApi - functional programming interface
 * @export
 */
const MetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration);
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(chainName, contractAddress, metadataId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(chainName, contractAddress, metadataId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetadata(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetadata(chainName, contractAddress, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetadataForChain(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetadataForChain(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {RefreshNFTMetadataByTokenIDRequest} refreshNFTMetadataByTokenIDRequest the request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshNFTMetadataByTokenID(contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshNFTMetadataByTokenID(contractAddress, chainName, refreshNFTMetadataByTokenIDRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * MetadataApi - factory interface
 * @export
 */
const MetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetadataApiFp(configuration);
    return {
        /**
         * Get metadata by ID
         * @summary Get metadata by ID
         * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(requestParameters, options) {
            return localVarFp.getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of metadata from the given contract
         * @summary Get a list of metadata from the given contract
         * @param {MetadataApiListMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadata(requestParameters, options) {
            return localVarFp.listMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of metadata from the given chain
         * @summary Get a list of metadata from the given chain
         * @param {MetadataApiListMetadataForChainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetadataForChain(requestParameters, options) {
            return localVarFp.listMetadataForChain(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh stacked metadata
         * @summary Refresh stacked metadata
         * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID(requestParameters, options) {
            return localVarFp.refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh NFT metadata
         * @summary Refresh NFT metadata
         * @param {MetadataApiRefreshNFTMetadataByTokenIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadataByTokenID(requestParameters, options) {
            return localVarFp.refreshNFTMetadataByTokenID(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshNFTMetadataByTokenIDRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
class MetadataApi extends BaseAPI$1 {
    /**
     * Get metadata by ID
     * @summary Get metadata by ID
     * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of metadata from the given contract
     * @summary Get a list of metadata from the given contract
     * @param {MetadataApiListMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    listMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).listMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of metadata from the given chain
     * @summary Get a list of metadata from the given chain
     * @param {MetadataApiListMetadataForChainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    listMetadataForChain(requestParameters, options) {
        return MetadataApiFp(this.configuration).listMetadataForChain(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh stacked metadata
     * @summary Refresh stacked metadata
     * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshMetadataByID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh NFT metadata
     * @summary Refresh NFT metadata
     * @param {MetadataApiRefreshNFTMetadataByTokenIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshNFTMetadataByTokenID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshNFTMetadataByTokenID(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshNFTMetadataByTokenIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftOwnersApi - axios parameter creator
 * @export
 */
const NftOwnersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTOwners: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listAllNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/nft-owners`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners: async (contractAddress, tokenId, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTOwners', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('listNFTOwners', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnersByContractAddress: async (contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listOwnersByContractAddress', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listOwnersByContractAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftOwnersApi - functional programming interface
 * @export
 */
const NftOwnersApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftOwnersApiAxiosParamCreator(configuration);
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllNFTOwners(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllNFTOwners(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOwnersByContractAddress(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOwnersByContractAddress(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftOwnersApi - factory interface
 * @export
 */
const NftOwnersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftOwnersApiFp(configuration);
    return {
        /**
         * List all NFT owners on a chain
         * @summary List all NFT owners
         * @param {NftOwnersApiListAllNFTOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTOwners(requestParameters, options) {
            return localVarFp.listAllNFTOwners(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners(requestParameters, options) {
            return localVarFp.listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List owners by contract address
         * @summary List owners by contract address
         * @param {NftOwnersApiListOwnersByContractAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnersByContractAddress(requestParameters, options) {
            return localVarFp.listOwnersByContractAddress(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftOwnersApi - object-oriented interface
 * @export
 * @class NftOwnersApi
 * @extends {BaseAPI}
 */
class NftOwnersApi extends BaseAPI$1 {
    /**
     * List all NFT owners on a chain
     * @summary List all NFT owners
     * @param {NftOwnersApiListAllNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listAllNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listAllNFTOwners(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFT owners by token ID
     * @summary List NFT owners by token ID
     * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List owners by contract address
     * @summary List owners by contract address
     * @param {NftOwnersApiListOwnersByContractAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listOwnersByContractAddress(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listOwnersByContractAddress(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftsApi - axios parameter creator
 * @export
 */
const NftsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (contractAddress, tokenId, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getNFT', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('getNFT', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getNFT', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTs: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listAllNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/nfts`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs: async (contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTs', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress: async (accountAddress, chainName, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/nfts`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftsApi - functional programming interface
 * @export
 */
const NftsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(contractAddress, tokenId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(contractAddress, tokenId, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllNFTs(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllNFTs(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTs(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTs(contractAddress, chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftsApi - factory interface
 * @export
 */
const NftsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftsApiFp(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT(requestParameters, options) {
            return localVarFp.getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all NFTs on a chain
         * @summary List all NFTs
         * @param {NftsApiListAllNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllNFTs(requestParameters, options) {
            return localVarFp.listAllNFTs(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs(requestParameters, options) {
            return localVarFp.listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress(requestParameters, options) {
            return localVarFp.listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftsApi - object-oriented interface
 * @export
 * @class NftsApi
 * @extends {BaseAPI}
 */
class NftsApi extends BaseAPI$1 {
    /**
     * Get NFT by token ID
     * @summary Get NFT by token ID
     * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    getNFT(requestParameters, options) {
        return NftsApiFp(this.configuration).getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all NFTs on a chain
     * @summary List all NFTs
     * @param {NftsApiListAllNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listAllNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listAllNFTs(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by contract address
     * @summary List NFTs by contract address
     * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by account address
     * @summary List NFTs by account address
     * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTsByAccountAddress(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {string} chainName
         * @param {CancelOrdersRequestBody} cancelOrdersRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders: async (chainName, cancelOrdersRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('cancelOrders', 'chainName', chainName);
            // verify required parameter 'cancelOrdersRequestBody' is not null or undefined
            assertParamExists$1('cancelOrders', 'cancelOrdersRequestBody', cancelOrdersRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/cancel`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(cancelOrdersRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (chainName, createListingRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('createListing', 'chainName', chainName);
            // verify required parameter 'createListingRequestBody' is not null or undefined
            assertParamExists$1('createListing', 'createListingRequestBody', createListingRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createListingRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData: async (chainName, fulfillmentDataRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('fulfillmentData', 'chainName', chainName);
            // verify required parameter 'fulfillmentDataRequest' is not null or undefined
            assertParamExists$1('fulfillmentData', 'fulfillmentDataRequest', fulfillmentDataRequest);
            const localVarPath = `/v1/chains/{chain_name}/orders/fulfillment-data`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(fulfillmentDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing: async (chainName, listingId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getListing', 'chainName', chainName);
            // verify required parameter 'listingId' is not null or undefined
            assertParamExists$1('getListing', 'listingId', listingId);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings/{listing_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"listing_id"}}`, encodeURIComponent(String(listingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (chainName, tradeId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getTrade', 'chainName', chainName);
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists$1('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/chains/{chain_name}/trades/{trade_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatusName} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [accountAddress] The account address of the user who created the listing
         * @param {string} [sellItemMetadataId] The metadata_id of the sell item
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {string} [fromUpdatedAt] From updated at including given date
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {ListListingsSortByEnum} [sortBy] Order field to sort by
         * @param {ListListingsSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings: async (chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listListings', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sellItemContractAddress !== undefined) {
                localVarQueryParameter['sell_item_contract_address'] = sellItemContractAddress;
            }
            if (buyItemContractAddress !== undefined) {
                localVarQueryParameter['buy_item_contract_address'] = buyItemContractAddress;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (sellItemMetadataId !== undefined) {
                localVarQueryParameter['sell_item_metadata_id'] = sellItemMetadataId;
            }
            if (sellItemTokenId !== undefined) {
                localVarQueryParameter['sell_item_token_id'] = sellItemTokenId;
            }
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {ListTradesSortByEnum} [sortBy] Trade field to sort by
         * @param {ListTradesSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listTrades', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/trades`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (fromIndexedAt !== undefined) {
                localVarQueryParameter['from_indexed_at'] = (fromIndexedAt instanceof Date) ?
                    fromIndexedAt.toISOString() :
                    fromIndexedAt;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {string} chainName
         * @param {CancelOrdersRequestBody} cancelOrdersRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrders(chainName, cancelOrdersRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrders(chainName, cancelOrdersRequestBody, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(chainName, createListingRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(chainName, createListingRequestBody, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillmentData(chainName, fulfillmentDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillmentData(chainName, fulfillmentDataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListing(chainName, listingId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListing(chainName, listingId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(chainName, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(chainName, tradeId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatusName} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [accountAddress] The account address of the user who created the listing
         * @param {string} [sellItemMetadataId] The metadata_id of the sell item
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {string} [fromUpdatedAt] From updated at including given date
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {ListListingsSortByEnum} [sortBy] Order field to sort by
         * @param {ListListingsSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {ListTradesSortByEnum} [sortBy] Trade field to sort by
         * @param {ListTradesSortDirectionEnum} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         * Cancel one or more orders
         * @summary Cancel one or more orders
         * @param {OrdersApiCancelOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders(requestParameters, options) {
            return localVarFp.cancelOrders(requestParameters.chainName, requestParameters.cancelOrdersRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a listing
         * @summary Create a listing
         * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing(requestParameters, options) {
            return localVarFp.createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData(requestParameters, options) {
            return localVarFp.fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing(requestParameters, options) {
            return localVarFp.getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(requestParameters, options) {
            return localVarFp.getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings(requestParameters, options) {
            return localVarFp.listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.accountAddress, requestParameters.sellItemMetadataId, requestParameters.sellItemTokenId, requestParameters.fromUpdatedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(requestParameters, options) {
            return localVarFp.listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.fromIndexedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends BaseAPI$1 {
    /**
     * Cancel one or more orders
     * @summary Cancel one or more orders
     * @param {OrdersApiCancelOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    cancelOrders(requestParameters, options) {
        return OrdersApiFp(this.configuration).cancelOrders(requestParameters.chainName, requestParameters.cancelOrdersRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a listing
     * @summary Create a listing
     * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @summary Retrieve fulfillment data for orders
     * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    fulfillmentData(requestParameters, options) {
        return OrdersApiFp(this.configuration).fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single listing by ID
     * @summary Get a single listing by ID
     * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single trade by ID
     * @summary Get a single trade by ID
     * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getTrade(requestParameters, options) {
        return OrdersApiFp(this.configuration).getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all listings
     * @summary List all listings
     * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listListings(requestParameters, options) {
        return OrdersApiFp(this.configuration).listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.accountAddress, requestParameters.sellItemMetadataId, requestParameters.sellItemTokenId, requestParameters.fromUpdatedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all trades
     * @summary List all trades
     * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listTrades(requestParameters, options) {
        return OrdersApiFp(this.configuration).listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.fromIndexedAt, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
const ListListingsSortByEnum$1 = {
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at',
    BuyItemAmount: 'buy_item_amount'
};
/**
 * @export
 */
const ListListingsSortDirectionEnum$1 = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * @export
 */
const ListTradesSortByEnum$1 = {
    IndexedAt: 'indexed_at'
};
/**
 * @export
 */
const ListTradesSortDirectionEnum$1 = {
    Asc: 'asc',
    Desc: 'desc'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * PassportApi - axios parameter creator
 * @export
 */
const PassportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {string} chainName
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress: async (chainName, createCounterfactualAddressRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('createCounterfactualAddress', 'chainName', chainName);
            // verify required parameter 'createCounterfactualAddressRequest' is not null or undefined
            assertParamExists$1('createCounterfactualAddress', 'createCounterfactualAddressRequest', createCounterfactualAddressRequest);
            const localVarPath = `/v1/chains/{chain_name}/passport/counterfactual-address`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createCounterfactualAddressRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequestDeprecated} createCounterfactualAddressRequestDeprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddressDeprecated: async (createCounterfactualAddressRequestDeprecated, options = {}) => {
            // verify required parameter 'createCounterfactualAddressRequestDeprecated' is not null or undefined
            assertParamExists$1('createCounterfactualAddressDeprecated', 'createCounterfactualAddressRequestDeprecated', createCounterfactualAddressRequestDeprecated);
            const localVarPath = `/passport-mr/v1/counterfactual-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createCounterfactualAddressRequestDeprecated, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {string} chainName
         * @param {string} contractAddress contract address
         * @param {string} methodId method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAbi: async (chainName, contractAddress, methodId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getContractAbi', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getContractAbi', 'contractAddress', contractAddress);
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists$1('getContractAbi', 'methodId', methodId);
            const localVarPath = `/v1/chains/{chain_name}/passport/transaction-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (methodId !== undefined) {
                localVarQueryParameter['method_id'] = methodId;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {string} chainName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses: async (userId, chainName, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists$1('getLinkedAddresses', 'userId', userId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getLinkedAddresses', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/passport/users/{user_id}/linked-addresses`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddressesDeprecated: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists$1('getLinkedAddressesDeprecated', 'userId', userId);
            const localVarPath = `/passport-mr/v1/users/{userId}/linked-addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassportApi - functional programming interface
 * @export
 */
const PassportApiFp = function (configuration) {
    const localVarAxiosParamCreator = PassportApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {string} chainName
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddress(chainName, createCounterfactualAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddress(chainName, createCounterfactualAddressRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequestDeprecated} createCounterfactualAddressRequestDeprecated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddressDeprecated(createCounterfactualAddressRequestDeprecated, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddressDeprecated(createCounterfactualAddressRequestDeprecated, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {string} chainName
         * @param {string} contractAddress contract address
         * @param {string} methodId method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractAbi(chainName, contractAddress, methodId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractAbi(chainName, contractAddress, methodId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {string} chainName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddresses(userId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddresses(userId, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddressesDeprecated(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddressesDeprecated(userId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * PassportApi - factory interface
 * @export
 */
const PassportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PassportApiFp(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress(requestParameters, options) {
            return localVarFp.createCounterfactualAddress(requestParameters.chainName, requestParameters.createCounterfactualAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {PassportApiCreateCounterfactualAddressDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddressDeprecated(requestParameters, options) {
            return localVarFp.createCounterfactualAddressDeprecated(requestParameters.createCounterfactualAddressRequestDeprecated, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a contract abi by contract address and method id
         * @summary Get a contract abi
         * @param {PassportApiGetContractAbiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAbi(requestParameters, options) {
            return localVarFp.getContractAbi(requestParameters.chainName, requestParameters.contractAddress, requestParameters.methodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses(requestParameters, options) {
            return localVarFp.getLinkedAddresses(requestParameters.userId, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {PassportApiGetLinkedAddressesDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddressesDeprecated(requestParameters, options) {
            return localVarFp.getLinkedAddressesDeprecated(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PassportApi - object-oriented interface
 * @export
 * @class PassportApi
 * @extends {BaseAPI}
 */
class PassportApi extends BaseAPI$1 {
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddress(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddress(requestParameters.chainName, requestParameters.createCounterfactualAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddressDeprecated(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddressDeprecated(requestParameters.createCounterfactualAddressRequestDeprecated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a contract abi by contract address and method id
     * @summary Get a contract abi
     * @param {PassportApiGetContractAbiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getContractAbi(requestParameters, options) {
        return PassportApiFp(this.configuration).getContractAbi(requestParameters.chainName, requestParameters.contractAddress, requestParameters.methodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddresses(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddresses(requestParameters.userId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddressesDeprecated(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddressesDeprecated(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getERC20Token', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getERC20Token', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens: async (chainName, fromUpdatedAt, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listERC20Tokens', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = (fromUpdatedAt instanceof Date) ?
                    fromUpdatedAt.toISOString() :
                    fromUpdatedAt;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getERC20Token(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getERC20Token(contractAddress, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [fromUpdatedAt] Datetime to use as the oldest updated timestamp
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listERC20Tokens(chainName, fromUpdatedAt, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listERC20Tokens(chainName, fromUpdatedAt, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TokensApiFp(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token(requestParameters, options) {
            return localVarFp.getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens(requestParameters, options) {
            return localVarFp.listERC20Tokens(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends BaseAPI$1 {
    /**
     * Get single ERC20 token
     * @summary Get single ERC20 token
     * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getERC20Token(requestParameters, options) {
        return TokensApiFp(this.configuration).getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List ERC20 tokens
     * @summary List ERC20 tokens
     * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listERC20Tokens(requestParameters, options) {
        return TokensApiFp(this.configuration).listERC20Tokens(requestParameters.chainName, requestParameters.fromUpdatedAt, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$2 = class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError400AllOfCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError401AllOfCodeEnum = {
    UnauthorisedRequest: 'UNAUTHORISED_REQUEST'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError403AllOfCodeEnum = {
    AuthenticationError: 'AUTHENTICATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError404AllOfCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError429AllOfCodeEnum = {
    TooManyRequestsError: 'TOO_MANY_REQUESTS_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError500AllOfCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError501AllOfCodeEnum = {
    NotImplementedError: 'NOT_IMPLEMENTED_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ActiveOrderStatusNameEnum = {
    Active: 'ACTIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The activity type
 * @export
 * @enum {string}
 */
const ActivityType = {
    Mint: 'mint',
    Burn: 'burn',
    Transfer: 'transfer',
    Sale: 'sale',
    Deposit: 'deposit',
    Withdrawal: 'withdrawal'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const CancelledOrderStatusNameEnum = {
    Cancelled: 'CANCELLED'
};
const CancelledOrderStatusCancellationTypeEnum = {
    OnChain: 'ON_CHAIN',
    OffChain: 'OFF_CHAIN'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The collection contract type
 * @export
 * @enum {string}
 */
const CollectionContractType = {
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC1155ItemTypeEnum = {
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC20ItemTypeEnum = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC721ItemTypeEnum = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ExpiredOrderStatusNameEnum = {
    Expired: 'EXPIRED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FailedOrderCancellationReasonCodeEnum = {
    Filled: 'FILLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FeeTypeEnum = {
    Royalty: 'ROYALTY',
    MakerEcosystem: 'MAKER_ECOSYSTEM',
    TakerEcosystem: 'TAKER_ECOSYSTEM',
    Protocol: 'PROTOCOL'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FilledOrderStatusNameEnum = {
    Filled: 'FILLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const GetContractAbiResTransactionTypeEnum = {
    Erc20Approve: 'ERC20_APPROVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const InactiveOrderStatusNameEnum = {
    Inactive: 'INACTIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The status of the mint request
 * @export
 * @enum {string}
 */
const MintRequestStatus = {
    Pending: 'pending',
    Succeeded: 'succeeded',
    Failed: 'failed'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for an NFT
 * @export
 * @enum {string}
 */
const NFTContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const NativeItemTypeEnum = {
    Native: 'NATIVE',
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const OrderTypeEnum = {
    Listing: 'LISTING'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The Order status
 * @export
 * @enum {string}
 */
const OrderStatusName$1 = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Filled: 'FILLED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PendingOrderStatusNameEnum = {
    Pending: 'PENDING'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProtocolDataOrderTypeEnum = {
    FullRestricted: 'FULL_RESTRICTED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SaleFeeTypeEnum = {
    Royalty: 'ROYALTY'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for a token
 * @export
 * @enum {string}
 */
const TokenContractType = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError400AllOfCodeEnum: APIError400AllOfCodeEnum,
    APIError401AllOfCodeEnum: APIError401AllOfCodeEnum,
    APIError403AllOfCodeEnum: APIError403AllOfCodeEnum,
    APIError404AllOfCodeEnum: APIError404AllOfCodeEnum,
    APIError429AllOfCodeEnum: APIError429AllOfCodeEnum,
    APIError500AllOfCodeEnum: APIError500AllOfCodeEnum,
    APIError501AllOfCodeEnum: APIError501AllOfCodeEnum,
    ActiveOrderStatusNameEnum: ActiveOrderStatusNameEnum,
    ActivitiesApi: ActivitiesApi,
    ActivitiesApiAxiosParamCreator: ActivitiesApiAxiosParamCreator,
    ActivitiesApiFactory: ActivitiesApiFactory,
    ActivitiesApiFp: ActivitiesApiFp,
    ActivityType: ActivityType,
    CancelledOrderStatusCancellationTypeEnum: CancelledOrderStatusCancellationTypeEnum,
    CancelledOrderStatusNameEnum: CancelledOrderStatusNameEnum,
    ChainsApi: ChainsApi,
    ChainsApiAxiosParamCreator: ChainsApiAxiosParamCreator,
    ChainsApiFactory: ChainsApiFactory,
    ChainsApiFp: ChainsApiFp,
    CollectionContractType: CollectionContractType,
    CollectionsApi: CollectionsApi,
    CollectionsApiAxiosParamCreator: CollectionsApiAxiosParamCreator,
    CollectionsApiFactory: CollectionsApiFactory,
    CollectionsApiFp: CollectionsApiFp,
    Configuration: Configuration$2,
    ERC1155ItemTypeEnum: ERC1155ItemTypeEnum,
    ERC20ItemTypeEnum: ERC20ItemTypeEnum,
    ERC721ItemTypeEnum: ERC721ItemTypeEnum,
    ExpiredOrderStatusNameEnum: ExpiredOrderStatusNameEnum,
    FailedOrderCancellationReasonCodeEnum: FailedOrderCancellationReasonCodeEnum,
    FeeTypeEnum: FeeTypeEnum,
    FilledOrderStatusNameEnum: FilledOrderStatusNameEnum,
    GetContractAbiResTransactionTypeEnum: GetContractAbiResTransactionTypeEnum,
    InactiveOrderStatusNameEnum: InactiveOrderStatusNameEnum,
    ListListingsSortByEnum: ListListingsSortByEnum$1,
    ListListingsSortDirectionEnum: ListListingsSortDirectionEnum$1,
    ListTradesSortByEnum: ListTradesSortByEnum$1,
    ListTradesSortDirectionEnum: ListTradesSortDirectionEnum$1,
    MetadataApi: MetadataApi,
    MetadataApiAxiosParamCreator: MetadataApiAxiosParamCreator,
    MetadataApiFactory: MetadataApiFactory,
    MetadataApiFp: MetadataApiFp,
    MintRequestStatus: MintRequestStatus,
    NFTContractType: NFTContractType,
    NativeItemTypeEnum: NativeItemTypeEnum,
    NftOwnersApi: NftOwnersApi,
    NftOwnersApiAxiosParamCreator: NftOwnersApiAxiosParamCreator,
    NftOwnersApiFactory: NftOwnersApiFactory,
    NftOwnersApiFp: NftOwnersApiFp,
    NftsApi: NftsApi,
    NftsApiAxiosParamCreator: NftsApiAxiosParamCreator,
    NftsApiFactory: NftsApiFactory,
    NftsApiFp: NftsApiFp,
    OrderStatusName: OrderStatusName$1,
    OrderTypeEnum: OrderTypeEnum,
    OrdersApi: OrdersApi,
    OrdersApiAxiosParamCreator: OrdersApiAxiosParamCreator,
    OrdersApiFactory: OrdersApiFactory,
    OrdersApiFp: OrdersApiFp,
    PassportApi: PassportApi,
    PassportApiAxiosParamCreator: PassportApiAxiosParamCreator,
    PassportApiFactory: PassportApiFactory,
    PassportApiFp: PassportApiFp,
    PendingOrderStatusNameEnum: PendingOrderStatusNameEnum,
    ProtocolDataOrderTypeEnum: ProtocolDataOrderTypeEnum,
    SaleFeeTypeEnum: SaleFeeTypeEnum,
    TokenContractType: TokenContractType,
    TokensApi: TokensApi,
    TokensApiAxiosParamCreator: TokensApiAxiosParamCreator,
    TokensApiFactory: TokensApiFactory,
    TokensApiFp: TokensApiFp
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var activitiesApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActivityType: ActivityType
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var chainsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var collectionsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var metadataApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var nftOwnersApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var nftsApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var tokensApiTypes = /*#__PURE__*/Object.freeze({
    __proto__: null
});

class MultiRollupApiClients {
    config;
    activitiesApi;
    chainsApi;
    collectionApi;
    nftOwnersApi;
    nftsApi;
    ordersApi;
    passportApi;
    constructor(config) {
        this.config = config;
        this.activitiesApi = new ActivitiesApi(config.indexer);
        this.chainsApi = new ChainsApi(config.indexer);
        this.collectionApi = new CollectionsApi(config.indexer);
        this.nftOwnersApi = new NftOwnersApi(config.indexer);
        this.nftsApi = new NftsApi(config.indexer);
        this.ordersApi = new OrdersApi(config.orderBook);
        this.passportApi = new PassportApi(config.passport);
    }
}

// eslint-disable-next-line @typescript-eslint/naming-convention
const defaultHeaders$1 = { 'x-sdk-version': 'ts-immutable-sdk-0.35.8' };
const createConfig = ({ basePath, headers, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const composedHeaders = { ...defaultHeaders$1, ...(headers || {}) };
    const apiConfigOptions = {
        basePath,
        baseOptions: { headers: composedHeaders },
    };
    return new Configuration$1(apiConfigOptions);
};
/**
 * Creates a Configuration for the specified environment
 * @returns an MultiRollupAPIConfiguration
 */
const multiRollupConfig = {
    getProduction: () => ({
        indexer: createConfig({
            basePath: 'https://indexer-mr.imtbl.com',
        }),
        orderBook: createConfig({
            basePath: 'https://order-book-mr.imtbl.com',
        }),
        passport: createConfig({
            basePath: 'https://api.immutable.com',
        }),
    }),
    getSandbox: () => ({
        indexer: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        orderBook: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        passport: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
    }),
};

/**
 * Custom Error class that is returned from the API when a request fails
 */
class APIError extends Error {
    code;
    details;
    link;
    traceId;
    constructor({ message, code, details, link, trace_id: traceId, }) {
        super(message);
        this.code = code;
        this.details = details;
        this.link = link;
        this.traceId = traceId;
    }
}

/* eslint-disable implicit-arrow-linebreak */
const defaultHeaders = {
    sdkVersion: 'ts-immutable-sdk-multi-rollup-api-client-0.35.8',
};
/**
 * createAPIConfiguration to create a custom Configuration
 * other than the production and sandbox defined below.
 */
const createAPIConfiguration = ({ baseConfig, basePath, headers: baseHeaders, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const headers = { ...(baseHeaders || {}), ...defaultHeaders };
    const configParams = {
        ...baseConfig,
        basePath,
        baseOptions: { headers },
    };
    return new index.Configuration(configParams);
};
class BlockchainDataConfiguration {
    apiConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.apiConfig = createAPIConfiguration(overrides);
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.sandbox.immutable.com',
                        baseConfig,
                    });
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.immutable.com',
                        baseConfig,
                    });
                    break;
                }
                default: {
                    this.apiConfig = createAPIConfiguration({
                        basePath: 'https://api.sandbox.immutable.com',
                        baseConfig,
                    });
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/naming-convention */
/**
 * [Formats an error in the APIError shape](https://axios-http.com/docs/handling_errors)
 * @param error - The Error object thrown by the request
 * @returns APIError
 */
function formatError(error) {
    if (globalAxios$1.isAxiosError(error) && error.response) {
        const apiError = error.response.data;
        if (apiError.code && apiError.message) {
            return new APIError({
                code: apiError.code,
                message: apiError.message,
                details: apiError.details || null,
                link: apiError.link || '',
                trace_id: apiError.trace_id || '',
            });
        }
        return new APIError({
            code: error.code ?? error.response?.status.toString() ?? 'unknown_error_code',
            message: String(error),
            details: null,
            link: '',
            trace_id: '',
        });
    }
    return new APIError({
        code: 'unknown_error_code',
        message: String(error),
        details: null,
        link: '',
        trace_id: '',
    });
}

class BlockchainData {
    config;
    activities;
    chains;
    collections;
    nfts;
    nftOwners;
    tokens;
    metadata;
    constructor(moduleConfig) {
        this.config = new BlockchainDataConfiguration(moduleConfig);
        this.activities = new index.ActivitiesApi(this.config.apiConfig);
        this.chains = new index.ChainsApi(this.config.apiConfig);
        this.collections = new index.CollectionsApi(this.config.apiConfig);
        this.nfts = new index.NftsApi(this.config.apiConfig);
        this.nftOwners = new index.NftOwnersApi(this.config.apiConfig);
        this.tokens = new index.TokensApi(this.config.apiConfig);
        this.metadata = new index.MetadataApi(this.config.apiConfig);
    }
    /**
     * List all activities
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivities(request) {
        return await this.activities
            .listActivities(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List activities sorted by updated_at timestamp ascending, useful for time based data replication
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivityHistory(request) {
        return await this.activities
            .listActivityHistory(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a single activity by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single activity
     * @throws {@link index.APIError}
     */
    async getActivity(request) {
        return await this.activities
            .getActivity(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List supported chains
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of supported chains
     * @throws {@link index.APIError}
     */
    async listChains(request) {
        return await this.chains
            .listChains(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List all collections
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollections(request) {
        return await this.collections
            .listCollections(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List collections by NFT owner
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollectionsByNFTOwner(request) {
        return await this.collections
            .listCollectionsByNFTOwner(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a collection by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single collection
     * @throws {@link index.APIError}
     */
    async getCollection(request) {
        return await this.collections
            .getCollection(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get NFT by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single NFT
     * @throws {@link index.APIError}
     */
    async getNFT(request) {
        return await this.nfts
            .getNFT(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTs(request) {
        return await this.nfts
            .listNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by account address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTsByAccountAddress(request) {
        return await this.nfts
            .listNFTsByAccountAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List All NFTs on a chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listAllNFTs(request) {
        return await this.nfts
            .listAllNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwners(request) {
        return await this.nftOwners
            .listNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwnersByContractAddress(request) {
        return await this.nftOwners
            .listOwnersByContractAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List All NFT owners on a chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listAllNFTOwners(request) {
        return await this.nftOwners
            .listAllNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List ERC20 Token contracts
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async listTokens(request) {
        return await this.tokens
            .listERC20Tokens(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get details for an ERC20 Token by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async getToken(request) {
        return await this.tokens
            .getERC20Token(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get metadata by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single Metadata
     * @throws {@link index.APIError}
     */
    async getMetadata(request) {
        return await this.metadata
            .getMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT Metadata by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of Metadata
     * @throws {@link index.APIError}
     */
    async listNFTMetadataByContractAddress(request) {
        return await this.metadata
            .listMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT Metadata by chain
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of Metadata
     * @throws {@link index.APIError}
     */
    async listNFTMetadataByChain(request) {
        return await this.metadata
            .listMetadataForChain(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh collection metadata
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated collection
     * @throws {@link index.APIError}
     */
    async refreshCollectionMetadata(request) {
        return await this.collections
            .refreshCollectionMetadata(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh metadata for specific NFTs
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the remaining rate limits
     * @throws {@link index.APIError}
     */
    async refreshNFTMetadata(request) {
        return await this.metadata
            .refreshNFTMetadataByTokenID(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Refresh metadata by ID. This will refresh metadata for all NFTs that reference the given metadata ID.
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the remaining rate limits
     * @throws {@link index.APIError}
     */
    async refreshStackedMetadata(request) {
        return await this.metadata
            .refreshMetadataByID(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
}

var blockchain_data = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError: APIError,
    ActivitiesTypes: activitiesApiTypes,
    BlockchainData: BlockchainData,
    ChainsTypes: chainsApiTypes,
    CollectionsTypes: collectionsApiTypes,
    MetadataTypes: metadataApiTypes,
    NFTOwnersTypes: nftOwnersApiTypes,
    NFTsTypes: nftsApiTypes,
    TokensTypes: tokensApiTypes
});

/**
 * createImmutableXConfiguration to create a custom ImmutableXConfiguration
 * other than the production and sandbox defined below.
 */
const createImmutableXConfiguration = ({ basePath, chainID, coreContractAddress, registrationContractAddress, }) => Config.createConfig({
    basePath,
    chainID,
    coreContractAddress,
    registrationContractAddress,
    sdkVersion: 'ts-immutable-sdk-0.35.8',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const production = () => createImmutableXConfiguration({
    basePath: 'https://api.x.immutable.com',
    chainID: 1,
    coreContractAddress: '0x5FDCCA53617f4d2b9134B29090C87D01058e27e9',
    registrationContractAddress: '0x72a06bf2a1CE5e39cBA06c0CAb824960B587d64c',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const sandbox = () => createImmutableXConfiguration({
    basePath: 'https://api.sandbox.x.immutable.com',
    chainID: 11155111,
    coreContractAddress: '0x2d5C349fD8464DA06a3f90b4B0E9195F3d1b7F98',
    registrationContractAddress: '0xDbA6129C02E69405622fAdc3d5A7f8d23eac3b97',
});
class ImxConfiguration {
    immutableXConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.immutableXConfig = overrides.immutableXConfig;
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.immutableXConfig = sandbox();
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.immutableXConfig = production();
                    break;
                }
                default: {
                    this.immutableXConfig = sandbox();
                }
            }
        }
    }
}

class ImmutableXClient {
    immutableX;
    depositsApi;
    mintsApi;
    ordersApi;
    tokensApi;
    tradesApi;
    transfersApi;
    exchangeApi;
    nftCheckoutPrimaryApi;
    usersApi;
    withdrawalsApi;
    balanceApi;
    assetApi;
    collectionApi;
    metadataApi;
    metadataRefreshesApi;
    projectsApi;
    constructor(config) {
        const imxConfig = new ImxConfiguration(config);
        this.immutableX = new ImmutableX(imxConfig.immutableXConfig);
        this.depositsApi = this.immutableX.depositsApi;
        this.mintsApi = this.immutableX.mintsApi;
        this.ordersApi = this.immutableX.ordersApi;
        this.tokensApi = this.immutableX.tokensApi;
        this.tradesApi = this.immutableX.tradesApi;
        this.transfersApi = this.immutableX.transfersApi;
        this.exchangeApi = this.immutableX.exchangeApi;
        this.usersApi = this.immutableX.usersApi;
        this.withdrawalsApi = this.immutableX.withdrawalsApi;
        this.balanceApi = this.immutableX.balanceApi;
        this.assetApi = this.immutableX.assetApi;
        this.collectionApi = this.immutableX.collectionApi;
        this.metadataApi = this.immutableX.metadataApi;
        this.metadataRefreshesApi = this.immutableX.metadataRefreshesApi;
        this.nftCheckoutPrimaryApi = this.immutableX.nftCheckoutPrimaryApi;
        this.projectsApi = this.immutableX.projectsApi;
    }
    /**
     * Get details of a Deposit with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Deposit
     * @throws {@link index.IMXError}
     */
    getDeposit(request) {
        return this.immutableX.getDeposit(request);
    }
    /**
     * Get a list of Deposits
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Deposits
     * @throws {@link index.IMXError}
     */
    listDeposits(request) {
        return this.immutableX.listDeposits(request);
    }
    /**
     * Get Stark keys for a registered User
     * @param ethAddress - the eth address of the User
     * @returns a promise that resolves with the requested User
     * @throws {@link index.IMXError}
     */
    getUser(ethAddress) {
        return this.immutableX.getUser(ethAddress);
    }
    /**
     * Get details of an Asset
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Asset
     * @throws {@link index.IMXError}
     */
    getAsset(request) {
        return this.immutableX.getAsset(request);
    }
    /**
     * Get a list of Assets
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Assets
     * @throws {@link index.IMXError}
     */
    listAssets(request) {
        return this.immutableX.listAssets(request);
    }
    /**
     * Create a Collection
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Collection
     * @throws {@link index.IMXError}
     */
    createCollection(ethSigner, request) {
        return this.immutableX.createCollection(ethSigner, request);
    }
    /**
     * Get details of a Collection at the given address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Collection
     * @throws {@link index.IMXError}
     */
    getCollection(request) {
        return this.immutableX.getCollection(request);
    }
    /**
     * Get a list of Collection filters
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collection Filters
     * @throws {@link index.IMXError}
     */
    listCollectionFilters(request) {
        return this.immutableX.listCollectionFilters(request);
    }
    /**
     * Get a list of Collections
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collections
     * @throws {@link index.IMXError}
     */
    listCollections(request) {
        return this.collectionApi.listCollections(request).then((res) => res.data);
    }
    /**
     * Update a Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated Collection
     * @throws {@link index.IMXError}
     */
    updateCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.updateCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Add metadata schema to Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    addMetadataSchemaToCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.addMetadataSchemaToCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Get Metadata schema
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Metadata schema
     * @throws {@link index.IMXError}
     */
    getMetadataSchema(request) {
        return this.immutableX.getMetadataSchema(request);
    }
    /**
     * Update metadata schema by name
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param name - the Metadata schema name
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    updateMetadataSchemaByName(ethSigner, collectionAddress, name, request) {
        return this.immutableX.updateMetadataSchemaByName(ethSigner, collectionAddress, name, request);
    }
    /**
     * Get a list of metadata refreshes
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refreshes
     * @throws {@link index.IMXError}
     */
    listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor) {
        return this.immutableX.listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh errors
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refresh errors
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor) {
        return this.immutableX.getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh results
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @returns a promise that resolves with the requested metadata refresh results
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshResults(ethSigner, refreshId) {
        return this.immutableX.getMetadataRefreshResults(ethSigner, refreshId);
    }
    /**
     * Request a metadata refresh
     * @param ethSigner - the L1 signer
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested metadata refresh
     * @throws {@link index.IMXError}
     */
    createMetadataRefresh(ethSigner, request) {
        return this.immutableX.createMetadataRefresh(ethSigner, request);
    }
    /**
     * Create a Project
     * @param ethSigner - the L1 signer
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the created Project
     * @throws {@link index.IMXError}
     */
    async createProject(ethSigner, request) {
        return this.immutableX.createProject(ethSigner, request);
    }
    /**
     * Get a Project
     * @param ethSigner - the L1 signer
     * @param id - the Project ID
     * @returns a promise that resolves with the requested Project
     * @throws {@link index.IMXError}
     */
    async getProject(ethSigner, id) {
        return this.immutableX.getProject(ethSigner, id);
    }
    /**
     * Get Projects owned by the given User
     * @param ethSigner - the L1 signer
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @param orderBy - the property to sort by
     * @param direction - direction to sort (asc/desc)
     * @returns a promise that resolves with the requested Projects
     * @throws {@link index.IMXError}
     */
    async getProjects(ethSigner, pageSize, cursor, orderBy, direction) {
        return this.immutableX.getProjects(ethSigner, pageSize, cursor, orderBy, direction);
    }
    /**
     * Get the token Balances of the User
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Balance
     * @throws {@link index.IMXError}
     */
    getBalance(request) {
        return this.immutableX.getBalance(request);
    }
    /**
     * Get a list of Balances for given User
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Balances
     * @throws {@link index.IMXError}
     */
    listBalances(request) {
        return this.immutableX.listBalances(request);
    }
    /**
     * Get details of a Mint with the given ID
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Mint
     * @throws {@link index.IMXError}
     */
    getMint(request) {
        return this.immutableX.getMint(request);
    }
    /**
     * Get a list of Mints
     * @param request optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Mints
     * @throws {@link index.IMXError}
     */
    listMints(request) {
        return this.immutableX.listMints(request);
    }
    /**
     * Mint tokens in a batch with fees
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the minted tokens
     * @throws {@link index.IMXError}
     */
    mint(ethSigner, request) {
        return this.immutableX.mint(ethSigner, request);
    }
    /**
     * Get a list of Withdrawals
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Withdrawals
     * @throws {@link index.IMXError}
     */
    listWithdrawals(request) {
        return this.immutableX.listWithdrawals(request);
    }
    /**
     * Get details of Withdrawal with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Withdrawal
     * @throws {@link index.IMXError}
     */
    getWithdrawal(request) {
        return this.immutableX.getWithdrawal(request);
    }
    /**
     * Get details of an Order with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Order
     * @throws {@link index.IMXError}
     */
    getOrder(request) {
        return this.immutableX.getOrder(request);
    }
    /**
     * Get a list of Orders
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Orders
     * @throws {@link index.IMXError}
     */
    listOrders(request) {
        return this.immutableX.listOrders(request);
    }
    /**
     * Get details of a Trade with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Trade
     * @throws {@link index.IMXError}
     */
    getTrade(request) {
        return this.immutableX.getTrade(request);
    }
    /**
     * Get a list of Trades
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Trades
     * @throws {@link index.IMXError}
     */
    listTrades(request) {
        return this.immutableX.listTrades(request);
    }
    /**
     * Get details of a Token
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Token
     * @throws {@link index.IMXError}
     */
    getToken(request) {
        return this.immutableX.getToken(request);
    }
    /**
     * Get a list of Tokens
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Tokens
     * @throws {@link index.IMXError}
     */
    listTokens(request) {
        return this.immutableX.listTokens(request);
    }
    /**
     * Get details of a Transfer with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Transfer
     * @throws {@link index.IMXError}
     */
    getTransfer(request) {
        return this.immutableX.getTransfer(request);
    }
    /**
     * Get a list of Transfers
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Transfers
     * @throws {@link index.IMXError}
     */
    listTransfers(request) {
        return this.immutableX.listTransfers(request);
    }
    /**
     * Create a new Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transaction
     * @throws {@link index.IMXError}
     */
    createExchange(request) {
        return this.immutableX.createExchange(request).then((res) => res.data);
    }
    /**
     * Get an Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the Exchange Transaction
     * @throws {@link index.IMXError}
     */
    getExchange(request) {
        return this.immutableX.getExchange(request).then((res) => res.data);
    }
    /**
     * Get Exchange transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with Exchange Transactions
     * @throws {@link index.IMXError}
     */
    getExchanges(request) {
        return this.immutableX.getExchanges(request).then((res) => res.data);
    }
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of Eth/Stark signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transfer
     * @throws {@link index.IMXError}
     */
    exchangeTransfer(walletConnection, request) {
        return this.immutableX.exchangeTransfer(walletConnection, request);
    }
    /**
     * Create a new nft primary transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created nft primary Transaction
     * @throws {@link index.IMXError}
     */
    createNftPrimary(request) {
        return this.immutableX.createNftPrimary(request).then((res) => res.data);
    }
    /**
     * Get nft primary supported currencies and their limits
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary Currencies
     * @throws {@link index.IMXError}
     */
    getCurrenciesNFTCheckoutPrimary(request) {
        return this.immutableX
            .getCurrenciesNFTCheckoutPrimary(request)
            .then((res) => res.data);
    }
    /**
     * Get nft primary transaction by transaction id
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransaction(request) {
        return this.immutableX
            .getNftPrimaryTransaction(request)
            .then((res) => res.data);
    }
    /**
     * Get list of nft primary transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransactions(request) {
        return this.immutableX
            .getNftPrimaryTransactions(request)
            .then((res) => res.data);
    }
}

var immutablex_client = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IMXError: IMXError,
    ImmutableXClient: ImmutableXClient,
    imxClientCreateStarkSigner: createStarkSigner,
    imxClientGenerateLegacyStarkPrivateKey: generateLegacyStarkPrivateKey
});

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString$1 = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob$1 = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData$1 = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

var utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData: isFormData$1,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob: isBlob$1,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode$2(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode$2;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


var platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

var cookies = platform.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })();

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

var isURLSameOrigin = platform.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else {
        requestHeaders.setContentType('multipart/form-data;', false); // mobile/desktop app frameworks
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const VERSION = "1.4.0";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

// this module should only have a default export
var globalAxios = axios;

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH = "https://guardian.sandbox.imtbl.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MessagesApi - axios parameter creator
 * @export
 */
const MessagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingMessage: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('approvePendingMessage', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}/approve`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateMessage: async (messageEvaluationRequest, options = {}) => {
            // verify required parameter 'messageEvaluationRequest' is not null or undefined
            assertParamExists('evaluateMessage', 'messageEvaluationRequest', messageEvaluationRequest);
            const localVarPath = `/guardian/v1/messages/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(messageEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageByID: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('getMessageByID', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagesApi - functional programming interface
 * @export
 */
const MessagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingMessage(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingMessage(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateMessage(messageEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateMessage(messageEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageByID(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageByID(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
class MessagesApi extends BaseAPI {
    /**
     * Approve a pending evm message
     * @summary Approve a pending evm message
     * @param {MessagesApiApprovePendingMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    approvePendingMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).approvePendingMessage(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a given message is valid  for EVM
     * @summary Evaluate an evm message to sign
     * @param {MessagesApiEvaluateMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    evaluateMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).evaluateMessage(requestParameters.messageEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an evm message by id
     * @summary Info for a specific evm message
     * @param {MessagesApiGetMessageByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessageByID(requestParameters, options) {
        return MessagesApiFp(this.configuration).getMessageByID(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingTransaction: async (payloadHash, transactionApprovalRequest, options = {}) => {
            // verify required parameter 'payloadHash' is not null or undefined
            assertParamExists('approvePendingTransaction', 'payloadHash', payloadHash);
            // verify required parameter 'transactionApprovalRequest' is not null or undefined
            assertParamExists('approvePendingTransaction', 'transactionApprovalRequest', transactionApprovalRequest);
            const localVarPath = `/guardian/v1/transactions/{payloadHash}/approve`
                .replace(`{${"payloadHash"}}`, encodeURIComponent(String(payloadHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionApprovalRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateTransaction: async (id, transactionEvaluationRequest, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluateTransaction', 'id', id);
            // verify required parameter 'transactionEvaluationRequest' is not null or undefined
            assertParamExists('evaluateTransaction', 'transactionEvaluationRequest', transactionEvaluationRequest);
            const localVarPath = `/guardian/v1/transactions/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByID: async (transactionID, chainType, chainID, options = {}) => {
            // verify required parameter 'transactionID' is not null or undefined
            assertParamExists('getTransactionByID', 'transactionID', transactionID);
            // verify required parameter 'chainType' is not null or undefined
            assertParamExists('getTransactionByID', 'chainType', chainType);
            const localVarPath = `/guardian/v1/transactions/{transactionID}`
                .replace(`{${"transactionID"}}`, encodeURIComponent(String(transactionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (chainType !== undefined) {
                localVarQueryParameter['chainType'] = chainType;
            }
            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingTransaction(payloadHash, transactionApprovalRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingTransaction(payloadHash, transactionApprovalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateTransaction(id, transactionEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateTransaction(id, transactionEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByID(transactionID, chainType, chainID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByID(transactionID, chainType, chainID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Approve a pending transaction
     * @summary Approve a pending transaction given chain
     * @param {TransactionsApiApprovePendingTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    approvePendingTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).approvePendingTransaction(requestParameters.payloadHash, requestParameters.transactionApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if the transaction is valid by transaction ID for both StarkEx and EVM
     * @summary Evaluate a transaction
     * @param {TransactionsApiEvaluateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    evaluateTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).evaluateTransaction(requestParameters.id, requestParameters.transactionEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a transaction by payload hash
     * @summary Info for a specific transaction
     * @param {TransactionsApiGetTransactionByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionByID(requestParameters, options) {
        return TransactionsApiFp(this.configuration).getTransactionByID(requestParameters.transactionID, requestParameters.chainType, requestParameters.chainID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const TransactionApprovalRequestChainTypeEnum = {
    Starkex: 'starkex',
    Evm: 'evm'
};

// used to sign message with L1 keys. Used for registration
function serializeEthSignature(sig) {
    // This is because golang appends a recovery param
    // https://github.com/ethers-io/ethers.js/issues/823
    return encUtils.addHexPrefix(encUtils.padLeft(sig.r.toString(16), 64)
        + encUtils.padLeft(sig.s.toString(16), 64)
        + encUtils.padLeft(sig.recoveryParam?.toString(16) || '', 2));
}
function importRecoveryParam(v) {
    const isValidBigNumber = new BN$2(v, 16).cmp(new BN$2(27)) !== -1
        ? new BN$2(v, 16).sub(new BN$2(27)).toNumber()
        : new BN$2(v, 16).toNumber();
    return v.trim()
        ? isValidBigNumber
        : undefined;
}
// used chained with serializeEthSignature. serializeEthSignature(deserializeSignature(...))
function deserializeSignature(sig, size = 64) {
    const removedHexPrefixSig = encUtils.removeHexPrefix(sig);
    return {
        r: new BN$2(removedHexPrefixSig.substring(0, size), 'hex'),
        s: new BN$2(removedHexPrefixSig.substring(size, size * 2), 'hex'),
        recoveryParam: importRecoveryParam(removedHexPrefixSig.substring(size * 2, size * 2 + 2)),
    };
}
async function signRaw(payload, signer) {
    const signature = deserializeSignature(await signer.signMessage(payload));
    return serializeEthSignature(signature);
}
async function signMessage$1(message, signer) {
    const ethAddress = await signer.getAddress();
    const ethSignature = await signRaw(message, signer);
    return {
        message,
        ethAddress,
        ethSignature,
    };
}

/**
 * Helper method to convert token type to a SignableToken type
 * @param token - the token type to convert to a SignableToken type
 * @returns the converted SignableToken
 */
function convertToSignableToken(token) {
    switch (token.type) {
        case 'ERC721':
            return {
                type: 'ERC721',
                data: {
                    token_id: token.tokenId,
                    token_address: token.tokenAddress,
                },
            };
        case 'ERC20':
            return {
                type: 'ERC20',
                data: {
                    token_address: token.tokenAddress,
                },
            };
        case 'ETH':
        default:
            return {
                type: 'ETH',
                data: {
                    decimals: 18,
                },
            };
    }
}

var PassportErrorType;
(function (PassportErrorType) {
    PassportErrorType["AUTHENTICATION_ERROR"] = "AUTHENTICATION_ERROR";
    PassportErrorType["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    PassportErrorType["WALLET_CONNECTION_ERROR"] = "WALLET_CONNECTION_ERROR";
    PassportErrorType["NOT_LOGGED_IN_ERROR"] = "NOT_LOGGED_IN_ERROR";
    PassportErrorType["SILENT_LOGIN_ERROR"] = "SILENT_LOGIN_ERROR";
    PassportErrorType["REFRESH_TOKEN_ERROR"] = "REFRESH_TOKEN_ERROR";
    PassportErrorType["USER_REGISTRATION_ERROR"] = "USER_REGISTRATION_ERROR";
    PassportErrorType["USER_NOT_REGISTERED_ERROR"] = "USER_NOT_REGISTERED_ERROR";
    PassportErrorType["LOGOUT_ERROR"] = "LOGOUT_ERROR";
    PassportErrorType["TRANSFER_ERROR"] = "TRANSFER_ERROR";
    PassportErrorType["CREATE_ORDER_ERROR"] = "CREATE_ORDER_ERROR";
    PassportErrorType["CANCEL_ORDER_ERROR"] = "CANCEL_ORDER_ERROR";
    PassportErrorType["EXCHANGE_TRANSFER_ERROR"] = "EXCHANGE_TRANSFER_ERROR";
    PassportErrorType["CREATE_TRADE_ERROR"] = "CREATE_TRADE_ERROR";
    PassportErrorType["OPERATION_NOT_SUPPORTED_ERROR"] = "OPERATION_NOT_SUPPORTED_ERROR";
})(PassportErrorType || (PassportErrorType = {}));
function isAPIError(error) {
    return 'code' in error && 'message' in error;
}
class PassportError extends Error {
    type;
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
const withPassportError = async (fn, customErrorType) => {
    try {
        return await fn();
    }
    catch (error) {
        let errorMessage;
        if (isAxiosError$1(error) && error.response?.data && isAPIError(error.response.data)) {
            errorMessage = error.response.data.message;
        }
        else {
            errorMessage = error.message;
        }
        throw new PassportError(errorMessage, customErrorType);
    }
};

/**
 * Enum representing different chain IDs.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain ID for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain ID for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain ID for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain ID for Ethereum.
 * @property {number} SEPOLIA - The chain ID for Sepolia.
 */
var ChainId$1;
(function (ChainId) {
    ChainId[ChainId["IMTBL_ZKEVM_MAINNET"] = 13371] = "IMTBL_ZKEVM_MAINNET";
    ChainId[ChainId["IMTBL_ZKEVM_TESTNET"] = 13473] = "IMTBL_ZKEVM_TESTNET";
    ChainId[ChainId["IMTBL_ZKEVM_DEVNET"] = 15003] = "IMTBL_ZKEVM_DEVNET";
    ChainId[ChainId["ETHEREUM"] = 1] = "ETHEREUM";
    ChainId[ChainId["SEPOLIA"] = 11155111] = "SEPOLIA";
})(ChainId$1 || (ChainId$1 = {}));
/**
 * Enum representing different chain names.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain name for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain name for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain name for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain name for Ethereum.
 * @property {number} SEPOLIA - The chain name for Sepolia.
 */
var ChainName$1;
(function (ChainName) {
    ChainName["ETHEREUM"] = "Ethereum";
    ChainName["SEPOLIA"] = "Sepolia";
    ChainName["IMTBL_ZKEVM_TESTNET"] = "Immutable zkEVM Test";
    ChainName["IMTBL_ZKEVM_DEVNET"] = "Immutable zkEVM Dev";
    ChainName["IMTBL_ZKEVM_MAINNET"] = "Immutable zkEVM";
})(ChainName$1 || (ChainName$1 = {}));

const KEY_PKCE_STATE = 'pkce_state';
const KEY_PKCE_VERIFIER = 'pkce_verifier';
const validCredentialsMinTtlSec = 3600; // 1 hour
class DeviceCredentialsManager {
    areValid(tokenResponse) {
        if (tokenResponse) {
            const accessTokenValid = this.isTokenValid(tokenResponse.access_token);
            const idTokenValid = this.isTokenValid(tokenResponse.id_token);
            return accessTokenValid && idTokenValid;
        }
        return false;
    }
    isTokenValid(jwt) {
        try {
            const tokenPayload = jwt_decode(jwt);
            const expiresAt = tokenPayload.exp ?? 0;
            const now = (Date.now() / 1000) + validCredentialsMinTtlSec;
            return expiresAt > now;
        }
        catch (error) {
            return false;
        }
    }
    savePKCEData(data) {
        localStorage.setItem(KEY_PKCE_STATE, data.state);
        localStorage.setItem(KEY_PKCE_VERIFIER, data.verifier);
    }
    getPKCEData() {
        const state = localStorage.getItem(KEY_PKCE_STATE);
        const verifier = localStorage.getItem(KEY_PKCE_VERIFIER);
        if (state && verifier) {
            return { state, verifier };
        }
        return null;
    }
}

function isIdTokenExpired(idToken) {
    if (!idToken) {
        return false;
    }
    const decodedToken = jwt_decode(idToken);
    const now = Math.floor(Date.now() / 1000);
    return decodedToken.exp < now;
}
function isTokenExpired(oidcUser) {
    const { id_token: idToken, expired } = oidcUser;
    if (expired) {
        return true;
    }
    return isIdTokenExpired(idToken);
}

const formUrlEncodedHeader = {
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
    },
};
const getAuthConfiguration = (config) => {
    const { authenticationDomain, oidcConfiguration } = config;
    const store = typeof window !== 'undefined' ? window.localStorage : new InMemoryWebStorage();
    const userStore = new WebStorageStateStore({ store });
    let endSessionEndpoint = `${authenticationDomain}/v2/logout?client_id=${oidcConfiguration.clientId}`;
    if (oidcConfiguration.logoutRedirectUri) {
        endSessionEndpoint += `&returnTo=${encodeURIComponent(oidcConfiguration.logoutRedirectUri)}`;
    }
    const baseConfiguration = {
        authority: authenticationDomain,
        redirect_uri: oidcConfiguration.redirectUri,
        popup_redirect_uri: oidcConfiguration.redirectUri,
        client_id: oidcConfiguration.clientId,
        metadata: {
            authorization_endpoint: `${authenticationDomain}/authorize`,
            token_endpoint: `${authenticationDomain}/oauth/token`,
            userinfo_endpoint: `${authenticationDomain}/userinfo`,
            end_session_endpoint: endSessionEndpoint,
        },
        mergeClaims: true,
        loadUserInfo: true,
        scope: oidcConfiguration.scope,
        userStore,
    };
    if (oidcConfiguration.audience) {
        baseConfiguration.extraQueryParams = {
            audience: oidcConfiguration.audience,
        };
    }
    return baseConfiguration;
};
function wait$1(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
function base64URLEncode(str) {
    return str.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
function sha256(buffer) {
    return crypto.createHash('sha256').update(buffer).digest();
}
class AuthManager {
    userManager;
    config;
    deviceCredentialsManager;
    logoutMode;
    /**
     * Promise that is used to prevent multiple concurrent calls to the refresh token endpoint.
     */
    refreshingPromise = null;
    constructor(config) {
        this.config = config;
        this.userManager = new UserManager(getAuthConfiguration(config));
        this.deviceCredentialsManager = new DeviceCredentialsManager();
        this.logoutMode = config.oidcConfiguration.logoutMode || 'redirect';
    }
    static mapOidcUserToDomainModel = (oidcUser) => {
        const passport = oidcUser.profile?.passport;
        const user = {
            expired: oidcUser.expired,
            idToken: oidcUser.id_token,
            accessToken: oidcUser.access_token,
            refreshToken: oidcUser.refresh_token,
            profile: {
                sub: oidcUser.profile.sub,
                email: oidcUser.profile.email,
                nickname: oidcUser.profile.nickname,
            },
        };
        if (passport?.imx_eth_address) {
            user.imx = {
                ethAddress: passport.imx_eth_address,
                starkAddress: passport.imx_stark_address,
                userAdminAddress: passport.imx_user_admin_address,
            };
        }
        if (passport?.zkevm_eth_address) {
            user.zkEvm = {
                ethAddress: passport?.zkevm_eth_address,
                userAdminAddress: passport?.zkevm_user_admin_address,
            };
        }
        return user;
    };
    static mapDeviceTokenResponseToOidcUser = (tokenResponse) => {
        const idTokenPayload = jwt_decode(tokenResponse.id_token);
        return new User({
            id_token: tokenResponse.id_token,
            access_token: tokenResponse.access_token,
            refresh_token: tokenResponse.refresh_token,
            token_type: tokenResponse.token_type,
            profile: {
                sub: idTokenPayload.sub,
                iss: idTokenPayload.iss,
                aud: idTokenPayload.aud,
                exp: idTokenPayload.exp,
                iat: idTokenPayload.iat,
                email: idTokenPayload.email,
                nickname: idTokenPayload.nickname,
                passport: idTokenPayload.passport,
            },
        });
    };
    async login() {
        return withPassportError(async () => {
            const popupWindowFeatures = { width: 410, height: 450 };
            const oidcUser = await this.userManager.signinPopup({
                popupWindowFeatures,
            });
            return AuthManager.mapOidcUserToDomainModel(oidcUser);
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginCallback() {
        return withPassportError(async () => this.userManager.signinPopupCallback(), PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginWithDeviceFlow() {
        return withPassportError(async () => {
            const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/device/code`, {
                client_id: this.config.oidcConfiguration.clientId,
                scope: this.config.oidcConfiguration.scope,
                audience: this.config.oidcConfiguration.audience,
            }, formUrlEncodedHeader);
            return {
                code: response.data.user_code,
                deviceCode: response.data.device_code,
                url: response.data.verification_uri_complete,
                interval: response.data.interval,
            };
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-disable no-await-in-loop */
    async loginWithDeviceFlowCallback(deviceCode, interval, timeoutMs) {
        return withPassportError(async () => {
            const startTime = Date.now();
            const loopCondition = true;
            while (loopCondition) {
                if (timeoutMs != null && Date.now() - startTime > timeoutMs) {
                    throw new Error('Timed out');
                }
                await wait$1(interval * 1000);
                try {
                    const tokenResponse = await this.getDeviceFlowToken(deviceCode);
                    const oidcUser = AuthManager.mapDeviceTokenResponseToOidcUser(tokenResponse);
                    const user = AuthManager.mapOidcUserToDomainModel(oidcUser);
                    await this.userManager.storeUser(oidcUser);
                    return user;
                }
                catch (error) {
                    if (globalAxios$1.isAxiosError(error)) {
                        const responseError = error.response?.data;
                        switch (responseError.error) {
                            case 'authorization_pending':
                                break;
                            case 'slow_down':
                                break;
                            case 'expired_token':
                                throw new Error('Token expired, please log in again');
                            case 'access_denied':
                                throw new Error('User denied access');
                            default:
                                throw new Error('Error getting token');
                        }
                    }
                    else {
                        throw error;
                    }
                }
            }
            throw new Error('Failed to get credentials');
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-enable no-await-in-loop */
    async getDeviceFlowToken(deviceCode) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
            device_code: deviceCode,
        }, formUrlEncodedHeader);
        return response.data;
    }
    getPKCEAuthorizationUrl() {
        const verifier = base64URLEncode(crypto.randomBytes(32));
        const challenge = base64URLEncode(sha256(verifier));
        // https://auth0.com/docs/secure/attack-protection/state-parameters
        const state = base64URLEncode(crypto.randomBytes(32));
        this.deviceCredentialsManager.savePKCEData({ state, verifier });
        return `${this.config.authenticationDomain}/authorize?`
            + 'response_type=code'
            + `&code_challenge=${challenge}`
            + '&code_challenge_method=S256'
            + `&client_id=${this.config.oidcConfiguration.clientId}`
            + `&redirect_uri=${this.config.oidcConfiguration.redirectUri}`
            + `&scope=${this.config.oidcConfiguration.scope}`
            + `&state=${state}`
            + `&audience=${this.config.oidcConfiguration.audience}`;
    }
    async loginWithPKCEFlowCallback(authorizationCode, state) {
        return withPassportError(async () => {
            const pkceData = this.deviceCredentialsManager.getPKCEData();
            if (!pkceData) {
                throw new Error('No code verifier or state for PKCE');
            }
            if (state !== pkceData.state) {
                throw new Error('Provided state does not match stored state');
            }
            const tokenResponse = await this.getPKCEToken(authorizationCode, pkceData.verifier);
            const oidcUser = AuthManager.mapDeviceTokenResponseToOidcUser(tokenResponse);
            const user = AuthManager.mapOidcUserToDomainModel(oidcUser);
            await this.userManager.storeUser(oidcUser);
            return user;
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async getPKCEToken(authorizationCode, codeVerifier) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'authorization_code',
            code_verifier: codeVerifier,
            code: authorizationCode,
            redirect_uri: this.config.oidcConfiguration.redirectUri,
        }, formUrlEncodedHeader);
        return response.data;
    }
    async logout() {
        return withPassportError(async () => {
            if (this.logoutMode === 'silent') {
                return this.userManager.signoutSilent();
            }
            return this.userManager.signoutRedirect();
        }, PassportErrorType.LOGOUT_ERROR);
    }
    async removeUser() {
        return this.userManager.removeUser();
    }
    getDeviceFlowEndSessionEndpoint() {
        const { authenticationDomain, oidcConfiguration } = this.config;
        let endSessionEndpoint = `${authenticationDomain}/v2/logout`;
        if (oidcConfiguration.logoutRedirectUri) {
            endSessionEndpoint += `?client_id=${oidcConfiguration.clientId}`
                + `&returnTo=${encodeURIComponent(oidcConfiguration.logoutRedirectUri)}`;
        }
        return endSessionEndpoint;
    }
    async logoutSilentCallback(url) {
        return this.userManager.signoutSilentCallback(url);
    }
    async forceUserRefresh() {
        return this.refreshTokenAndUpdatePromise();
    }
    /**
     * Refreshes the token and returns the user.
     * If the token is already being refreshed, returns the existing promise.
     */
    async refreshTokenAndUpdatePromise() {
        if (this.refreshingPromise)
            return this.refreshingPromise;
        // eslint-disable-next-line no-async-promise-executor
        this.refreshingPromise = new Promise(async (resolve, reject) => {
            try {
                const newOidcUser = await this.userManager.signinSilent();
                if (newOidcUser) {
                    resolve(AuthManager.mapOidcUserToDomainModel(newOidcUser));
                    return;
                }
                resolve(null);
            }
            catch (err) {
                reject(err);
            }
            finally {
                this.refreshingPromise = null; // Reset the promise after completion
            }
        });
        return this.refreshingPromise;
    }
    /**
     * Get the user from the cache or refresh the token if it's expired.
     * return null if there's no refresh token.
     */
    async getUser() {
        return withPassportError(async () => {
            const oidcUser = await this.userManager.getUser();
            if (!oidcUser)
                return null;
            if (!isTokenExpired(oidcUser)) {
                return AuthManager.mapOidcUserToDomainModel(oidcUser);
            }
            if (oidcUser.refresh_token) {
                return this.refreshTokenAndUpdatePromise();
            }
            return null;
        }, PassportErrorType.NOT_LOGGED_IN_ERROR);
    }
}

const lazyLoad = (promiseToAwait, initialiseFunction) => promiseToAwait().then(initialiseFunction);
const lazyDocumentReady = (initialiseFunction) => {
    const documentReadyPromise = () => new Promise((resolve) => {
        if (window.document.readyState === 'complete') {
            resolve();
        }
        else {
            const onReadyStateChange = () => {
                if (window.document.readyState === 'complete') {
                    resolve();
                    window.document.removeEventListener('readystatechange', onReadyStateChange);
                }
            };
            window.document.addEventListener('readystatechange', onReadyStateChange);
        }
    });
    return lazyLoad(documentReadyPromise, initialiseFunction);
};

class MagicAdapter {
    config;
    lazyMagicClient;
    constructor(config) {
        this.config = config;
        if (typeof window !== 'undefined') {
            this.lazyMagicClient = lazyDocumentReady(() => {
                const client = new Magic(this.config.magicPublishableApiKey, {
                    extensions: [new OpenIdExtension()],
                    network: this.config.network,
                });
                client.preload();
                return client;
            });
        }
    }
    get magicClient() {
        if (!this.lazyMagicClient) {
            throw new Error('Cannot perform this action outside of the browser');
        }
        return this.lazyMagicClient;
    }
    async login(idToken) {
        return withPassportError(async () => {
            const magicClient = await this.magicClient;
            await magicClient.openid.loginWithOIDC({
                jwt: idToken,
                providerId: this.config.magicProviderId,
            });
            return magicClient.rpcProvider;
        }, PassportErrorType.WALLET_CONNECTION_ERROR);
    }
    async logout() {
        const magicClient = await this.magicClient;
        if (magicClient.user) {
            await magicClient.user.logout();
        }
    }
}

const getStarkSigner = async (signer) => withPassportError(async () => {
    const privateKey = await generateLegacyStarkPrivateKey(signer);
    return createStarkSigner(privateKey);
}, PassportErrorType.WALLET_CONNECTION_ERROR);

const POLL_INTERVAL = 1 * 1000; // every 1 second
const MAX_RETRIES = 3;
const wait = (ms) => new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
});
const retryWithDelay = async (fn, options) => {
    const { retries = MAX_RETRIES, interval = POLL_INTERVAL, finalErr = Error('Retry failed'), finallyFn = () => { }, } = options || {};
    try {
        return await fn();
    }
    catch (err) {
        if (retries <= 0) {
            return Promise.reject(finalErr);
        }
        await wait(interval);
        return retryWithDelay(fn, { retries: retries - 1, finalErr, finallyFn });
    }
    finally {
        if (retries <= 0) {
            finallyFn();
        }
    }
};

/**
 * ProviderErrors should take priority over RpcErrorCodes
 * https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 * https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
var ProviderErrorCode;
(function (ProviderErrorCode) {
    ProviderErrorCode[ProviderErrorCode["USER_REJECTED_REQUEST"] = 4001] = "USER_REJECTED_REQUEST";
    ProviderErrorCode[ProviderErrorCode["UNAUTHORIZED"] = 4100] = "UNAUTHORIZED";
    ProviderErrorCode[ProviderErrorCode["UNSUPPORTED_METHOD"] = 4200] = "UNSUPPORTED_METHOD";
    ProviderErrorCode[ProviderErrorCode["DISCONNECTED"] = 4900] = "DISCONNECTED";
})(ProviderErrorCode || (ProviderErrorCode = {}));
var RpcErrorCode;
(function (RpcErrorCode) {
    RpcErrorCode[RpcErrorCode["RPC_SERVER_ERROR"] = -32000] = "RPC_SERVER_ERROR";
    RpcErrorCode[RpcErrorCode["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    RpcErrorCode[RpcErrorCode["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    RpcErrorCode[RpcErrorCode["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    RpcErrorCode[RpcErrorCode["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    RpcErrorCode[RpcErrorCode["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    RpcErrorCode[RpcErrorCode["TRANSACTION_REJECTED"] = -32003] = "TRANSACTION_REJECTED";
})(RpcErrorCode || (RpcErrorCode = {}));
class JsonRpcError extends Error {
    message;
    code;
    constructor(code, message) {
        super(message);
        this.message = message;
        this.code = code;
    }
}

const transactionRejectedCrossSdkBridgeError = 'Transaction requires confirmation but this functionality is not'
    + ' supported in this environment. Please contact Immutable support if you need to enable this feature.';
const convertBigNumberishToString = (value) => BigNumber$1.from(value).toString();
const transformGuardianTransactions = (txs) => {
    try {
        return txs.map((t) => ({
            delegateCall: t.delegateCall === true,
            revertOnError: t.revertOnError === true,
            gasLimit: t.gasLimit ? convertBigNumberishToString(t.gasLimit) : '0',
            target: t.to ?? ethers.constants.AddressZero,
            value: t.value ? convertBigNumberishToString(t.value) : '0',
            data: t.data ? t.data.toString() : '0x',
        }));
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Transaction failed to parsing: ${errorMessage}`);
    }
};
class GuardianClient {
    transactionAPI;
    messageAPI;
    confirmationScreen;
    crossSdkBridgeEnabled;
    constructor({ confirmationScreen, config }) {
        const guardianConfiguration = new Configuration({ basePath: config.imxPublicApiDomain });
        this.confirmationScreen = confirmationScreen;
        this.crossSdkBridgeEnabled = config.crossSdkBridgeEnabled;
        this.messageAPI = new MessagesApi(guardianConfiguration);
        this.transactionAPI = new TransactionsApi(guardianConfiguration);
    }
    /**
     * Open confirmation screen and close it automatically if the
     * underlying task fails.
     */
    withConfirmationScreen(popupWindowSize) {
        return (task) => this.withConfirmationScreenTask(popupWindowSize)(task)();
    }
    withConfirmationScreenTask(popupWindowSize) {
        return (task) => async () => {
            this.confirmationScreen.loading(popupWindowSize);
            try {
                return await task();
            }
            catch (err) {
                this.confirmationScreen.closeWindow();
                throw err;
            }
        };
    }
    withDefaultConfirmationScreenTask(task) {
        return this.withConfirmationScreenTask()(task);
    }
    async evaluateImxTransaction({ payloadHash, user }) {
        const finallyFn = () => {
            this.confirmationScreen.closeWindow();
        };
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const transactionRes = await retryWithDelay(async () => this.transactionAPI.getTransactionByID({
            transactionID: payloadHash,
            chainType: 'starkex',
        }, { headers }), { finallyFn });
        if (!transactionRes.data.id) {
            throw new Error("Transaction doesn't exists");
        }
        const evaluateImxRes = await this.transactionAPI.evaluateTransaction({
            id: payloadHash,
            transactionEvaluationRequest: {
                chainType: 'starkex',
            },
        }, { headers });
        const { confirmationRequired } = evaluateImxRes.data;
        if (confirmationRequired) {
            if (this.crossSdkBridgeEnabled) {
                throw new Error(transactionRejectedCrossSdkBridgeError);
            }
            const confirmationResult = await this.confirmationScreen.requestConfirmation(payloadHash, user.imx.ethAddress, TransactionApprovalRequestChainTypeEnum.Starkex);
            if (!confirmationResult.confirmed) {
                throw new Error('Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const guardianTransactions = transformGuardianTransactions(metaTransactions);
        try {
            const transactionEvaluationResponseAxiosResponse = await this.transactionAPI.evaluateTransaction({
                id: 'evm',
                transactionEvaluationRequest: {
                    chainType: 'evm',
                    chainId,
                    transactionData: {
                        nonce,
                        userAddress: user.zkEvm.ethAddress,
                        metaTransactions: guardianTransactions,
                    },
                },
            }, { headers });
            return transactionEvaluationResponseAxiosResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Transaction failed to validate with error: ${errorMessage}`);
        }
    }
    async validateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const transactionEvaluationResponse = await this.evaluateEVMTransaction({
            chainId,
            nonce,
            user,
            metaTransactions,
        });
        const { confirmationRequired, transactionId } = transactionEvaluationResponse;
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!transactionId) {
            const confirmationResult = await this.confirmationScreen.requestConfirmation(transactionId, user.zkEvm.ethAddress, TransactionApprovalRequestChainTypeEnum.Evm, chainId);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateMessage({ chainID, payload, user }) {
        try {
            const messageEvalResponse = await this.messageAPI.evaluateMessage({ messageEvaluationRequest: { chainID, payload } }, { headers: { Authorization: `Bearer ${user.accessToken}` } });
            return messageEvalResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Message failed to validate with error: ${errorMessage}`);
        }
    }
    async validateMessage({ chainID, payload, user }) {
        const { messageId, confirmationRequired } = await this.evaluateMessage({ chainID, payload, user });
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!messageId) {
            const confirmationResult = await this.confirmationScreen.requestMessageConfirmation(messageId, user.zkEvm.ethAddress);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Signature rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
}

var PassportEvents;
(function (PassportEvents) {
    PassportEvents["LOGGED_OUT"] = "loggedOut";
})(PassportEvents || (PassportEvents = {}));
var Networks;
(function (Networks) {
    Networks["PRODUCTION"] = "mainnet";
    Networks["SANDBOX"] = "sepolia";
})(Networks || (Networks = {}));

async function exchangeTransfer$1({ user, starkSigner, request, exchangesApi, }) {
    return withPassportError(async () => {
        const { ethAddress } = user.imx;
        const transferAmount = request.amount;
        const signableResult = await exchangesApi.getExchangeSignableTransfer({
            id: request.transactionID,
            getSignableTransferRequest: {
                sender: ethAddress,
                token: convertToSignableToken(request),
                amount: transferAmount,
                receiver: request.receiver,
            },
        });
        const starkAddress = await starkSigner.getAddress();
        const { payload_hash: payloadHash } = signableResult.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key || starkAddress,
            sender_vault_id: signableResult.data.sender_vault_id,
            receiver_stark_key: signableResult.data.receiver_stark_key,
            receiver_vault_id: signableResult.data.receiver_vault_id,
            asset_id: signableResult.data.asset_id,
            amount: signableResult.data.amount,
            nonce: signableResult.data.nonce,
            expiration_timestamp: signableResult.data.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const response = await exchangesApi.createExchangeTransfer({
            id: request.transactionID,
            createTransferRequest: transferSigningParams,
        }, { headers });
        return {
            sent_signature: response?.data.sent_signature,
            status: response?.data.status?.toString(),
            time: response?.data.time,
            transfer_id: response?.data.transfer_id,
        };
    }, PassportErrorType.EXCHANGE_TRANSFER_ERROR);
}

const ERC721$1 = 'ERC721';
async function createOrder$1({ starkSigner, user, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const amountSell = request.sell.type === ERC721$1 ? '1' : request.sell.amount;
        const amountBuy = request.buy.type === ERC721$1 ? '1' : request.buy.amount;
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const getSignableOrderRequestV3 = {
            user: ethAddress,
            amount_buy: amountBuy,
            token_buy: convertToSignableToken(request.buy),
            amount_sell: amountSell,
            token_sell: convertToSignableToken(request.sell),
            fees: request.fees,
            split_fees: true,
            expiration_timestamp: request.expiration_timestamp,
        };
        const getSignableOrderResponse = await ordersApi.getSignableOrder({
            getSignableOrderRequestV3,
        }, { headers });
        await guardianClient.evaluateImxTransaction({
            user,
            payloadHash: getSignableOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const signableResultData = getSignableOrderResponse.data;
        const orderParams = {
            createOrderRequest: {
                include_fees: true,
                fees: request.fees,
                stark_signature: starkSignature,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const createOrderResponse = await ordersApi.createOrderV3(orderParams, {
            headers,
        });
        return {
            ...createOrderResponse.data,
        };
    }), PassportErrorType.CREATE_ORDER_ERROR);
}
async function cancelOrder$1({ user, starkSigner, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const getSignableCancelOrderRequest = {
            order_id: request.order_id,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const getSignableCancelOrderResponse = await ordersApi.getSignableCancelOrderV3({
            getSignableCancelOrderRequest,
        }, { headers });
        await guardianClient.evaluateImxTransaction({
            user,
            payloadHash: getSignableCancelOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableCancelOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const cancelOrderResponse = await ordersApi.cancelOrderV3({
            id: request.order_id.toString(),
            cancelOrderRequest: {
                order_id: request.order_id,
                stark_signature: starkSignature,
            },
        }, { headers });
        return {
            order_id: cancelOrderResponse.data.order_id,
            status: cancelOrderResponse.data.status,
        };
    }), PassportErrorType.CANCEL_ORDER_ERROR);
}

async function registerPassport({ ethSigner, starkSigner, usersApi }, authorization) {
    const [userAddress, starkPublicKey] = await Promise.all([
        ethSigner.getAddress(),
        starkSigner.getAddress(),
    ]);
    const signableResult = await usersApi.getSignableRegistrationOffchain({
        getSignableRegistrationRequest: {
            ether_key: userAddress,
            stark_key: starkPublicKey,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const [ethSignature, starkSignature] = await Promise.all([
        signRaw(signableMessage, ethSigner),
        starkSigner.signMessage(payloadHash),
    ]);
    const response = await usersApi.registerPassportUser({
        authorization: `Bearer ${authorization}`,
        registerPassportUserRequest: {
            eth_signature: ethSignature,
            ether_key: userAddress,
            stark_signature: starkSignature,
            stark_key: starkPublicKey,
        },
    });
    return response.data;
}

async function createTrade$1({ request, tradesApi, user, starkSigner, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const getSignableTradeRequest = {
            expiration_timestamp: request.expiration_timestamp,
            fees: request.fees,
            order_id: request.order_id,
            user: ethAddress,
        };
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const getSignableTradeResponse = await tradesApi.getSignableTrade({
            getSignableTradeRequest,
        }, { headers });
        await guardianClient.evaluateImxTransaction({
            user,
            payloadHash: getSignableTradeResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableTradeResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const { data: signableResultData } = getSignableTradeResponse;
        const tradeParams = {
            createTradeRequest: {
                include_fees: true,
                fees: request?.fees,
                stark_signature: starkSignature,
                order_id: request?.order_id,
                fee_info: signableResultData.fee_info,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const { data: createTradeResponse } = await tradesApi.createTradeV3(tradeParams, {
            headers,
        });
        return createTradeResponse;
    }), PassportErrorType.CREATE_TRADE_ERROR);
}

const ERC721 = 'ERC721';
async function transfer$1({ request, transfersApi, starkSigner, user, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const transferAmount = request.type === ERC721 ? '1' : request.amount;
        const getSignableTransferRequest = {
            sender: user.imx.ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        };
        const headers = {
            Authorization: `Bearer ${user.accessToken}`,
        };
        const signableResult = await transfersApi.getSignableTransferV1({
            getSignableTransferRequest,
        }, { headers });
        await guardianClient.evaluateImxTransaction({
            user,
            payloadHash: signableResult.data.payload_hash,
        });
        const signableResultData = signableResult.data;
        const { payload_hash: payloadHash } = signableResultData;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const senderStarkKey = await starkSigner.getAddress();
        const transferSigningParams = {
            sender_stark_key: signableResultData.sender_stark_key || senderStarkKey,
            sender_vault_id: signableResultData.sender_vault_id,
            receiver_stark_key: signableResultData.receiver_stark_key,
            receiver_vault_id: signableResultData.receiver_vault_id,
            asset_id: signableResultData.asset_id,
            amount: signableResultData.amount,
            nonce: signableResultData.nonce,
            expiration_timestamp: signableResultData.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const createTransferRequest = {
            createTransferRequest: transferSigningParams,
        };
        const { data: responseData } = await transfersApi.createTransferV1(createTransferRequest, { headers });
        return {
            sent_signature: responseData.sent_signature,
            status: responseData.status?.toString(),
            time: responseData.time,
            transfer_id: responseData.transfer_id,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}
async function batchNftTransfer({ user, starkSigner, request, transfersApi, guardianClient, }) {
    // eslint-disable-next-line function-paren-newline
    return withPassportError(guardianClient.withConfirmationScreenTask({ width: 480, height: 784 })(async () => {
        const { ethAddress } = user.imx;
        const signableRequests = request.map((nftTransfer) => ({
            amount: '1',
            token: convertToSignableToken({
                type: ERC721,
                tokenId: nftTransfer.tokenId,
                tokenAddress: nftTransfer.tokenAddress,
            }),
            receiver: nftTransfer.receiver,
        }));
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const signableResult = await transfersApi.getSignableTransfer({
            getSignableTransferRequestV2: {
                sender_ether_key: ethAddress,
                signable_requests: signableRequests,
            },
        }, { headers });
        await guardianClient.evaluateImxTransaction({
            user,
            payloadHash: signableResult.data.signable_responses[0]?.payload_hash,
        });
        const requests = await Promise.all(signableResult.data.signable_responses.map(async (resp) => {
            const starkSignature = await starkSigner.signMessage(resp.payload_hash);
            return {
                sender_vault_id: resp.sender_vault_id,
                receiver_stark_key: resp.receiver_stark_key,
                receiver_vault_id: resp.receiver_vault_id,
                asset_id: resp.asset_id,
                amount: resp.amount,
                nonce: resp.nonce,
                expiration_timestamp: resp.expiration_timestamp,
                stark_signature: starkSignature,
            };
        }));
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key,
            requests,
        };
        const response = await transfersApi.createTransfer({
            createTransferRequestV2: transferSigningParams,
        }, { headers });
        return {
            transfer_ids: response?.data.transfer_ids,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}

async function forceUserRefresh(authManager) {
    // User metadata is updated asynchronously. Poll userinfo endpoint until it is updated.
    await retryWithDelay(async () => {
        const user = await authManager.forceUserRefresh(); // force refresh to get updated user info
        if (user?.imx)
            return user;
        return Promise.reject(new Error('user wallet addresses not exist'));
    });
}
async function registerOffchain$1(userAdminKeySigner, starkSigner, unregisteredUser, authManager, usersApi) {
    return withPassportError(async () => {
        try {
            const response = await registerPassport({
                ethSigner: userAdminKeySigner,
                starkSigner,
                usersApi,
            }, unregisteredUser.accessToken);
            await forceUserRefresh(authManager);
            return response;
        }
        catch (err) {
            if (globalAxios$1.isAxiosError(err) && err.status === 409) {
                // The user already registered, but the user token is not updated yet.
                await forceUserRefresh(authManager);
                return { tx_hash: '' };
            }
            throw err;
        }
    }, PassportErrorType.USER_REGISTRATION_ERROR);
}

class PassportImxProvider {
    authManager;
    immutableXClient;
    guardianClient;
    magicAdapter;
    /**
     * This property is set during initialisation and stores the signers in a promise.
     * This property is not meant to be accessed directly, but through the
     * `getAuthenticatedUserAndSigners` method.
     * @see getAuthenticatedUserAndSigners
     */
    signers;
    signerInitialisationError;
    constructor({ authManager, immutableXClient, confirmationScreen, config, passportEventEmitter, magicAdapter, }) {
        this.authManager = authManager;
        this.immutableXClient = immutableXClient;
        this.guardianClient = new GuardianClient({
            confirmationScreen,
            config,
        });
        this.magicAdapter = magicAdapter;
        this.initialiseSigners();
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        this.signers = undefined;
    };
    /**
     * This method is called by the constructor and asynchronously initialises the signers.
     * The signers are stored in a promise so that they can be retrieved by the provider
     * when needed.
     *
     * If an error is thrown during initialisation, it is stored in the `signerInitialisationError`,
     * so that it doesn't result in an unhandled promise rejection.
     *
     * This error is thrown when the signers are requested through:
     * @see getAuthenticatedUserAndSigners
     *
     */
    async initialiseSigners() {
        const generateSigners = async () => {
            const user = await this.authManager.getUser();
            // The user will be present because the factory validates it
            const magicRpcProvider = await this.magicAdapter.login(user.idToken);
            const web3Provider = new Web3Provider(magicRpcProvider);
            const ethSigner = web3Provider.getSigner();
            const starkSigner = await getStarkSigner(ethSigner);
            return { ethSigner, starkSigner };
        };
        // eslint-disable-next-line no-async-promise-executor
        this.signers = new Promise(async (resolve) => {
            try {
                resolve(await generateSigners());
            }
            catch (err) {
                // Capture and store the initialization error
                this.signerInitialisationError = err;
                resolve(undefined);
            }
        });
    }
    async getAuthenticatedUserAndSigners() {
        const user = await this.authManager.getUser();
        if (!user || !this.signers) {
            throw new PassportError('User has been logged out', PassportErrorType.NOT_LOGGED_IN_ERROR);
        }
        const signers = await this.signers;
        // Throw the stored error if the signers failed to initialise
        if (typeof signers === 'undefined') {
            if (typeof this.signerInitialisationError !== 'undefined') {
                throw this.signerInitialisationError;
            }
            throw new Error('Signers failed to initialise');
        }
        return { user, ...signers };
    }
    async getRegisteredImxUserAndSigners() {
        const { user, starkSigner, ethSigner } = await this.getAuthenticatedUserAndSigners();
        const isUserImx = (oidcUser) => oidcUser?.imx !== undefined;
        if (!isUserImx(user)) {
            throw new PassportError('User has not been registered with StarkEx', PassportErrorType.USER_NOT_REGISTERED_ERROR);
        }
        return { user, starkSigner, ethSigner };
    }
    async transfer(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return transfer$1({
            request,
            user,
            starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    async registerOffchain() {
        const { user, ethSigner, starkSigner } = await this.getAuthenticatedUserAndSigners();
        return await registerOffchain$1(ethSigner, starkSigner, user, this.authManager, this.immutableXClient.usersApi);
    }
    async isRegisteredOffchain() {
        const { user } = await this.getAuthenticatedUserAndSigners();
        return !!user.imx;
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    isRegisteredOnchain() {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    async createOrder(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return createOrder$1({
            request,
            user,
            starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    async cancelOrder(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return cancelOrder$1({
            request,
            user,
            starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    async createTrade(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return createTrade$1({
            request,
            user,
            starkSigner,
            tradesApi: this.immutableXClient.tradesApi,
            guardianClient: this.guardianClient,
        });
    }
    async batchNftTransfer(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return batchNftTransfer({
            request,
            user,
            starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    async exchangeTransfer(request) {
        const { user, starkSigner } = await this.getRegisteredImxUserAndSigners();
        return exchangeTransfer$1({
            request,
            user,
            starkSigner,
            exchangesApi: this.immutableXClient.exchangeApi,
        });
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    deposit(deposit) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    prepareWithdrawal(request) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    completeWithdrawal(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    starkPublicKey, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    token) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    async getAddress() {
        const { user } = await this.getRegisteredImxUserAndSigners();
        return Promise.resolve(user.imx.ethAddress);
    }
}

class PassportImxProviderFactory {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    passportEventEmitter;
    constructor({ authManager, config, confirmationScreen, immutableXClient, magicAdapter, passportEventEmitter, }) {
        this.authManager = authManager;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        this.immutableXClient = immutableXClient;
        this.magicAdapter = magicAdapter;
        this.passportEventEmitter = passportEventEmitter;
    }
    async getProvider() {
        let user = null;
        try {
            user = await this.authManager.getUser();
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.warn(e);
        }
        if (!user) {
            user = await this.authManager.login();
        }
        return this.createProviderInstance(user);
    }
    async getProviderSilent() {
        const user = await this.authManager.getUser();
        if (!user) {
            return null;
        }
        return this.createProviderInstance(user);
    }
    async createProviderInstance(user) {
        if (!user.idToken) {
            throw new PassportError('Failed to initialise', PassportErrorType.WALLET_CONNECTION_ERROR);
        }
        return new PassportImxProvider({
            config: this.config,
            authManager: this.authManager,
            immutableXClient: this.immutableXClient,
            confirmationScreen: this.confirmationScreen,
            passportEventEmitter: this.passportEventEmitter,
            magicAdapter: this.magicAdapter,
        });
    }
}

const validateConfiguration = (configuration, requiredKeys, prefix) => {
    const missingKeys = requiredKeys
        .map((key) => !configuration[key] && key)
        .filter((n) => n)
        .join(', ');
    if (missingKeys !== '') {
        const errorMessage = prefix
            ? `${prefix} - ${missingKeys} cannot be null`
            : `${missingKeys} cannot be null`;
        throw new PassportError(errorMessage, PassportErrorType.INVALID_CONFIGURATION);
    }
};
class PassportConfiguration {
    network;
    authenticationDomain;
    passportDomain;
    imxPublicApiDomain;
    magicPublishableApiKey;
    magicProviderId;
    oidcConfiguration;
    baseConfig;
    zkEvmRpcUrl;
    relayerUrl;
    multiRollupConfig;
    crossSdkBridgeEnabled;
    constructor({ baseConfig, overrides, crossSdkBridgeEnabled, ...oidcConfiguration }) {
        validateConfiguration(oidcConfiguration, [
            'clientId',
            'redirectUri',
        ]);
        this.oidcConfiguration = oidcConfiguration;
        this.baseConfig = baseConfig;
        this.crossSdkBridgeEnabled = crossSdkBridgeEnabled || false;
        if (overrides) {
            validateConfiguration(overrides, [
                'network',
                'authenticationDomain',
                'passportDomain',
                'magicPublishableApiKey',
                'magicProviderId',
                'zkEvmRpcUrl',
                'relayerUrl',
                'imxPublicApiDomain',
                'indexerMrBasePath',
                'orderBookMrBasePath',
                'passportMrBasePath',
            ], 'overrides');
            this.network = overrides.network;
            this.authenticationDomain = overrides.authenticationDomain;
            this.passportDomain = overrides.passportDomain;
            this.imxPublicApiDomain = overrides.imxPublicApiDomain;
            this.magicPublishableApiKey = overrides.magicPublishableApiKey;
            this.magicProviderId = overrides.magicProviderId;
            this.zkEvmRpcUrl = overrides.zkEvmRpcUrl;
            this.relayerUrl = overrides.relayerUrl;
            this.multiRollupConfig = {
                indexer: createConfig({
                    basePath: overrides.indexerMrBasePath,
                }),
                orderBook: createConfig({
                    basePath: overrides.orderBookMrBasePath,
                }),
                passport: createConfig({
                    basePath: overrides.passportMrBasePath,
                }),
            };
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.PRODUCTION: {
                    this.network = Networks.PRODUCTION;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.immutable.com';
                    this.imxPublicApiDomain = 'https://api.immutable.com';
                    this.zkEvmRpcUrl = ''; // TODO: ID-785 Update once mainnet has been deployed
                    this.relayerUrl = 'https://api.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getProduction();
                    break;
                }
                case Environment$1.SANDBOX:
                default: {
                    this.network = Networks.SANDBOX;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.sandbox.immutable.com';
                    this.imxPublicApiDomain = 'https://api.sandbox.immutable.com';
                    this.zkEvmRpcUrl = 'https://rpc.testnet.immutable.com';
                    this.relayerUrl = 'https://api.sandbox.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getSandbox();
                    break;
                }
            }
        }
    }
}

var ReceiveMessage;
(function (ReceiveMessage) {
    ReceiveMessage["CONFIRMATION_WINDOW_READY"] = "confirmation_window_ready";
    ReceiveMessage["TRANSACTION_CONFIRMED"] = "transaction_confirmed";
    ReceiveMessage["TRANSACTION_ERROR"] = "transaction_error";
    ReceiveMessage["MESSAGE_CONFIRMED"] = "message_confirmed";
    ReceiveMessage["MESSAGE_REJECTED"] = "message_rejected";
    ReceiveMessage["LOGOUT_SUCCESS"] = "logout_success";
})(ReceiveMessage || (ReceiveMessage = {}));
const PASSPORT_EVENT_TYPE = 'imx_passport_confirmation';

const openPopupCenter = ({ url, title, width, height, }) => {
    const left = Math.max(0, Math.round(window.screenX + (window.outerWidth - width) / 2));
    const top = Math.max(0, Math.round(window.screenY + (window.outerHeight - height) / 2));
    const newWindow = window.open(url, title, `
      scrollbars=yes,
      width=${width}, 
      height=${height}, 
      top=${top}, 
      left=${left}
     `);
    if (!newWindow) {
        throw new Error('Failed to open confirmation screen');
    }
    newWindow.focus();
    return newWindow;
};

const CONFIRMATION_WINDOW_TITLE = 'Confirm this transaction';
const CONFIRMATION_WINDOW_HEIGHT = 380;
const CONFIRMATION_WINDOW_WIDTH = 480;
const CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION = 1000;
const CONFIRMATION_IFRAME_ID = 'passport-confirm';
const CONFIRMATION_IFRAME_STYLE = 'display: none; position: absolute;width:0px;height:0px;border:0;';
class ConfirmationScreen {
    config;
    confirmationWindow;
    constructor(config) {
        this.config = config;
    }
    getHref(relativePath, queryStringParams) {
        let href = `${this.config.passportDomain}/transaction-confirmation/${relativePath}`;
        if (queryStringParams) {
            const queryString = queryStringParams
                ? Object.keys(queryStringParams)
                    .map((key) => `${key}=${queryStringParams[key]}`)
                    .join('&')
                : '';
            href = `${href}?${queryString}`;
        }
        return href;
    }
    requestConfirmation(transactionId, etherAddress, chainType, chainId) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_ERROR: {
                        reject(new Error('Transaction error'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            let href = '';
            if (chainType === TransactionApprovalRequestChainTypeEnum.Starkex) {
                href = this.getHref('transaction', { transactionId, etherAddress, chainType });
            }
            else {
                href = this.getHref('zkevm', {
                    transactionId, etherAddress, chainType, chainId,
                });
            }
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    requestMessageConfirmation(messageID, etherAddress) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.MESSAGE_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.MESSAGE_REJECTED: {
                        reject(new Error('Message rejected'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            const href = this.getHref('zkevm/message', { messageID, etherAddress });
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    loading(popupOptions) {
        if (this.config.crossSdkBridgeEnabled) {
            // There is no need to open a confirmation window if cross-sdk bridge is enabled
            return;
        }
        this.confirmationWindow = openPopupCenter({
            url: this.getHref('loading'),
            title: CONFIRMATION_WINDOW_TITLE,
            width: popupOptions?.width || CONFIRMATION_WINDOW_WIDTH,
            height: popupOptions?.height || CONFIRMATION_WINDOW_HEIGHT,
        });
    }
    closeWindow() {
        this.confirmationWindow?.close();
    }
    logout() {
        return new Promise((resolve, rejects) => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('id', CONFIRMATION_IFRAME_ID);
            iframe.setAttribute('src', this.getHref('logout'));
            iframe.setAttribute('style', CONFIRMATION_IFRAME_STYLE);
            const logoutHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                window.removeEventListener('message', logoutHandler);
                iframe.remove();
                if (data.messageType === ReceiveMessage.LOGOUT_SUCCESS) {
                    resolve({ logout: true });
                }
                rejects(new Error('Unsupported logout type'));
            };
            window.addEventListener('message', logoutHandler);
            document.body.appendChild(iframe);
        });
    }
    showConfirmationScreen(href, messageHandler, resolve) {
        this.confirmationWindow.location.href = href;
        // https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript/48240128#48240128
        const timer = setInterval(() => {
            if (this.confirmationWindow?.closed) {
                clearInterval(timer);
                window.removeEventListener('message', messageHandler);
                resolve({ confirmed: false });
            }
        }, CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION);
    }
}

var RelayerTransactionStatus;
(function (RelayerTransactionStatus) {
    RelayerTransactionStatus["PENDING"] = "PENDING";
    RelayerTransactionStatus["SUBMITTED"] = "SUBMITTED";
    RelayerTransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
    RelayerTransactionStatus["REVERTED"] = "REVERTED";
    RelayerTransactionStatus["FAILED"] = "FAILED";
})(RelayerTransactionStatus || (RelayerTransactionStatus = {}));
var ProviderEvent;
(function (ProviderEvent) {
    ProviderEvent["ACCOUNTS_CHANGED"] = "accountsChanged";
})(ProviderEvent || (ProviderEvent = {}));

class TypedEventEmitter {
    emitter = new EventEmitter();
    emit(eventName, ...eventArg) {
        this.emitter.emit(eventName, ...eventArg);
    }
    on(eventName, handler) {
        this.emitter.on(eventName, handler);
    }
    removeListener(eventName, handler) {
        this.emitter.removeListener(eventName, handler);
    }
}

const SIGNATURE_WEIGHT = 1; // Weight of a single signature in the multi-sig
const TRANSACTION_SIGNATURE_THRESHOLD = 1; // Total required weight in the multi-sig for a transaction
const EIP712_SIGNATURE_THRESHOLD = 2; // Total required weight in the multi-sig for data signing
const ETH_SIGN_FLAG = '02';
const ETH_SIGN_PREFIX = '\x19\x01';
const META_TRANSACTIONS_TYPE = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function getNormalisedTransactions(txs) {
    return txs.map((t) => ({
        delegateCall: t.delegateCall === true,
        revertOnError: t.revertOnError === true,
        gasLimit: t.gasLimit ?? ethers.constants.Zero,
        target: t.to ?? ethers.constants.AddressZero,
        value: t.value ?? ethers.constants.Zero,
        data: t.data ?? [],
    }));
}
function digestOfTransactionsAndNonce(nonce, normalisedTransactions) {
    const packMetaTransactionsNonceData = ethers.utils.defaultAbiCoder.encode(['uint256', META_TRANSACTIONS_TYPE], [nonce, normalisedTransactions]);
    return ethers.utils.keccak256(packMetaTransactionsNonceData);
}
const getNonce = async (jsonRpcProvider, smartContractWalletAddress) => {
    const code = await jsonRpcProvider.send('eth_getCode', [smartContractWalletAddress, 'latest']);
    if (code && code !== '0x') {
        const contract = new ethers.Contract(smartContractWalletAddress, walletContracts.mainModule.abi, jsonRpcProvider);
        return contract.nonce();
    }
    return 0;
};
const encodeMessageSubDigest = (chainId, walletAddress, digest) => (ethers.utils.solidityPack(['string', 'uint256', 'address', 'bytes32'], [ETH_SIGN_PREFIX, chainId, walletAddress, digest]));
const getSignedMetaTransactions = async (metaTransactions, nonce, chainId, walletAddress, signer) => {
    const normalisedMetaTransactions = getNormalisedTransactions(metaTransactions);
    // Get the hash
    const digest = digestOfTransactionsAndNonce(nonce, normalisedMetaTransactions);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    // Add metadata
    const encodedSignature = v1.signature.encodeSignature({
        version: 1,
        threshold: TRANSACTION_SIGNATURE_THRESHOLD,
        signers: [
            {
                isDynamic: false,
                unrecovered: true,
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
    // Encode the transaction;
    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
    return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [
        normalisedMetaTransactions,
        nonce,
        encodedSignature,
    ]);
};
const decodeRelayerTypedDataSignature = (relayerSignature) => {
    const signatureWithThreshold = `0x0000${relayerSignature}`;
    return v1.signature.decodeSignature(signatureWithThreshold);
};
const getSignedTypedData = async (typedData, relayerSignature, chainId, walletAddress, signer) => {
    // Ethers auto-generates the EIP712Domain type in the TypedDataEncoder, and so it needs to be removed
    const types = { ...typedData.types };
    // @ts-ignore
    delete types.EIP712Domain;
    // eslint-disable-next-line no-underscore-dangle
    const digest = ethers.utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    const { signers } = decodeRelayerTypedDataSignature(relayerSignature);
    return v1.signature.encodeSignature({
        version: 1,
        threshold: EIP712_SIGNATURE_THRESHOLD,
        signers: [
            ...signers,
            {
                isDynamic: false,
                unrecovered: true,
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
};
const getEip155ChainId = (chainId) => `eip155:${chainId}`;

class RelayerClient {
    config;
    jsonRpcProvider;
    user;
    constructor({ config, jsonRpcProvider, user }) {
        this.config = config;
        this.jsonRpcProvider = jsonRpcProvider;
        this.user = user;
    }
    async postToRelayer(request) {
        const body = {
            id: 1,
            jsonrpc: '2.0',
            ...request,
        };
        const response = await fetch(`${this.config.relayerUrl}/v1/transactions`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this.user.accessToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });
        const jsonResponse = await response.json();
        if (jsonResponse.error) {
            throw jsonResponse.error;
        }
        return jsonResponse;
    }
    async ethSendTransaction(to, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'eth_sendTransaction',
            params: [{
                    to,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetTransactionByHash(hash) {
        const payload = {
            method: 'im_getTransactionByHash',
            params: [hash],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetFeeOptions(userAddress, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_getFeeOptions',
            params: [{
                    userAddress,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imSignTypedData(address, eip712Payload) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_signTypedData',
            params: [{
                    address,
                    eip712Payload,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
}

const CHAIN_NAME_MAP = new Map([
    [
        ChainId$1.ETHEREUM,
        ChainName$1.ETHEREUM,
    ],
    [
        ChainId$1.SEPOLIA,
        ChainName$1.SEPOLIA,
    ],
    [
        ChainId$1.IMTBL_ZKEVM_MAINNET,
        ChainName$1.IMTBL_ZKEVM_MAINNET,
    ],
    [
        ChainId$1.IMTBL_ZKEVM_TESTNET,
        ChainName$1.IMTBL_ZKEVM_TESTNET,
    ],
    [
        ChainId$1.IMTBL_ZKEVM_DEVNET,
        ChainName$1.IMTBL_ZKEVM_DEVNET,
    ],
]);

const MESSAGE_TO_SIGN = 'Only sign this message from Immutable Passport';
async function registerZkEvmUser({ authManager, magicProvider, multiRollupApiClients, accessToken, jsonRpcProvider, }) {
    const web3Provider = new Web3Provider(magicProvider);
    const ethSigner = web3Provider.getSigner();
    const ethereumAddress = await ethSigner.getAddress();
    const ethereumSignature = await signRaw(MESSAGE_TO_SIGN, ethSigner);
    const headers = { Authorization: `Bearer ${accessToken}` };
    const { chainId } = await jsonRpcProvider.ready;
    try {
        const chainName = CHAIN_NAME_MAP.get(chainId);
        if (!chainName) {
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Chain name does not exist on for chain id ${chainId}`);
        }
        await multiRollupApiClients.passportApi.createCounterfactualAddress({
            chainName,
            createCounterfactualAddressRequest: {
                ethereum_address: ethereumAddress,
                ethereum_signature: ethereumSignature,
            },
        }, { headers });
    }
    catch (error) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Failed to create counterfactual address: ${error}`);
    }
    const user = await authManager.forceUserRefresh();
    if (!user?.zkEvm) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Failed to refresh user details');
    }
    return user;
}

const loginZkEvmUser = async ({ authManager, magicAdapter, multiRollupApiClients, jsonRpcProvider, }) => {
    let user = null;
    try {
        user = await authManager.getUser();
    }
    catch (err) {
        // eslint-disable-next-line no-console
        console.warn('eth_requestAccounts` failed to retrieve a cached user session:', err);
    }
    if (!user) {
        user = await authManager.login();
    }
    if (!user.idToken) {
        throw new Error('User is missing idToken');
    }
    const magicProvider = await magicAdapter.login(user.idToken);
    if (!user.zkEvm) {
        // Generate counterfactual address and retrieve updated Auth0 user
        const userZkevm = await registerZkEvmUser({
            authManager,
            magicProvider,
            multiRollupApiClients,
            accessToken: user.accessToken,
            jsonRpcProvider,
        });
        return {
            user: userZkevm,
            magicProvider,
        };
    }
    return {
        user: user,
        magicProvider,
    };
};

const MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES = 30;
const TRANSACTION_HASH_RETRIEVAL_WAIT = 1000;
const getMetaTransactions = async (metaTransaction, nonce, chainId, walletAddress, signer, relayerClient) => {
    // NOTE: We sign the transaction before getting the fee options because
    // accurate estimation of a transaction gas cost is only possible if the smart
    // wallet contract can actually execute it (in a simulated environment) - and
    // it can only execute signed transactions.
    const signedTransaction = await getSignedMetaTransactions([metaTransaction], nonce, chainId, walletAddress, signer);
    // TODO: ID-698 Add support for non-native gas payments (e.g ERC20, feeTransaction initialisation must change)
    // NOTE: "Fee Options" represent the multiple ways we could pay for the gas
    // used in this transaction. Each fee option has a "recipientAddress" we
    // should transfer the payment to, an amount and a currency. We choose one
    // option and build a transaction that sends the expected currency amount for
    // that option to the specified address.
    const feeOptions = await relayerClient.imGetFeeOptions(walletAddress, signedTransaction);
    const imxFeeOption = feeOptions.find((feeOption) => feeOption.tokenSymbol === 'IMX');
    if (!imxFeeOption) {
        throw new Error('Failed to retrieve fees for IMX token');
    }
    const feeMetaTransaction = {
        nonce,
        to: imxFeeOption.recipientAddress,
        value: imxFeeOption.tokenPrice,
        revertOnError: true,
    };
    if (BigNumber$1.from(feeMetaTransaction.value).isZero()) {
        return [metaTransaction];
    }
    return [metaTransaction, feeMetaTransaction];
};
const sendTransaction$1 = ({ params, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 520 })(async () => {
    const transactionRequest = params[0];
    if (!transactionRequest.to) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, 'eth_sendTransaction requires a "to" field');
    }
    const { chainId } = await jsonRpcProvider.ready;
    const chainIdBigNumber = BigNumber$1.from(chainId);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    const nonce = await getNonce(jsonRpcProvider, user.zkEvm.ethAddress);
    const metaTransaction = {
        to: transactionRequest.to,
        data: transactionRequest.data,
        nonce,
        value: transactionRequest.value,
        revertOnError: true,
    };
    const metaTransactions = await getMetaTransactions(metaTransaction, nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer, relayerClient);
    await guardianClient.validateEVMTransaction({
        chainId: getEip155ChainId(chainId),
        nonce: convertBigNumberishToString(nonce),
        user,
        metaTransactions,
    });
    // NOTE: We sign again because we now are adding the fee transaction, so the
    // whole payload is different and needs a new signature.
    const signedTransactions = await getSignedMetaTransactions(metaTransactions, nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer);
    const relayerId = await relayerClient.ethSendTransaction(user.zkEvm.ethAddress, signedTransactions);
    const retrieveRelayerTransaction = async () => {
        const tx = await relayerClient.imGetTransactionByHash(relayerId);
        // NOTE: The transaction hash is only available from the Relayer once the
        // transaction is actually submitted onchain. Hence we need to poll the
        // Relayer get transaction endpoint until the status transitions to one that
        // has the hash available.
        if (tx.status === RelayerTransactionStatus.PENDING) {
            throw new Error();
        }
        return tx;
    };
    const relayerTransaction = await retryWithDelay(retrieveRelayerTransaction, {
        retries: MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES,
        interval: TRANSACTION_HASH_RETRIEVAL_WAIT,
        finalErr: new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, 'transaction hash not generated in time'),
    });
    if (![
        RelayerTransactionStatus.SUBMITTED,
        RelayerTransactionStatus.SUCCESSFUL,
    ].includes(relayerTransaction.status)) {
        let errorMessage = `Transaction failed to submit with status ${relayerTransaction.status}.`;
        if (relayerTransaction.statusMessage) {
            errorMessage += ` Error message: ${relayerTransaction.statusMessage}`;
        }
        throw new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, errorMessage);
    }
    return relayerTransaction.hash;
});

const REQUIRED_TYPED_DATA_PROPERTIES = ['types', 'domain', 'primaryType', 'message'];
const isValidTypedDataPayload = (typedData) => (REQUIRED_TYPED_DATA_PROPERTIES.every((key) => key in typedData));
const transformTypedData = (typedData, chainId) => {
    let transformedTypedData;
    if (typeof typedData === 'string') {
        try {
            transformedTypedData = JSON.parse(typedData);
        }
        catch (err) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Failed to parse typed data JSON: ${err}`);
        }
    }
    else if (typeof typedData === 'object') {
        transformedTypedData = typedData;
    }
    else {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument: ${typedData}`);
    }
    if (!isValidTypedDataPayload(transformedTypedData)) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument. The following properties are required: ${REQUIRED_TYPED_DATA_PROPERTIES.join(', ')}`);
    }
    const providedChainId = transformedTypedData.domain?.chainId;
    if (providedChainId) {
        // domain.chainId (if defined) can be a number, string, or hex value, but the relayer & guardian only accept a number.
        if (typeof providedChainId === 'string') {
            if (providedChainId.startsWith('0x')) {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 16);
            }
            else {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 10);
            }
        }
        if (transformedTypedData.domain.chainId !== chainId) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid chainId, expected ${chainId}`);
        }
    }
    return transformedTypedData;
};
const signTypedDataV4 = async ({ params, method, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 730 })(async () => {
    const fromAddress = params[0];
    const typedDataParam = params[1];
    if (!fromAddress || !typedDataParam) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `${method} requires an address and a typed data JSON`);
    }
    const { chainId } = await jsonRpcProvider.ready;
    const typedData = transformTypedData(typedDataParam, chainId);
    await guardianClient.validateMessage({ chainID: String(chainId), payload: typedData, user });
    const relayerSignature = await relayerClient.imSignTypedData(fromAddress, typedData);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    return getSignedTypedData(typedData, relayerSignature, BigNumber$1.from(chainId), fromAddress, signer);
});

class ZkEvmProvider {
    authManager;
    config;
    confirmationScreen;
    magicAdapter;
    multiRollupApiClients;
    jsonRpcProvider; // Used for read
    eventEmitter;
    guardianClient;
    relayerClient;
    magicProvider; // Used for signing
    user;
    isPassport = true;
    constructor({ authManager, magicAdapter, config, confirmationScreen, multiRollupApiClients, passportEventEmitter, }) {
        this.authManager = authManager;
        this.magicAdapter = magicAdapter;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        if (config.crossSdkBridgeEnabled) {
            // JsonRpcProvider by default sets the referrer as "client".
            // On Unreal 4 this errors as the browser used is expecting a valid URL.
            this.jsonRpcProvider = new JsonRpcProvider({
                url: this.config.zkEvmRpcUrl,
                fetchOptions: { referrer: 'http://imtblgamesdk.local' },
            });
        }
        else {
            this.jsonRpcProvider = new JsonRpcProvider(this.config.zkEvmRpcUrl);
        }
        this.multiRollupApiClients = multiRollupApiClients;
        this.eventEmitter = new TypedEventEmitter();
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        const shouldEmitAccountsChanged = this.isLoggedIn();
        this.magicProvider = undefined;
        this.user = undefined;
        this.relayerClient = undefined;
        this.guardianClient = undefined;
        if (shouldEmitAccountsChanged) {
            this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, []);
        }
    };
    isLoggedIn() {
        return this.magicProvider !== undefined
            && this.user !== undefined
            && this.relayerClient !== undefined
            && this.guardianClient !== undefined;
    }
    async performRequest(request) {
        switch (request.method) {
            case 'eth_requestAccounts': {
                if (this.isLoggedIn()) {
                    return [this.user.zkEvm.ethAddress];
                }
                const { magicProvider, user } = await loginZkEvmUser({
                    authManager: this.authManager,
                    config: this.config,
                    magicAdapter: this.magicAdapter,
                    multiRollupApiClients: this.multiRollupApiClients,
                    jsonRpcProvider: this.jsonRpcProvider,
                });
                this.user = user;
                this.magicProvider = magicProvider;
                this.relayerClient = new RelayerClient({
                    config: this.config,
                    jsonRpcProvider: this.jsonRpcProvider,
                    user: this.user,
                });
                this.guardianClient = new GuardianClient({
                    confirmationScreen: this.confirmationScreen,
                    config: this.config,
                });
                this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, [this.user.zkEvm.ethAddress]);
                return [this.user.zkEvm.ethAddress];
            }
            case 'eth_sendTransaction': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return sendTransaction$1({
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    guardianClient: this.guardianClient,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                });
            }
            case 'eth_accounts': {
                return this.isLoggedIn() ? [this.user.zkEvm.ethAddress] : [];
            }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v4': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return signTypedDataV4({
                    method: request.method,
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                    guardianClient: this.guardianClient,
                });
            }
            // Pass through methods
            case 'eth_gasPrice':
            case 'eth_getBalance':
            case 'eth_getCode':
            case 'eth_getStorageAt':
            case 'eth_estimateGas':
            case 'eth_call':
            case 'eth_blockNumber':
            case 'eth_chainId':
            case 'eth_getBlockByHash':
            case 'eth_getBlockByNumber':
            case 'eth_getTransactionByHash':
            case 'eth_getTransactionReceipt':
            case 'eth_getTransactionCount': {
                return this.jsonRpcProvider.send(request.method, request.params || []);
            }
            default: {
                throw new JsonRpcError(ProviderErrorCode.UNSUPPORTED_METHOD, 'Method not supported');
            }
        }
    }
    async performJsonRpcRequest(request) {
        const { id, jsonrpc } = request;
        try {
            const result = await this.performRequest(request);
            return {
                id,
                jsonrpc,
                result,
            };
        }
        catch (error) {
            let jsonRpcError;
            if (error instanceof JsonRpcError) {
                jsonRpcError = error;
            }
            else if (error instanceof Error) {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            else {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
            }
            return {
                id,
                jsonrpc,
                error: jsonRpcError,
            };
        }
    }
    async request(request) {
        try {
            return this.performRequest(request);
        }
        catch (error) {
            if (error instanceof JsonRpcError) {
                throw error;
            }
            if (error instanceof Error) {
                throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
        }
    }
    sendAsync(request, callback) {
        if (!callback) {
            throw new Error('No callback provided');
        }
        if (Array.isArray(request)) {
            Promise.all(request.map(this.performJsonRpcRequest)).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, []);
            });
        }
        else {
            this.performJsonRpcRequest(request).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, null);
            });
        }
    }
    async send(request, callbackOrParams, callback) {
        // Web3 >= 1.0.0-beta.38 calls `send` with method and parameters.
        if (typeof request === 'string') {
            if (typeof callbackOrParams === 'function') {
                return this.sendAsync({
                    method: request,
                    params: [],
                }, callbackOrParams);
            }
            if (callback) {
                return this.sendAsync({
                    method: request,
                    params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
                }, callback);
            }
            return this.request({
                method: request,
                params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
            });
        }
        // Web3 <= 1.0.0-beta.37 uses `send` with a callback for async queries.
        if (typeof callbackOrParams === 'function') {
            return this.sendAsync(request, callbackOrParams);
        }
        if (!Array.isArray(request) && typeof request === 'object') {
            return this.performJsonRpcRequest(request);
        }
        throw new JsonRpcError(RpcErrorCode.INVALID_REQUEST, 'Invalid request');
    }
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    removeListener(event, listener) {
        this.eventEmitter.removeListener(event, listener);
    }
}

class Passport {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    multiRollupApiClients;
    passportImxProviderFactory;
    passportEventEmitter;
    constructor(passportModuleConfiguration) {
        this.config = new PassportConfiguration(passportModuleConfiguration);
        this.authManager = new AuthManager(this.config);
        this.magicAdapter = new MagicAdapter(this.config);
        this.confirmationScreen = new ConfirmationScreen(this.config);
        this.immutableXClient = passportModuleConfiguration.overrides?.immutableXClient
            || new ImmutableXClient({
                baseConfig: passportModuleConfiguration.baseConfig,
            });
        this.multiRollupApiClients = new MultiRollupApiClients(this.config.multiRollupConfig);
        this.passportEventEmitter = new TypedEventEmitter();
        this.passportImxProviderFactory = new PassportImxProviderFactory({
            authManager: this.authManager,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            immutableXClient: this.immutableXClient,
            magicAdapter: this.magicAdapter,
            passportEventEmitter: this.passportEventEmitter,
        });
    }
    /**
     * @deprecated The method `login` with an argument of `{ useCachedSession: true }` should be used in conjunction with
     * `connectImx` instead.
     */
    async connectImxSilent() {
        return this.passportImxProviderFactory.getProviderSilent();
    }
    async connectImx() {
        return this.passportImxProviderFactory.getProvider();
    }
    connectEvm() {
        if (this.config.network === Networks.PRODUCTION) {
            throw new Error('EVM is not supported on production network');
        }
        return new ZkEvmProvider({
            passportEventEmitter: this.passportEventEmitter,
            authManager: this.authManager,
            magicAdapter: this.magicAdapter,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            multiRollupApiClients: this.multiRollupApiClients,
        });
    }
    /**
     *
     * Initiates the authorisation flow.
     *
     * @param options.useCachedSession = false - If true, and no active session exists, then the user will not be
     * prompted to log in and the Promise will resolve with a null value.
     * @returns {Promise<UserProfile | null>} the user profile if the user is logged in, otherwise null
     */
    async login(options) {
        const { useCachedSession = false } = options || {};
        let user = null;
        try {
            user = await this.authManager.getUser();
        }
        catch (error) {
            if (useCachedSession) {
                throw error;
            }
            // eslint-disable-next-line no-console
            console.warn('login failed to retrieve a cached user session', error);
        }
        if (!user && !useCachedSession) {
            user = await this.authManager.login();
        }
        return user ? user.profile : null;
    }
    async loginCallback() {
        return this.authManager.loginCallback();
    }
    async loginWithDeviceFlow() {
        return this.authManager.loginWithDeviceFlow();
    }
    async loginWithDeviceFlowCallback(deviceCode, interval, timeoutMs) {
        const user = await this.authManager.loginWithDeviceFlowCallback(deviceCode, interval, timeoutMs);
        return user.profile;
    }
    loginWithPKCEFlow() {
        return this.authManager.getPKCEAuthorizationUrl();
    }
    async loginWithPKCEFlowCallback(authorizationCode, state) {
        const user = await this.authManager.loginWithPKCEFlowCallback(authorizationCode, state);
        return user.profile;
    }
    async logout() {
        await this.confirmationScreen.logout();
        await this.authManager.logout();
        // Code after this point is only executed if the logout mode is silent
        await this.magicAdapter.logout();
        this.passportEventEmitter.emit(PassportEvents.LOGGED_OUT);
    }
    /**
     * Logs the user out of Passport when using device flow authentication.
     *
     * @returns {Promise<string>} The device flow end session endpoint. Consumers are responsible for
     * opening this URL in the same browser that was used to log the user in.
     */
    async logoutDeviceFlow() {
        await this.authManager.removeUser();
        await this.magicAdapter.logout();
        this.passportEventEmitter.emit(PassportEvents.LOGGED_OUT);
        return this.authManager.getDeviceFlowEndSessionEndpoint();
    }
    /**
     * This method should only be called from the logout redirect uri
     * when logout mode is 'silent'.
     */
    async logoutSilentCallback(url) {
        return this.authManager.logoutSilentCallback(url);
    }
    async getUserInfo() {
        const user = await this.authManager.getUser();
        return user?.profile;
    }
    async getIdToken() {
        const user = await this.authManager.getUser();
        return user?.idToken;
    }
    async getAccessToken() {
        const user = await this.authManager.getUser();
        return user?.accessToken;
    }
    async getLinkedAddresses() {
        const user = await this.authManager.getUser();
        if (!user?.profile.sub) {
            return [];
        }
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const linkedAddressesResult = await this.multiRollupApiClients.passportApi.getLinkedAddresses({
            chainName: ChainName$1.ETHEREUM,
            userId: user?.profile.sub,
        }, { headers });
        return linkedAddressesResult.data.linked_addresses;
    }
}

var passport = /*#__PURE__*/Object.freeze({
    __proto__: null,
    JsonRpcError: JsonRpcError,
    get Networks () { return Networks; },
    Passport: Passport,
    PassportError: PassportError,
    get ProviderErrorCode () { return ProviderErrorCode; },
    get ProviderEvent () { return ProviderEvent; },
    get RpcErrorCode () { return RpcErrorCode; }
});

class BaseHttpRequest {
    config;
    constructor(config) {
        this.config = config;
    }
}

class ApiError extends Error {
    url;
    status;
    statusText;
    body;
    request;
    constructor(request, response, message) {
        super(message);
        this.name = 'ApiError';
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
class CancelError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CancelError';
    }
    get isCancelled() {
        return true;
    }
}
class CancelablePromise {
    [Symbol.toStringTag];
    _isResolved;
    _isRejected;
    _isCancelled;
    _cancelHandlers;
    _promise;
    _resolve;
    _reject;
    constructor(executor) {
        this._isResolved = false;
        this._isRejected = false;
        this._isCancelled = false;
        this._cancelHandlers = [];
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
            const onResolve = (value) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isResolved = true;
                this._resolve?.(value);
            };
            const onReject = (reason) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isRejected = true;
                this._reject?.(reason);
            };
            const onCancel = (cancelHandler) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._cancelHandlers.push(cancelHandler);
            };
            Object.defineProperty(onCancel, 'isResolved', {
                get: () => this._isResolved,
            });
            Object.defineProperty(onCancel, 'isRejected', {
                get: () => this._isRejected,
            });
            Object.defineProperty(onCancel, 'isCancelled', {
                get: () => this._isCancelled,
            });
            return executor(onResolve, onReject, onCancel);
        });
    }
    then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this._promise.catch(onRejected);
    }
    finally(onFinally) {
        return this._promise.finally(onFinally);
    }
    cancel() {
        if (this._isResolved || this._isRejected || this._isCancelled) {
            return;
        }
        this._isCancelled = true;
        if (this._cancelHandlers.length) {
            try {
                for (const cancelHandler of this._cancelHandlers) {
                    cancelHandler();
                }
            }
            catch (error) {
                console.warn('Cancellation threw an error', error);
                return;
            }
        }
        this._cancelHandlers.length = 0;
        this._reject?.(new CancelError('Request aborted'));
    }
    get isCancelled() {
        return this._isCancelled;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
const isDefined = (value) => {
    return value !== undefined && value !== null;
};
const isString = (value) => {
    return typeof value === 'string';
};
const isStringWithValue = (value) => {
    return isString(value) && value !== '';
};
const isBlob = (value) => {
    return (typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag]));
};
const isFormData = (value) => {
    return value instanceof FormData$2;
};
const isSuccess = (status) => {
    return status >= 200 && status < 300;
};
const base64 = (str) => {
    try {
        return btoa(str);
    }
    catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString('base64');
    }
};
const getQueryString = (params) => {
    const qs = [];
    const append = (key, value) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    const process = (key, value) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(v => {
                    process(key, v);
                });
            }
            else if (typeof value === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            }
            else {
                append(key, value);
            }
        }
    };
    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });
    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }
    return '';
};
const getUrl = (config, options) => {
    const encoder = config.ENCODE_PATH || encodeURI;
    const path = options.url
        .replace('{api-version}', config.VERSION)
        .replace(/{(.*?)}/g, (substring, group) => {
        if (options.path?.hasOwnProperty(group)) {
            return encoder(String(options.path[group]));
        }
        return substring;
    });
    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};
const getFormData = (options) => {
    if (options.formData) {
        const formData = new FormData$2();
        const process = (key, value) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            }
            else {
                formData.append(key, JSON.stringify(value));
            }
        };
        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
            if (Array.isArray(value)) {
                value.forEach(v => process(key, v));
            }
            else {
                process(key, value);
            }
        });
        return formData;
    }
    return undefined;
};
const resolve = async (options, resolver) => {
    if (typeof resolver === 'function') {
        return resolver(options);
    }
    return resolver;
};
const getHeaders = async (config, options, formData) => {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const additionalHeaders = await resolve(options, config.HEADERS);
    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {};
    const headers = Object.entries({
        Accept: 'application/json',
        ...additionalHeaders,
        ...options.headers,
        ...formHeaders,
    })
        .filter(([_, value]) => isDefined(value))
        .reduce((headers, [key, value]) => ({
        ...headers,
        [key]: String(value),
    }), {});
    if (isStringWithValue(token)) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers['Authorization'] = `Basic ${credentials}`;
    }
    if (options.body) {
        if (options.mediaType) {
            headers['Content-Type'] = options.mediaType;
        }
        else if (isBlob(options.body)) {
            headers['Content-Type'] = options.body.type || 'application/octet-stream';
        }
        else if (isString(options.body)) {
            headers['Content-Type'] = 'text/plain';
        }
        else if (!isFormData(options.body)) {
            headers['Content-Type'] = 'application/json';
        }
    }
    return headers;
};
const getRequestBody = (options) => {
    if (options.body) {
        return options.body;
    }
    return undefined;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
    const source = globalAxios$1.CancelToken.source();
    const requestConfig = {
        url,
        headers,
        data: body ?? formData,
        method: options.method,
        withCredentials: config.WITH_CREDENTIALS,
        cancelToken: source.token,
    };
    onCancel(() => source.cancel('The user aborted a request.'));
    try {
        return await globalAxios$1.request(requestConfig);
    }
    catch (error) {
        const axiosError = error;
        if (axiosError.response) {
            return axiosError.response;
        }
        throw error;
    }
};
const getResponseHeader = (response, responseHeader) => {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};
const getResponseBody = (response) => {
    if (response.status !== 204) {
        return response.data;
    }
    return undefined;
};
const catchErrorCodes = (options, result) => {
    const errors = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        ...options.errors,
    };
    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }
    if (!result.ok) {
        throw new ApiError(options, result, 'Generic Error');
    }
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
const request = (config, options) => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options, formData);
            if (!onCancel.isCancelled) {
                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
                const responseBody = getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);
                const result = {
                    url,
                    ok: isSuccess(response.status),
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? responseBody,
                };
                catchErrorCodes(options, result);
                resolve(result.body);
            }
        }
        catch (error) {
            reject(error);
        }
    });
};

class AxiosHttpRequest extends BaseHttpRequest {
    constructor(config) {
        super(config);
    }
    /**
     * Request method
     * @param options The request options from the service
     * @returns CancelablePromise<T>
     * @throws ApiError
     */
    request(options) {
        return request(this.config, options);
    }
}

class OrdersService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Cancel one or more orders
     * Cancel one or more orders
     * @returns CancelOrdersResult Orders cancellation response.
     * @throws ApiError
     */
    cancelOrders({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/cancel',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                401: `Unauthorised Request (401)`,
                404: `The specified resource was not found (404)`,
                429: `Too Many Requests (429)`,
                500: `Internal Server Error (500)`,
                501: `Not Implemented Error (501)`,
            },
        });
    }
    /**
     * List all listings
     * List all listings
     * @returns ListListingsResult OK response.
     * @throws ApiError
     */
    listListings({ chainName, status, sellItemContractAddress, buyItemContractAddress, accountAddress, sellItemMetadataId, sellItemTokenId, fromUpdatedAt, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            query: {
                'status': status,
                'sell_item_contract_address': sellItemContractAddress,
                'buy_item_contract_address': buyItemContractAddress,
                'account_address': accountAddress,
                'sell_item_metadata_id': sellItemMetadataId,
                'sell_item_token_id': sellItemTokenId,
                'from_updated_at': fromUpdatedAt,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Create a listing
     * Create a listing
     * @returns ListingResult Created response.
     * @throws ApiError
     */
    createListing({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single listing by ID
     * Get a single listing by ID
     * @returns ListingResult OK response.
     * @throws ApiError
     */
    getListing({ chainName, listingId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings/{listing_id}',
            path: {
                'chain_name': chainName,
                'listing_id': listingId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Retrieve fulfillment data for orders
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @returns any Successful response
     * @throws ApiError
     */
    fulfillmentData({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/fulfillment-data',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * List all trades
     * List all trades
     * @returns ListTradeResult OK response.
     * @throws ApiError
     */
    listTrades({ chainName, accountAddress, fromIndexedAt, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades',
            path: {
                'chain_name': chainName,
            },
            query: {
                'account_address': accountAddress,
                'from_indexed_at': fromIndexedAt,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single trade by ID
     * Get a single trade by ID
     * @returns TradeResult OK response.
     * @throws ApiError
     */
    getTrade({ chainName, tradeId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades/{trade_id}',
            path: {
                'chain_name': chainName,
                'trade_id': tradeId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
}

class OrderBookClient {
    orders;
    request;
    constructor(config, HttpRequest = AxiosHttpRequest) {
        this.request = new HttpRequest({
            BASE: config?.BASE ?? 'https://api.sandbox.immutable.com',
            VERSION: config?.VERSION ?? '1.0.0',
            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
            CREDENTIALS: config?.CREDENTIALS ?? 'include',
            TOKEN: config?.TOKEN,
            USERNAME: config?.USERNAME,
            PASSWORD: config?.PASSWORD,
            HEADERS: config?.HEADERS,
            ENCODE_PATH: config?.ENCODE_PATH,
        });
        this.orders = new OrdersService(this.request);
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var CancelledOrderStatus;
(function (CancelledOrderStatus) {
    (function (cancellation_type) {
        cancellation_type["ON_CHAIN"] = "ON_CHAIN";
        cancellation_type["OFF_CHAIN"] = "OFF_CHAIN";
    })(CancelledOrderStatus.cancellation_type || (CancelledOrderStatus.cancellation_type = {}));
})(CancelledOrderStatus || (CancelledOrderStatus = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var FailedOrderCancellation;
(function (FailedOrderCancellation) {
    (function (reason_code) {
        reason_code["FILLED"] = "FILLED";
    })(FailedOrderCancellation.reason_code || (FailedOrderCancellation.reason_code = {}));
})(FailedOrderCancellation || (FailedOrderCancellation = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var Fee;
(function (Fee) {
    (function (type) {
        type["ROYALTY"] = "ROYALTY";
        type["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
        type["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
        type["PROTOCOL"] = "PROTOCOL";
    })(Fee.type || (Fee.type = {}));
})(Fee || (Fee = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var Order;
(function (Order) {
    (function (type) {
        type["LISTING"] = "LISTING";
    })(Order.type || (Order.type = {}));
})(Order || (Order = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
/**
 * The Order status
 */
var OrderStatusName;
(function (OrderStatusName) {
    OrderStatusName["PENDING"] = "PENDING";
    OrderStatusName["ACTIVE"] = "ACTIVE";
    OrderStatusName["INACTIVE"] = "INACTIVE";
    OrderStatusName["FILLED"] = "FILLED";
    OrderStatusName["EXPIRED"] = "EXPIRED";
    OrderStatusName["CANCELLED"] = "CANCELLED";
})(OrderStatusName || (OrderStatusName = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var ProtocolData;
(function (ProtocolData) {
    (function (order_type) {
        order_type["FULL_RESTRICTED"] = "FULL_RESTRICTED";
    })(ProtocolData.order_type || (ProtocolData.order_type = {}));
})(ProtocolData || (ProtocolData = {}));

var FeeType;
(function (FeeType) {
    FeeType["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
    FeeType["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
    FeeType["PROTOCOL"] = "PROTOCOL";
    FeeType["ROYALTY"] = "ROYALTY";
})(FeeType || (FeeType = {}));
var TransactionPurpose;
(function (TransactionPurpose) {
    TransactionPurpose["APPROVAL"] = "APPROVAL";
    TransactionPurpose["FULFILL_ORDER"] = "FULFILL_ORDER";
    TransactionPurpose["CANCEL"] = "CANCEL";
})(TransactionPurpose || (TransactionPurpose = {}));
var SignablePurpose;
(function (SignablePurpose) {
    SignablePurpose["CREATE_LISTING"] = "CREATE_LISTING";
    SignablePurpose["OFF_CHAIN_CANCELLATION"] = "OFF_CHAIN_CANCELLATION";
})(SignablePurpose || (SignablePurpose = {}));
var ActionType;
(function (ActionType) {
    ActionType["TRANSACTION"] = "TRANSACTION";
    ActionType["SIGNABLE"] = "SIGNABLE";
})(ActionType || (ActionType = {}));

function mapFromOpenApiOrder(order) {
    const buyItems = order.buy.map((item) => {
        if (item.type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.amount,
            };
        }
        if (item.type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = order.sell.map((item) => {
        if (item.type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: order.id,
        type: order.type,
        accountAddress: order.account_address,
        buy: buyItems,
        sell: sellItems,
        fees: order.fees.map((fee) => ({
            amount: fee.amount,
            recipientAddress: fee.recipient_address,
            type: fee.type,
        })),
        chain: order.chain,
        createdAt: order.created_at,
        endAt: order.end_at,
        orderHash: order.order_hash,
        protocolData: {
            orderType: order.protocol_data.order_type,
            counter: order.protocol_data.counter,
            seaportAddress: order.protocol_data.seaport_address,
            seaportVersion: order.protocol_data.seaport_version,
            zoneAddress: order.protocol_data.zone_address,
        },
        salt: order.salt,
        signature: order.signature,
        startAt: order.start_at,
        status: order.status,
        updatedAt: order.updated_at,
    };
}
function mapFromOpenApiTrade(trade) {
    const buyItems = trade.buy.map((item) => {
        if (item.type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.amount,
            };
        }
        if (item.type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = trade.sell.map((item) => {
        if (item.type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: trade.id,
        orderId: trade.order_id,
        buy: buyItems,
        sell: sellItems,
        buyerFees: trade.buyer_fees.map((fee) => ({
            amount: fee.amount,
            recipientAddress: fee.recipient_address,
            type: fee.type,
        })),
        chain: trade.chain,
        indexedAt: trade.indexed_at,
        blockchainMetadata: {
            blockNumber: trade.blockchain_metadata.block_number,
            logIndex: trade.blockchain_metadata.log_index,
            transactionHash: trade.blockchain_metadata.transaction_hash,
            transactionIndex: trade.blockchain_metadata.transaction_index,
        },
        buyerAddress: trade.buyer_address,
        makerAddress: trade.maker_address,
        sellerAddress: trade.seller_address,
        takerAddress: trade.taker_address,
    };
}
function mapFromOpenApiPage(page) {
    return {
        nextCursor: page.next_cursor,
        previousCursor: page.previous_cursor,
    };
}

/* eslint-disable */
// TODO: Resolve these from seaport-js.
// There is some bundling issue that is preventing this from working
const SEAPORT_CONTRACT_NAME = 'ImmutableSeaport';
// export const SEAPORT_CONTRACT_VERSION_V1_4 = '1.4';
const SEAPORT_CONTRACT_VERSION_V1_5 = '1.5';
const EIP_712_ORDER_TYPE = {
    OrderComponents: [
        { name: 'offerer', type: 'address' },
        { name: 'zone', type: 'address' },
        { name: 'offer', type: 'OfferItem[]' },
        { name: 'consideration', type: 'ConsiderationItem[]' },
        { name: 'orderType', type: 'uint8' },
        { name: 'startTime', type: 'uint256' },
        { name: 'endTime', type: 'uint256' },
        { name: 'zoneHash', type: 'bytes32' },
        { name: 'salt', type: 'uint256' },
        { name: 'conduitKey', type: 'bytes32' },
        { name: 'counter', type: 'uint256' },
    ],
    OfferItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
    ],
    ConsiderationItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
        { name: 'recipient', type: 'address' },
    ],
};
var OrderType;
(function (OrderType) {
    OrderType[OrderType["FULL_OPEN"] = 0] = "FULL_OPEN";
    OrderType[OrderType["PARTIAL_OPEN"] = 1] = "PARTIAL_OPEN";
    OrderType[OrderType["FULL_RESTRICTED"] = 2] = "FULL_RESTRICTED";
    OrderType[OrderType["PARTIAL_RESTRICTED"] = 3] = "PARTIAL_RESTRICTED";
})(OrderType || (OrderType = {}));
var ItemType$1;
(function (ItemType) {
    ItemType[ItemType["NATIVE"] = 0] = "NATIVE";
    ItemType[ItemType["ERC20"] = 1] = "ERC20";
    ItemType[ItemType["ERC721"] = 2] = "ERC721";
    ItemType[ItemType["ERC1155"] = 3] = "ERC1155";
    ItemType[ItemType["ERC721_WITH_CRITERIA"] = 4] = "ERC721_WITH_CRITERIA";
    ItemType[ItemType["ERC1155_WITH_CRITERIA"] = 5] = "ERC1155_WITH_CRITERIA";
})(ItemType$1 || (ItemType$1 = {}));
var Side;
(function (Side) {
    Side[Side["OFFER"] = 0] = "OFFER";
    Side[Side["CONSIDERATION"] = 1] = "CONSIDERATION";
})(Side || (Side = {}));
var BasicOrderRouteType;
(function (BasicOrderRouteType) {
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC721"] = 0] = "ETH_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC1155"] = 1] = "ETH_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC721"] = 2] = "ERC20_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC1155"] = 3] = "ERC20_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC721_TO_ERC20"] = 4] = "ERC721_TO_ERC20";
    BasicOrderRouteType[BasicOrderRouteType["ERC1155_TO_ERC20"] = 5] = "ERC1155_TO_ERC20";
})(BasicOrderRouteType || (BasicOrderRouteType = {}));

function getOrderComponentsFromMessage(orderMessage) {
    const data = JSON.parse(orderMessage);
    const orderComponents = data.message;
    orderComponents.salt = BigNumber$1.from(orderComponents.salt).toHexString();
    return orderComponents;
}

// Add 20% more gas than estimate to prevent out of gas errors
// This can always be overwritten by the user signing the transaction
function prepareTransaction(transactionMethods, 
// chainId is required for EIP155
chainId) {
    return async () => {
        const transaction = await transactionMethods.buildTransaction();
        transaction.gasLimit = await transactionMethods.estimateGas();
        transaction.gasLimit = transaction.gasLimit
            .add(transaction.gasLimit.div(5));
        transaction.chainId = chainId;
        return transaction;
    };
}

function mapImmutableOrderToSeaportOrderComponents(order, counter, zoneAddress) {
    const considerationItems = order.buy.map((buyItem) => {
        switch (buyItem.type) {
            case 'NATIVE':
                return {
                    startAmount: buyItem.amount,
                    endAmount: buyItem.amount,
                    itemType: ItemType$1.NATIVE,
                    recipient: order.account_address,
                    token: constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            case 'ERC20':
                return {
                    startAmount: buyItem.amount,
                    endAmount: buyItem.amount,
                    itemType: ItemType$1.ERC20,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            default: // ERC721
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType$1.ERC721,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
        }
    });
    const fees = order.fees.map((fee) => ({
        amount: fee.amount,
        itemType: order.buy[0].type === 'ERC20' ? ItemType$1.ERC20 : ItemType$1.NATIVE,
        recipient: fee.recipient_address,
        token: order.buy[0].type === 'ERC20'
            ? order.buy[0].contract_address
            : constants$1.AddressZero,
        identifierOrCriteria: '0',
    }));
    return {
        orderComponents: {
            conduitKey: constants$1.HashZero,
            consideration: [...considerationItems],
            offer: order.sell.map((sellItem) => {
                const erc721Item = sellItem;
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType$1.ERC721,
                    token: erc721Item.contract_address,
                    identifierOrCriteria: erc721Item.token_id,
                };
            }),
            counter,
            endTime: Math.round(new Date(order.end_at).getTime() / 1000).toString(),
            startTime: Math.round(new Date(order.start_at).getTime() / 1000).toString(),
            salt: order.salt,
            offerer: order.account_address,
            zone: zoneAddress,
            // this should be the fee exclusive number of items the user signed for
            totalOriginalConsiderationItems: considerationItems.length,
            orderType: OrderType.FULL_RESTRICTED,
            zoneHash: constants$1.HashZero,
        },
        tips: fees,
    };
}

class Seaport {
    seaportLibFactory;
    provider;
    seaportContractAddress;
    zoneContractAddress;
    constructor(seaportLibFactory, provider, seaportContractAddress, zoneContractAddress) {
        this.seaportLibFactory = seaportLibFactory;
        this.provider = provider;
        this.seaportContractAddress = seaportContractAddress;
        this.zoneContractAddress = zoneContractAddress;
    }
    async prepareSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const { actions: seaportActions } = await this.createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry);
        const listingActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            listingActions.push({
                type: ActionType.TRANSACTION,
                purpose: TransactionPurpose.APPROVAL,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods, (await this.provider.getNetwork()).chainId),
            });
        }
        const createAction = seaportActions.find((action) => action.type === 'create');
        if (!createAction) {
            throw new Error('No create order action found');
        }
        const orderMessageToSign = await createAction.getMessageToSign();
        const orderComponents = getOrderComponentsFromMessage(orderMessageToSign);
        listingActions.push({
            type: ActionType.SIGNABLE,
            purpose: SignablePurpose.CREATE_LISTING,
            message: await this.getTypedDataFromOrderComponents(orderComponents),
        });
        return {
            actions: listingActions,
            orderComponents,
            orderHash: this.getSeaportLib().getOrderHash(orderComponents),
        };
    }
    async fulfillOrder(order, account, extraData) {
        const { orderComponents, tips } = this.mapImmutableOrderToSeaportOrderComponents(order);
        const seaportLib = this.getSeaportLib(order);
        const { actions: seaportActions } = await seaportLib.fulfillOrders({
            accountAddress: account,
            fulfillOrderDetails: [
                {
                    order: {
                        parameters: orderComponents,
                        signature: order.signature,
                    },
                    extraData,
                    tips,
                },
            ],
        });
        const fulfillmentActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            fulfillmentActions.push({
                type: ActionType.TRANSACTION,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods, (await this.provider.getNetwork()).chainId),
                purpose: TransactionPurpose.APPROVAL,
            });
        }
        const fulfilOrderAction = seaportActions.find((action) => action.type === 'exchange');
        if (!fulfilOrderAction) {
            throw new Error('No exchange action found');
        }
        fulfillmentActions.push({
            type: ActionType.TRANSACTION,
            buildTransaction: prepareTransaction(fulfilOrderAction.transactionMethods, (await this.provider.getNetwork()).chainId),
            purpose: TransactionPurpose.FULFILL_ORDER,
        });
        return {
            actions: fulfillmentActions,
            expiration: Seaport.getExpirationISOTimeFromExtraData(extraData),
            order: mapFromOpenApiOrder(order),
        };
    }
    async fulfillBulkOrders(fulfillingOrders, account) {
        const fulfillOrderDetails = fulfillingOrders.map((o) => {
            const { orderComponents, tips } = this.mapImmutableOrderToSeaportOrderComponents(o.order);
            return {
                order: {
                    parameters: orderComponents,
                    signature: o.order.signature,
                },
                extraData: o.extra_data,
                tips,
            };
        });
        const { actions: seaportActions } = await this.getSeaportLib().fulfillOrders({
            fulfillOrderDetails,
            accountAddress: account,
        });
        const fulfillmentActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            fulfillmentActions.push({
                type: ActionType.TRANSACTION,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods, (await this.provider.getNetwork()).chainId),
                purpose: TransactionPurpose.APPROVAL,
            });
        }
        const fulfilOrderAction = seaportActions.find((action) => action.type === 'exchange');
        if (!fulfilOrderAction) {
            throw new Error('No exchange action found');
        }
        fulfillmentActions.push({
            type: ActionType.TRANSACTION,
            buildTransaction: prepareTransaction(fulfilOrderAction.transactionMethods, (await this.provider.getNetwork()).chainId),
            purpose: TransactionPurpose.FULFILL_ORDER,
        });
        return {
            actions: fulfillmentActions,
            // return the shortest expiration out of all extraData - they should be very close
            expiration: fulfillOrderDetails
                .map((d) => Seaport.getExpirationISOTimeFromExtraData(d.extraData))
                .reduce((p, c) => (new Date(p) < new Date(c) ? p : c)),
        };
    }
    async cancelOrders(orders, account) {
        const orderComponents = orders.map((order) => this.mapImmutableOrderToSeaportOrderComponents(order).orderComponents);
        const seaportLib = this.getSeaportLib(orders[0]);
        const cancellationTransaction = await seaportLib.cancelOrders(orderComponents, account);
        return {
            type: ActionType.TRANSACTION,
            buildTransaction: prepareTransaction(cancellationTransaction, (await this.provider.getNetwork()).chainId),
            purpose: TransactionPurpose.CANCEL,
        };
    }
    mapImmutableOrderToSeaportOrderComponents(order) {
        const orderCounter = order.protocol_data.counter;
        return mapImmutableOrderToSeaportOrderComponents(order, orderCounter, this.zoneContractAddress);
    }
    createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const seaportLib = this.getSeaportLib();
        return seaportLib.createOrder({
            allowPartialFills: false,
            offer: [
                {
                    itemType: ItemType$1.ERC721,
                    token: listingItem.contractAddress,
                    identifier: listingItem.tokenId,
                },
            ],
            consideration: [
                {
                    token: considerationItem.type === 'ERC20' ? considerationItem.contractAddress : undefined,
                    amount: considerationItem.amount,
                    recipient: offerer,
                },
            ],
            startTime: (orderStart.getTime() / 1000).toFixed(0),
            endTime: (orderExpiry.getTime() / 1000).toFixed(0),
            zone: this.zoneContractAddress,
            restrictedByZone: true,
        }, offerer);
    }
    async getTypedDataFromOrderComponents(orderComponents) {
        const { chainId } = await this.provider.getNetwork();
        const domainData = {
            name: SEAPORT_CONTRACT_NAME,
            version: SEAPORT_CONTRACT_VERSION_V1_5,
            chainId,
            verifyingContract: this.seaportContractAddress,
        };
        return {
            domain: domainData,
            types: EIP_712_ORDER_TYPE,
            value: orderComponents,
        };
    }
    getSeaportLib(order) {
        const seaportAddress = order?.protocol_data?.seaport_address ?? this.seaportContractAddress;
        const seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // if (order?.protocol_data?.seaport_version === SEAPORT_CONTRACT_VERSION_V1_5) {
        //   seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // }
        return this.seaportLibFactory.create(seaportVersion, seaportAddress);
    }
    static getExpirationISOTimeFromExtraData(extraData) {
        // Expirtaion bytes in SIP7 extra data [21:29]
        // In hex string -> [21 * 2 + 2 (0x) : 29 * 2]
        // In JS slice (start, end_inclusive), (44,60)
        // 8 bytes uint64 epoch time in seconds
        const expirationHex = extraData.slice(44, 60);
        const expirationInSeconds = parseInt(expirationHex, 16);
        return new Date(expirationInSeconds * 1000).toISOString();
    }
}

class ImmutableApiClient {
    orderbookService;
    chainName;
    seaportAddress;
    constructor(orderbookService, chainName, seaportAddress) {
        this.orderbookService = orderbookService;
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
    }
    async fulfillmentData(requests) {
        return this.orderbookService.fulfillmentData({
            chainName: this.chainName,
            requestBody: requests,
        });
    }
    async getListing(listingId) {
        return this.orderbookService.getListing({
            chainName: this.chainName,
            listingId,
        });
    }
    async getTrade(tradeId) {
        return this.orderbookService.getTrade({
            chainName: this.chainName,
            tradeId,
        });
    }
    async listListings(listOrderParams) {
        return this.orderbookService.listListings({
            chainName: this.chainName,
            ...listOrderParams,
        });
    }
    async listTrades(listTradesParams) {
        return this.orderbookService.listTrades({
            chainName: this.chainName,
            ...listTradesParams,
        });
    }
    async cancelOrders(orderIds, accountAddress, signature) {
        return this.orderbookService.cancelOrders({
            chainName: this.chainName,
            requestBody: {
                account_address: accountAddress,
                orders: orderIds,
                signature,
            },
        });
    }
    async createListing({ orderHash, orderComponents, orderSignature, makerFees, }) {
        if (orderComponents.offer.length !== 1) {
            throw new Error('Only one item can be listed at a time');
        }
        if (Number(orderComponents.offer[0].itemType) !== ItemType$1.ERC721) {
            throw new Error('Only ERC721 tokens can be listed');
        }
        const orderTypes = [
            ...orderComponents.consideration.map((c) => c.itemType),
        ];
        const isSameConsiderationType = new Set(orderTypes).size === 1;
        if (!isSameConsiderationType) {
            throw new Error('All consideration items must be of the same type');
        }
        return this.orderbookService.createListing({
            chainName: this.chainName,
            requestBody: {
                account_address: orderComponents.offerer,
                buy: [
                    {
                        type: Number(orderComponents.consideration[0].itemType)
                            === ItemType$1.NATIVE
                            ? 'NATIVE'
                            : 'ERC20',
                        amount: orderComponents.consideration[0].startAmount,
                        contract_address: orderComponents.consideration[0].token,
                    },
                ],
                fees: makerFees.map((x) => ({
                    amount: x.amount,
                    type: FeeType.MAKER_ECOSYSTEM,
                    recipient_address: x.recipientAddress,
                })),
                end_at: new Date(parseInt(`${orderComponents.endTime.toString()}000`, 10)).toISOString(),
                order_hash: orderHash,
                protocol_data: {
                    order_type: ProtocolData.order_type.FULL_RESTRICTED,
                    zone_address: orderComponents.zone,
                    seaport_address: this.seaportAddress,
                    seaport_version: SEAPORT_CONTRACT_VERSION_V1_5,
                    counter: orderComponents.counter.toString(),
                },
                salt: orderComponents.salt,
                sell: [
                    {
                        contract_address: orderComponents.offer[0].token,
                        token_id: orderComponents.offer[0].identifierOrCriteria,
                        type: 'ERC721',
                    },
                ],
                signature: orderSignature,
                start_at: new Date(parseInt(`${orderComponents.startTime.toString()}000`, 10)).toISOString(),
            },
        });
    }
}

class ImmutableApiClientFactory {
    chainName;
    seaportAddress;
    orderbookClient;
    constructor(apiEndpoint, chainName, seaportAddress) {
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
        this.orderbookClient = new OrderBookClient({
            // eslint-disable-next-line @typescript-eslint/naming-convention
            BASE: apiEndpoint,
        });
    }
    create() {
        return new ImmutableApiClient(this.orderbookClient.orders, this.chainName, this.seaportAddress);
    }
}

const TESTNET_CHAIN_NAME = 'imtbl-zkevm-testnet';
const MAINNET_CHAIN_NAME = 'imtbl-zkevm-mainnet';
function getOrderbookConfig(environment) {
    switch (environment) {
        case Environment$1.SANDBOX:
            return {
                seaportContractAddress: '0x3A0C2Ba54D6CBd3121F01b96dFd20e99D1696C9D',
                zoneContractAddress: '0x2EA937879beeF3393853A74Ad62F9ad7DA0B9E81',
                apiEndpoint: 'https://api.sandbox.immutable.com',
                chainName: TESTNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.testnet.immutable.com'),
            };
        // not yet deployed
        case Environment$1.PRODUCTION:
            return {
                seaportContractAddress: '',
                zoneContractAddress: '',
                apiEndpoint: 'https://api.immutable.com',
                chainName: MAINNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.immutable.com'),
            };
        default:
            return null;
    }
}

class SeaportLibFactory {
    defaultSeaportContractAddress;
    provider;
    constructor(defaultSeaportContractAddress, provider) {
        this.defaultSeaportContractAddress = defaultSeaportContractAddress;
        this.provider = provider;
    }
    create(orderSeaportVersion, orderSeaportAddress) {
        const seaportVersion = orderSeaportVersion ?? SEAPORT_CONTRACT_VERSION_V1_5;
        const seaportContractAddress = orderSeaportAddress ?? this.defaultSeaportContractAddress;
        return new Seaport$1(this.provider, {
            seaportVersion,
            balanceAndApprovalChecksOnOrderCreation: true,
            overrides: {
                contractAddress: seaportContractAddress,
            },
        });
    }
}

/**
 * zkEVM orderbook SDK
 * @constructor
 * @param {OrderbookModuleConfiguration} config - Configuration for Immutable services.
 */
class Orderbook {
    apiClient;
    seaport;
    orderbookConfig;
    constructor(config) {
        const obConfig = getOrderbookConfig(config.baseConfig.environment);
        const finalConfig = {
            ...obConfig,
            ...config.overrides,
        };
        if (!finalConfig) {
            throw new Error('Orderbook configuration not passed, please specify the environment under config.baseConfig.environment');
        }
        this.orderbookConfig = finalConfig;
        const { apiEndpoint, chainName } = this.orderbookConfig;
        if (!apiEndpoint) {
            throw new Error('API endpoint must be provided');
        }
        this.apiClient = new ImmutableApiClientFactory(apiEndpoint, chainName, this.orderbookConfig.seaportContractAddress).create();
        const seaportLibFactory = new SeaportLibFactory(this.orderbookConfig.seaportContractAddress, this.orderbookConfig.provider);
        this.seaport = new Seaport(seaportLibFactory, this.orderbookConfig.provider, this.orderbookConfig.seaportContractAddress, this.orderbookConfig.zoneContractAddress);
    }
    /**
     * Return the configuration for the orderbook module.
     * @return {OrderbookModuleConfiguration} The configuration for the orderbook module.
     */
    config() {
        return this.orderbookConfig;
    }
    /**
     * Get an order by ID
     * @param {string} listingId - The listingId to find.
     * @return {ListingResult} The returned order result.
     */
    async getListing(listingId) {
        const apiListing = await this.apiClient.getListing(listingId);
        return {
            result: mapFromOpenApiOrder(apiListing.result),
        };
    }
    /**
     * Get a trade by ID
     * @param {string} tradeId - The tradeId to find.
     * @return {TradeResult} The returned order result.
     */
    async getTrade(tradeId) {
        const apiListing = await this.apiClient.getTrade(tradeId);
        return {
            result: mapFromOpenApiTrade(apiListing.result),
        };
    }
    /**
     * List orders. This method is used to get a list of orders filtered by conditions specified
     * in the params object.
     * @param {ListListingsParams} listOrderParams - Filtering, ordering and page parameters.
     * @return {ListListingsResult} The paged orders.
     */
    async listListings(listOrderParams) {
        const apiListings = await this.apiClient.listListings(listOrderParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiOrder),
        };
    }
    /**
     * List trades. This method is used to get a list of trades filtered by conditions specified
     * in the params object
     * @param {ListTradesParams} listTradesParams - Filtering, ordering and page parameters.
     * @return {ListTradesResult} The paged trades.
     */
    async listTrades(listTradesParams) {
        const apiListings = await this.apiClient.listTrades(listTradesParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiTrade),
        };
    }
    /**
     * Get required transactions and messages for signing prior to creating a listing
     * through the createListing method
     * @param {PrepareListingParams} prepareListingParams - Details about the listing to be created.
     * @return {PrepareListingResponse} PrepareListingResponse includes
     * the unsigned approval transaction, the typed order message for signing and
     * the order components that can be submitted to `createListing` with a signature.
     */
    async prepareListing({ makerAddress, sell, buy, orderExpiry, }) {
        return this.seaport.prepareSeaportOrder(makerAddress, sell, buy, 
        // Default order start to now
        new Date(), 
        // Default order expiry to 2 years from now
        orderExpiry || new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 2));
    }
    /**
     * Create an order
     * @param {CreateListingParams} createListingParams - create an order with the given params.
     * @return {ListingResult} The result of the order created in the Immutable services.
     */
    async createListing(createListingParams) {
        const apiListingResponse = await this.apiClient.createListing({
            ...createListingParams,
        });
        return {
            result: mapFromOpenApiOrder(apiListingResponse.result),
        };
    }
    /**
     * Get unsigned transactions that can be submitted to fulfil an open order. If the approval
     * transaction exists it must be signed and submitted to the chain before the fulfilment
     * transaction can be submitted or it will be reverted.
     * @param {string} listingId - The listingId to fulfil.
     * @param {string} fulfillerAddress - The address of the account fulfilling the order.
     * @return {FulfillOrderResponse} Approval and fulfilment transactions.
     */
    async fulfillOrder(listingId, takerAddress, takerFees) {
        const fulfillmentDataRes = await this.apiClient.fulfillmentData([
            {
                order_id: listingId,
                fees: takerFees.map((fee) => ({
                    amount: fee.amount,
                    type: FeeType.TAKER_ECOSYSTEM,
                    recipient_address: fee.recipientAddress,
                })),
            },
        ]);
        if (fulfillmentDataRes.result.unfulfillable_orders?.length > 0) {
            throw new Error(`Unable to prepare fulfillment date: ${fulfillmentDataRes.result.unfulfillable_orders[0].reason}`);
        }
        else if (fulfillmentDataRes.result.fulfillable_orders?.length !== 1) {
            throw new Error('unexpected fulfillable order result length');
        }
        const extraData = fulfillmentDataRes.result.fulfillable_orders[0].extra_data;
        const orderResult = fulfillmentDataRes.result.fulfillable_orders[0].order;
        if (orderResult.status.name !== OrderStatusName.ACTIVE) {
            throw new Error(`Cannot fulfil order that is not active. Current status: ${orderResult.status}`);
        }
        return this.seaport.fulfillOrder(orderResult, takerAddress, extraData);
    }
    async fulfillBulkOrders(listings, takerAddress) {
        const fulfillmentDataRes = await this.apiClient.fulfillmentData(listings.map((listingRequest) => ({
            order_id: listingRequest.listingId,
            fees: listingRequest.takerFees.map((fee) => ({
                amount: fee.amount,
                type: FeeType.TAKER_ECOSYSTEM,
                recipient_address: fee.recipientAddress,
            })),
        })));
        try {
            return {
                ...(await this.seaport.fulfillBulkOrders(fulfillmentDataRes.result.fulfillable_orders, takerAddress)),
                fulfillableOrders: fulfillmentDataRes.result.fulfillable_orders.map((o) => mapFromOpenApiOrder(o.order)),
                unfulfillableOrders: fulfillmentDataRes.result.unfulfillable_orders.map((o) => ({
                    orderId: o.order_id,
                    reason: o.reason,
                })),
                sufficientBalance: true,
            };
        }
        catch (e) {
            // if insufficient balance error, we return FulfillBulkOrdersInsufficientBalanceResponse
            if (String(e).includes('The fulfiller does not have the balances needed to fulfill.')) {
                return {
                    fulfillableOrders: fulfillmentDataRes.result.fulfillable_orders.map((o) => mapFromOpenApiOrder(o.order)),
                    unfulfillableOrders: fulfillmentDataRes.result.unfulfillable_orders.map((o) => ({
                        orderId: o.order_id,
                        reason: o.reason,
                    })),
                    sufficientBalance: false,
                };
            }
            // if some other error is thrown,
            // there likely is a race condition of the original order validity
            // we throw the error back out
            throw e;
        }
    }
    /**
     * Cancelling orders is a gasless alternative to on-chain cancellation exposed with
     * `cancelOrdersOnChain`. For the orderbook to authenticate the cancellation, the creator
     * of the orders must sign an EIP712 message containing the orderIds
     * @param {string} orderIds - The orderIds to attempt to cancel.
     * @return {PrepareCancelOrdersResponse} The signable action to cancel the orders.
     */
    async prepareOrderCancellations(orderIds) {
        const network = await this.orderbookConfig.provider.getNetwork();
        const domain = {
            name: 'imtbl-order-book',
            chainId: network.chainId,
            verifyingContract: this.orderbookConfig.seaportContractAddress,
        };
        const types = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            CancelPayload: [
                { name: 'orders', type: 'Order[]' },
            ],
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Order: [
                { name: 'id', type: 'string' },
            ],
        };
        const cancelMessage = {
            orders: orderIds.map((id) => ({ id })),
        };
        return {
            signableAction: {
                purpose: SignablePurpose.OFF_CHAIN_CANCELLATION,
                type: ActionType.SIGNABLE,
                message: {
                    domain,
                    types,
                    value: cancelMessage,
                },
            },
        };
    }
    /**
     * Cancelling orders is a gasless alternative to on-chain cancellation exposed with
     * `cancelOrdersOnChain`. Orders cancelled this way cannot be fulfilled and will be removed
     * from the orderbook. If there is pending fulfillment data outstanding for the order, its
     * cancellation will be pending until the fulfillment window has passed.
     * `prepareOffchainOrderCancellations` can be used to get the signable action that is signed
     * to get the signature required for this call.
     * @param {string[]} orderIds - The orderIds to attempt to cancel.
     * @param {string} accountAddress - The address of the account cancelling the orders.
     * @param {string} accountAddress - The address of the account cancelling the orders.
     * @return {CancelOrdersResult} The result of the off-chain cancellation request
     */
    async cancelOrders(orderIds, accountAddress, signature) {
        return this.apiClient.cancelOrders(orderIds, accountAddress, signature);
    }
    /**
     * Get an unsigned order cancellation transaction. Orders can only be cancelled by
     * the account that created them. All of the orders must be from the same seaport contract.
     * If trying to cancel orders from multiple seaport contracts, group the orderIds by seaport
     * contract and call this method for each group.
     * @param {string[]} orderIds - The orderIds to cancel.
     * @param {string} accountAddress - The address of the account cancelling the order.
     * @return {CancelOrdersOnChainResponse} The unsigned cancel order action
     */
    async cancelOrdersOnChain(orderIds, accountAddress) {
        const orderResults = await Promise.all(orderIds.map((id) => this.apiClient.getListing(id)));
        // eslint-disable-next-line no-restricted-syntax
        for (const orderResult of orderResults) {
            if (orderResult.result.status.name !== OrderStatusName.ACTIVE
                && orderResult.result.status.name !== OrderStatusName.INACTIVE
                && orderResult.result.status.name !== OrderStatusName.PENDING) {
                throw new Error(`Cannot cancel order with status ${orderResult.result.status}`);
            }
            if (orderResult.result.account_address !== accountAddress.toLowerCase()) {
                throw new Error(`Only account ${orderResult.result.account_address} can cancel order ${orderResult.result.id}`);
            }
        }
        const orders = orderResults.map((orderResult) => orderResult.result);
        const seaportAddresses = orders.map((o) => o.protocol_data.seaport_address);
        const distinctSeaportAddresses = new Set(...[seaportAddresses]);
        if (distinctSeaportAddresses.size !== 1) {
            throw new Error('Cannot cancel multiple orders from different seaport contracts. Please group your orderIds accordingly');
        }
        const cancellationAction = await this.seaport.cancelOrders(orders, accountAddress);
        return { cancellationAction };
    }
}

// Consumers might want an estimated gas limit for fulfilling an order
// without calling the transaction builder. This is an estimate that
// should work for all fulfillment scenarios.
const ESTIMATED_FULFILLMENT_GAS_GWEI = 400000;
const constants = {
    estimatedFulfillmentGasGwei: ESTIMATED_FULFILLMENT_GAS_GWEI,
};

var orderbook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ActionType () { return ActionType; },
    get FeeType () { return FeeType; },
    get OrderStatusName () { return OrderStatusName; },
    Orderbook: Orderbook,
    get SignablePurpose () { return SignablePurpose; },
    get TransactionPurpose () { return TransactionPurpose; },
    constants: constants
});

function isChainValid(chainID, config) {
    return chainID === config.ethConfiguration.chainID;
}
async function validateChain(signer, config) {
    const chainID = await signer.getChainId();
    if (!isChainValid(chainID, config)) {
        throw new Error('The wallet used for this operation is not connected to the correct network.');
    }
}

async function transfer({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const transfersApi = new TransfersApi(config.immutableXConfig.apiConfiguration);
    const transferAmount = request.type === 'ERC721' ? '1' : request.amount;
    const signableResult = await transfersApi.getSignableTransferV1({
        getSignableTransferRequest: {
            sender: ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const transferSigningParams = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sender_stark_key: signableResult.data.sender_stark_key,
        sender_vault_id: signableResult.data.sender_vault_id,
        receiver_stark_key: signableResult.data.receiver_stark_key,
        receiver_vault_id: signableResult.data.receiver_vault_id,
        asset_id: signableResult.data.asset_id,
        amount: signableResult.data.amount,
        nonce: signableResult.data.nonce,
        expiration_timestamp: signableResult.data.expiration_timestamp,
        stark_signature: starkSignature,
    };
    const response = await transfersApi.createTransferV1({
        createTransferRequest: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        sent_signature: response?.data.sent_signature,
        status: response?.data.status?.toString(),
        time: response?.data.time,
        transfer_id: response?.data.transfer_id,
    };
}
async function batchTransfer({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const transfersApi = new TransfersApi(config.immutableXConfig.apiConfiguration);
    const signableRequests = request.map((nftTransfer) => ({
        amount: '1',
        token: convertToSignableToken({
            type: 'ERC721',
            tokenId: nftTransfer.tokenId,
            tokenAddress: nftTransfer.tokenAddress,
        }),
        receiver: nftTransfer.receiver,
    }));
    const signableResult = await transfersApi.getSignableTransfer({
        getSignableTransferRequestV2: {
            sender_ether_key: ethAddress,
            signable_requests: signableRequests,
        },
    });
    const signableMessage = signableResult.data.signable_message;
    if (signableMessage === undefined) {
        throw new Error('Invalid response from Signable registration offchain');
    }
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const requests = [];
    for (const resp of signableResult.data.signable_responses) {
        // TODO: remove once fixed
        // eslint-disable-next-line no-await-in-loop
        const starkSignature = await starkSigner.signMessage(resp.payload_hash);
        const req = {
            sender_vault_id: resp.sender_vault_id,
            receiver_stark_key: resp.receiver_stark_key,
            receiver_vault_id: resp.receiver_vault_id,
            asset_id: resp.asset_id,
            amount: resp.amount,
            nonce: resp.nonce,
            expiration_timestamp: resp.expiration_timestamp,
            stark_signature: starkSignature,
        };
        requests.push(req);
    }
    // TODO: throw error on missing payload hash?
    const transferSigningParams = {
        sender_stark_key: signableResult.data.sender_stark_key,
        requests,
    };
    const response = await transfersApi.createTransfer({
        createTransferRequestV2: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        transfer_ids: response?.data.transfer_ids,
    };
}

async function createOrder({ signers, request, config, }) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const ethAddress = await signers.ethSigner.getAddress();
    const ordersApi = new OrdersApi$1(config.immutableXConfig.apiConfiguration);
    const amountSell = request.sell.type === 'ERC721' ? '1' : request.sell.amount;
    const amountBuy = request.buy.type === 'ERC721' ? '1' : request.buy.amount;
    const getSignableOrderRequest = {
        user: ethAddress,
        amount_buy: amountBuy,
        token_buy: convertToSignableToken(request.buy),
        amount_sell: amountSell,
        token_sell: convertToSignableToken(request.sell),
        fees: request.fees,
        expiration_timestamp: request.expiration_timestamp,
    };
    const getSignableOrderResponse = await ordersApi.getSignableOrder({
        getSignableOrderRequestV3: getSignableOrderRequest,
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = getSignableOrderResponse.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const resp = getSignableOrderResponse.data;
    const orderParams = {
        createOrderRequest: {
            amount_buy: resp.amount_buy,
            amount_sell: resp.amount_sell,
            asset_id_buy: resp.asset_id_buy,
            asset_id_sell: resp.asset_id_sell,
            expiration_timestamp: resp.expiration_timestamp,
            fees: request.fees,
            nonce: resp.nonce,
            stark_key: resp.stark_key,
            stark_signature: starkSignature,
            vault_id_buy: resp.vault_id_buy,
            vault_id_sell: resp.vault_id_sell,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    };
    const createOrderResponse = await ordersApi.createOrderV3(orderParams);
    return {
        ...createOrderResponse.data,
    };
}
async function cancelOrder({ signers, request, config, }) {
    const ordersApi = new OrdersApi$1(config.immutableXConfig.apiConfiguration);
    const getSignableCancelOrderResponse = await ordersApi.getSignableCancelOrderV3({
        getSignableCancelOrderRequest: {
            order_id: request.order_id,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = getSignableCancelOrderResponse.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const ethAddress = await signers.ethSigner.getAddress();
    const cancelOrderResponse = await ordersApi.cancelOrderV3({
        id: request.order_id.toString(),
        cancelOrderRequest: {
            order_id: request.order_id,
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        order_id: cancelOrderResponse.data.order_id,
        status: cancelOrderResponse.data.status,
    };
}

async function registerOffchain(signers, config) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const usersApi = new UsersApi(config.immutableXConfig.apiConfiguration);
    const userAddress = await signers.ethSigner.getAddress();
    const starkPublicKey = await signers.starkSigner.getAddress();
    const signableResult = await usersApi.getSignableRegistrationOffchain({
        getSignableRegistrationRequest: {
            ether_key: userAddress,
            stark_key: starkPublicKey,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const registeredUser = await usersApi.registerUser({
        registerUserRequest: {
            eth_signature: ethSignature,
            ether_key: userAddress,
            stark_signature: starkSignature,
            stark_key: starkPublicKey,
        },
    });
    return registeredUser.data;
}
async function isRegisteredOffchain(ethAddress, config) {
    try {
        const usersApi = new UsersApi(config.immutableXConfig.apiConfiguration);
        const getUsersResult = await usersApi.getUsers({
            user: ethAddress,
        });
        const { accounts } = getUsersResult.data;
        return accounts?.length > 0;
    }
    catch (ex) {
        if (ex instanceof AxiosError$1 && ex.response?.status === 404) {
            return false;
        }
        throw ex;
    }
}
async function isRegisteredOnChain(starkPublicKey, ethSigner, config) {
    await validateChain(ethSigner, config.immutableXConfig);
    const registrationContract = Contracts.Registration.connect(config.immutableXConfig.ethConfiguration.registrationContractAddress, ethSigner);
    try {
        return await registrationContract.isRegistered(starkPublicKey);
    }
    catch (ex) {
        if (ex.reason === 'USER_UNREGISTERED') {
            return false;
        }
        throw ex;
    }
}
async function getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi) {
    const response = await usersApi.getSignableRegistration({
        getSignableRegistrationRequest: {
            ether_key: etherKey,
            stark_key: starkPublicKey,
        },
    });
    return {
        operator_signature: response.data.operator_signature,
        payload_hash: response.data.payload_hash,
        readable_transaction: response.data.readable_transaction,
        verification_signature: response.data.verification_signature,
    };
}

const assertIsDefined = (value) => {
    if (value !== undefined)
        return value;
    throw new Error('undefined field exception');
};
async function prepareWithdrawalAction(params) {
    const { signers: { ethSigner, starkSigner }, type, config, } = params;
    await validateChain(ethSigner, params.config);
    const withdrawalsApi = new WithdrawalsApi(config.apiConfiguration);
    const withdrawalAmount = type === 'ERC721' ? '1' : params.amount;
    const signableWithdrawalResult = await withdrawalsApi.getSignableWithdrawal({
        getSignableWithdrawalRequest: {
            user: await ethSigner.getAddress(),
            token: convertToSignableToken(params),
            amount: withdrawalAmount,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableWithdrawalResult.data;
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const { ethAddress, ethSignature } = await signMessage$1(signableMessage, ethSigner);
    const prepareWithdrawalResponse = await withdrawalsApi.createWithdrawal({
        createWithdrawalRequest: {
            stark_key: assertIsDefined(signableWithdrawalResult.data.stark_key),
            amount: withdrawalAmount,
            asset_id: assertIsDefined(signableWithdrawalResult.data.asset_id),
            vault_id: assertIsDefined(signableWithdrawalResult.data.vault_id),
            nonce: assertIsDefined(signableWithdrawalResult.data.nonce),
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return prepareWithdrawalResponse.data;
}

async function getEncodeAssetInfo(assetType, tokenType, config, tokenData) {
    const encodingApi = new EncodingApi(config.apiConfiguration);
    const result = await encodingApi.encodeAsset({
        assetType,
        encodeAssetRequest: {
            token: {
                type: tokenType,
                ...(tokenData && { data: tokenData }),
            },
        },
    });
    return result.data;
}

async function executeRegisterAndWithdrawERC20({ ethSigner, assetType, starkPublicKey, config, }) {
    const etherKey = await ethSigner.getAddress();
    const imxConfig = config.immutableXConfig;
    const usersApi = new UsersApi(imxConfig.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.immutableXConfig.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdraw(etherKey, starkPublicKey, signableResult.operator_signature, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawERC20(ethSigner, assetType, starkPublicKey, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdraw(starkPublicKey, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeERC20WithdrawalAction({ ethSigner, starkPublicKey, token, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ERC20', imxConfig, {
        token_address: token.tokenAddress,
    });
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawERC20({
            ethSigner,
            assetType: assetType.asset_type,
            starkPublicKey,
            config,
        });
    }
    return executeWithdrawERC20(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
}

async function executeWithdrawMintableERC721(ethSigner, assetType, starkPublicKey, mintingBlob, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdrawAndMint(starkPublicKey, assetType, mintingBlob);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeRegisterAndWithdrawMintableERC721(ethSigner, assetType, starkPublicKey, mintingBlob, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.regsiterAndWithdrawAndMint(etherKey, starkPublicKey, signableResult.operator_signature, assetType, mintingBlob);
    return ethSigner.sendTransaction(populatedTransaction);
}
function getMintingBlob(token) {
    const { id } = token.data;
    const blueprint = token.data.blueprint || '';
    return encUtils.sanitizeHex(encUtils.utf8ToHex(`{${id}}:{${blueprint}}`));
}
async function completeMintableERC721Withdrawal(ethSigner, starkPublicKey, token, config) {
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('mintable-asset', 'ERC721', imxConfig, {
        id: token.data.id,
        token_address: token.data.tokenAddress,
        ...(token.data.blueprint && { blueprint: token.data.blueprint }),
    });
    const mintingBlob = getMintingBlob(token);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawMintableERC721(ethSigner, assetType.asset_type, starkPublicKey, mintingBlob, imxConfig);
    }
    return executeWithdrawMintableERC721(ethSigner, assetType.asset_type, starkPublicKey, mintingBlob, imxConfig);
}
async function executeRegisterAndWithdrawERC721(ethSigner, assetType, starkPublicKey, tokenId, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdrawNft(etherKey, starkPublicKey, signableResult.operator_signature, assetType, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawERC721(ethSigner, assetType, starkPublicKey, tokenId, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdrawNft(starkPublicKey, assetType, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeERC721Withdrawal(ethSigner, starkPublicKey, token, config) {
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ERC721', imxConfig, {
        token_id: token.tokenId,
        token_address: token.tokenAddress,
    });
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawERC721(ethSigner, assetType.asset_type, starkPublicKey, token.tokenId, imxConfig);
    }
    return executeWithdrawERC721(ethSigner, assetType.asset_type, starkPublicKey, token.tokenId, imxConfig);
}
async function completeERC721WithdrawalAction({ ethSigner, starkPublicKey, token, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const { tokenAddress } = token;
    const { tokenId } = token;
    const imxConfig = config.immutableXConfig;
    const mintsApi = new MintsApi(imxConfig.apiConfiguration);
    return await mintsApi
        .getMintableTokenDetailsByClientTokenId({
        tokenAddress,
        tokenId,
    })
        .then((mintableToken) => completeMintableERC721Withdrawal(ethSigner, starkPublicKey, {
        type: 'ERC721',
        data: {
            id: tokenId,
            tokenAddress,
            blueprint: mintableToken.data.blueprint,
        },
    }, config))
        .catch((error) => {
        if (error.response?.status === 404) {
            // token is already minted on L1
            return completeERC721Withdrawal(ethSigner, starkPublicKey, token, config);
        }
        throw error; // unable to recover from any other kind of error
    });
}

async function executeRegisterAndWithdrawEth(ethSigner, assetType, starkPublicKey, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdraw(etherKey, starkPublicKey, signableResult.operator_signature, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawEth(ethSigner, assetType, starkPublicKey, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdraw(starkPublicKey, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeEthWithdrawalAction({ ethSigner, starkPublicKey, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ETH', imxConfig);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawEth(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
    }
    return executeWithdrawEth(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
}

async function prepareWithdrawal({ signers, withdrawal, config, }) {
    return prepareWithdrawalAction({
        signers,
        config: config.immutableXConfig,
        ...withdrawal,
    });
}
// TODO: remove once fixed
// eslint-disable-next-line consistent-return
async function completeWithdrawal({ signers: { ethSigner }, starkPublicKey, token, config, }) {
    // TODO: please add a reasonable default here
    // eslint-disable-next-line default-case
    switch (token.type) {
        case 'ETH':
            return completeEthWithdrawalAction({ ethSigner, starkPublicKey, config });
        case 'ERC20':
            return completeERC20WithdrawalAction({
                ethSigner,
                starkPublicKey,
                token,
                config,
            });
        case 'ERC721':
            return completeERC721WithdrawalAction({
                ethSigner,
                starkPublicKey,
                token,
                config,
            });
    }
}

async function createTrade({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const tradesApi = new TradesApi(config.immutableXConfig.apiConfiguration);
    const signableResult = await tradesApi.getSignableTrade({
        getSignableTradeRequest: {
            user: ethAddress,
            order_id: request.order_id,
            fees: request.fees,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const createTradeResponse = await tradesApi.createTradeV3({
        createTradeRequest: {
            amount_buy: signableResult.data.amount_buy,
            amount_sell: signableResult.data.amount_sell,
            asset_id_buy: signableResult.data.asset_id_buy,
            asset_id_sell: signableResult.data.asset_id_sell,
            expiration_timestamp: signableResult.data.expiration_timestamp,
            fee_info: signableResult.data.fee_info,
            fees: request.fees,
            include_fees: true,
            nonce: signableResult.data.nonce,
            order_id: request.order_id,
            stark_key: signableResult.data.stark_key,
            vault_id_buy: signableResult.data.vault_id_buy,
            vault_id_sell: signableResult.data.vault_id_sell,
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return createTradeResponse.data;
}

async function executeRegisterAndDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, config, usersApi) {
    const etherKey = await ethSigner.getAddress();
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const populatedTransaction = await coreContract.populateTransaction.registerAndDepositEth(etherKey, starkPublicKey, signableResult.operator_signature, assetType, vaultId);
    return ethSigner.sendTransaction({ ...populatedTransaction, value: amount });
}
async function executeDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction['deposit(uint256,uint256,uint256)'](starkPublicKey, assetType, vaultId);
    return ethSigner.sendTransaction({ ...populatedTransaction, value: amount });
}
async function depositEth({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const user = await ethSigner.getAddress();
    const data = {
        decimals: 18,
    };
    const amount = parseUnits(deposit.amount, 'wei');
    const imxConfig = config.immutableXConfig;
    const depositsApi = new DepositsApi(imxConfig.apiConfiguration);
    const encodingApi = new EncodingApi(imxConfig.apiConfiguration);
    const usersApi = new UsersApi(imxConfig.apiConfiguration);
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, imxConfig, usersApi);
    }
    return executeDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, imxConfig);
}

async function executeRegisterAndDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, config, usersApi) {
    const etherKey = await ethSigner.getAddress();
    const coreContract = Contracts.Core.connect(config.coreContractAddress, ethSigner);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const populatedTransaction = await coreContract.populateTransaction.registerAndDepositERC20(etherKey, starkPublicKey, signableResult.operator_signature, assetType, vaultId, quantizedAmount);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction.depositERC20(starkPublicKey, assetType, vaultId, quantizedAmount);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function depositERC20({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const { apiConfiguration, ethConfiguration } = config.immutableXConfig;
    const user = await ethSigner.getAddress();
    const tokensApi = new TokensApi$1(apiConfiguration);
    const depositsApi = new DepositsApi(apiConfiguration);
    const encodingApi = new EncodingApi(apiConfiguration);
    const usersApi = new UsersApi(apiConfiguration);
    // Get decimals for this specific ERC20
    const token = await tokensApi.getToken({ address: deposit.tokenAddress });
    // TODO: remove once fixed
    // eslint-disable-next-line radix
    const decimals = parseInt(token.data.decimals);
    const data = {
        decimals,
        token_address: deposit.tokenAddress,
    };
    const amount = parseUnits(deposit.amount, 0); // 0 to always use undecimalized value
    // Approve whether an amount of token from an account can be spent by a third-party account
    const tokenContract = Contracts.IERC20.connect(deposit.tokenAddress, ethSigner);
    const approveTransaction = await tokenContract.populateTransaction.approve(ethConfiguration.coreContractAddress, amount);
    await ethSigner.sendTransaction(approveTransaction);
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    // Perform encoding on asset details to get an assetType (required for stark contract request)
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
                data: {
                    token_address: deposit.tokenAddress,
                },
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const quantizedAmount = BigNumber$2.from(signableDepositResult.data.amount);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, ethConfiguration, usersApi);
    }
    return executeDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, ethConfiguration);
}

async function executeDepositERC721(ethSigner, tokenId, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction.depositNft(starkPublicKey, assetType, vaultId, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function depositERC721({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const user = await ethSigner.getAddress();
    const { immutableXConfig } = config;
    const depositsApi = new DepositsApi(immutableXConfig.apiConfiguration);
    const encodingApi = new EncodingApi(immutableXConfig.apiConfiguration);
    const usersApi = new UsersApi(immutableXConfig.apiConfiguration);
    const data = {
        token_address: deposit.tokenAddress,
        token_id: deposit.tokenId,
    };
    const amount = '1';
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    // Perform encoding on asset details to get an assetType (required for stark contract request)
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
                data: {
                    token_address: deposit.tokenAddress,
                    token_id: deposit.tokenId,
                },
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    // Approve whether an amount of token from an account can be spent by a third-party account
    const tokenContract = Contracts.IERC721.connect(deposit.tokenAddress, ethSigner);
    const operator = immutableXConfig.ethConfiguration.coreContractAddress;
    const isApprovedForAll = await tokenContract.isApprovedForAll(user, operator);
    if (!isApprovedForAll) {
        await tokenContract.setApprovalForAll(operator, true);
    }
    if (!isRegistered) {
        const signableResult = await getSignableRegistrationOnchain(user, starkPublicKey, usersApi);
        const coreContract = Contracts.Core.connect(immutableXConfig.ethConfiguration.coreContractAddress, ethSigner);
        // Note: proxy registration contract registerAndDepositNft method is not used as
        // it currently fails erc721 transfer ownership check
        await coreContract.registerUser(user, starkPublicKey, signableResult.operator_signature);
    }
    return executeDepositERC721(ethSigner, deposit.tokenId, assetType, starkPublicKey, vaultId, immutableXConfig);
}

// TODO: remove once fixed deposit variable shadowing
// eslint-disable-next-line consistent-return, @typescript-eslint/no-shadow
async function deposit({ signers, deposit, config }) {
    // TODO: please add a reasonable default here
    // eslint-disable-next-line default-case
    switch (deposit.type) {
        case 'ETH':
            return depositEth({ signers, deposit, config });
        case 'ERC20':
            return depositERC20({ signers, deposit, config });
        case 'ERC721':
            return depositERC721({ signers, deposit, config });
    }
}

async function exchangeTransfer({ signers, request, config, }) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const exchangeApi = new ExchangesApi(config.immutableXConfig.apiConfiguration);
    const ethAddress = await signers.ethSigner.getAddress();
    const transferAmount = request.amount;
    const signableResult = await exchangeApi.getExchangeSignableTransfer({
        id: request.transactionID,
        getSignableTransferRequest: {
            sender: ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const transferSigningParams = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sender_stark_key: signableResult.data.sender_stark_key,
        sender_vault_id: signableResult.data.sender_vault_id,
        receiver_stark_key: signableResult.data.receiver_stark_key,
        receiver_vault_id: signableResult.data.receiver_vault_id,
        asset_id: signableResult.data.asset_id,
        amount: signableResult.data.amount,
        nonce: signableResult.data.nonce,
        expiration_timestamp: signableResult.data.expiration_timestamp,
        stark_signature: starkSignature,
    };
    const response = await exchangeApi.createExchangeTransfer({
        id: request.transactionID,
        createTransferRequest: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        sent_signature: response?.data.sent_signature,
        status: response?.data.status?.toString(),
        time: response?.data.time,
        transfer_id: response?.data.transfer_id,
    };
}

class GenericIMXProvider {
    config;
    signers;
    constructor(config, ethSigner, starkSigner) {
        this.config = config;
        this.signers = { ethSigner, starkSigner };
    }
    async getAddress() {
        return this.signers.ethSigner.getAddress();
    }
    async isRegisteredOffchain() {
        const ethAddress = await this.getAddress();
        return isRegisteredOffchain(ethAddress, this.config);
    }
    registerOffchain() {
        return registerOffchain(this.signers, this.config);
    }
    batchNftTransfer(request) {
        return batchTransfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    cancelOrder(request) {
        return cancelOrder({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    completeWithdrawal(starkPublicKey, token) {
        return completeWithdrawal({
            config: this.config,
            signers: this.signers,
            token,
            starkPublicKey,
        });
    }
    createOrder(request) {
        return createOrder({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    createTrade(request) {
        return createTrade({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    deposit(tokenAmount) {
        return deposit({
            signers: this.signers,
            deposit: tokenAmount,
            config: this.config,
        });
    }
    exchangeTransfer(request) {
        return exchangeTransfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    async isRegisteredOnchain() {
        const starkPublicKey = await this.signers.starkSigner.getAddress();
        return isRegisteredOnChain(starkPublicKey, this.signers.ethSigner, this.config);
    }
    prepareWithdrawal(request) {
        return prepareWithdrawal({
            signers: this.signers,
            withdrawal: request,
            config: this.config,
        });
    }
    transfer(request) {
        return transfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
}

const WALLET_ACTION = {
    // TODO: remove once fixed - consider using an enum
    // eslint-disable-next-line @typescript-eslint/naming-convention
    SWITCH_CHAIN: 'wallet_switchEthereumChain',
    // eslint-disable-next-line @typescript-eslint/naming-convention
    CONNECT: 'eth_requestAccounts',
};
function isRequestableProvider(provider) {
    return !!provider?.request;
}
async function connectProvider(provider, chainID) {
    await provider.request({ method: WALLET_ACTION.CONNECT });
    if (chainID) {
        await provider.request({
            method: WALLET_ACTION.SWITCH_CHAIN,
            params: [{ chainId: `0x${chainID.toString(16)}` }],
        });
    }
}

const ERRORS = {
    // TODO: remove once fixed - consider using something in line with the naming convention
    // eslint-disable-next-line @typescript-eslint/naming-convention
    PROVIDER_NOT_FOUND: 'The Metamask provider was not found',
};
async function connect$1({ chainID, }) {
    const provider = (await detectEthereumProvider());
    if (!isRequestableProvider(provider)) {
        throw new Error(ERRORS.PROVIDER_NOT_FOUND);
    }
    await connectProvider(provider, chainID);
    // NOTE: if we want to listen to Metamask events in the future, we can add a
    // listener here.
    return new ethers.providers.Web3Provider(provider);
}

const COMMUNICATION_TYPE = 'message';
var RequestEventType;
(function (RequestEventType) {
    RequestEventType["GET_CONNECTION_REQUEST"] = "GET_CONNECTION_REQUEST";
    RequestEventType["CONNECT_WALLET_REQUEST"] = "CONNECT_WALLET_REQUEST";
    RequestEventType["SIGN_MESSAGE_REQUEST"] = "SIGN_MESSAGE_REQUEST";
    RequestEventType["DISCONNECT_WALLET_REQUEST"] = "DISCONNECT_WALLET_REQUEST";
})(RequestEventType || (RequestEventType = {}));
var ResponseEventType;
(function (ResponseEventType) {
    ResponseEventType["CONNECT_WALLET_RESPONSE"] = "CONNECT_WALLET_RESPONSE";
    ResponseEventType["SIGN_MESSAGE_RESPONSE"] = "SIGN_MESSAGE_RESPONSE";
    ResponseEventType["GET_CONNECTION_RESPONSE"] = "GET_CONNECTION_RESPONSE";
    ResponseEventType["DISCONNECT_WALLET_RESPONSE"] = "DISCONNECT_WALLET_RESPONSE";
})(ResponseEventType || (ResponseEventType = {}));

function postRequestMessage(iframe, payload) {
    if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage(payload, new URL(iframe.src).origin);
    }
}

function messageResponseListener(iframe, event, eventType, callback) {
    if (iframe && event.source !== iframe.contentWindow) {
        return;
    }
    const l2WalletMessage = event.data;
    if (l2WalletMessage.type !== eventType) {
        return;
    }
    callback(l2WalletMessage.details);
}

class ImxSigner {
    publicAddress;
    iframe;
    constructor(publicAddress, iframe) {
        this.publicAddress = publicAddress;
        this.iframe = iframe;
    }
    getAddress() {
        return this.publicAddress;
    }
    signMessage(rawMessage) {
        return new Promise((resolve, reject) => {
            const listener = (event) => {
                messageResponseListener(this.iframe, event, ResponseEventType.SIGN_MESSAGE_RESPONSE, (messageDetails) => {
                    window.removeEventListener(COMMUNICATION_TYPE, listener);
                    if (!messageDetails.success) {
                        reject(new Error(messageDetails.error?.message));
                    }
                    resolve(messageDetails.data.signedMessage);
                });
            };
            window.addEventListener(COMMUNICATION_TYPE, listener);
            postRequestMessage(this.iframe, {
                type: RequestEventType.SIGN_MESSAGE_REQUEST,
                details: { starkPublicKey: this.publicAddress, message: rawMessage },
            });
        });
    }
    getIFrame() {
        return this.iframe;
    }
}

const IMX_WALLET_IFRAME_ID = 'imx-wallet-app';
const IMX_WALLET_IFRAME_HOSTS = {
    [Environment$1.SANDBOX]: 'https://wallets.sandbox.immutable.com',
    [Environment$1.PRODUCTION]: 'https://wallets.immutable.com',
};
const IMX_WALLET_IFRAME_STYLE = 'display: none;';
function getIFrame() {
    return document.querySelector(`iframe#${IMX_WALLET_IFRAME_ID}`);
}
async function setupIFrame(env) {
    return new Promise((resolve) => {
        const iframe = document.createElement('iframe');
        iframe.setAttribute('id', IMX_WALLET_IFRAME_ID);
        iframe.setAttribute('src', IMX_WALLET_IFRAME_HOSTS[env]);
        iframe.setAttribute('style', IMX_WALLET_IFRAME_STYLE);
        document.body.appendChild(iframe);
        iframe.onload = () => resolve(iframe);
    });
}
async function getOrSetupIFrame(env) {
    const iframe = getIFrame();
    if (iframe)
        return iframe;
    return await setupIFrame(env);
}

const DEFAULT_CONNECTION_MESSAGE = 'Only sign this request if youve initiated an action with Immutable X.';
const CONNECTION_FAILED_ERROR = 'The L2 IMX Wallet connection has failed';
async function connect(l1Provider, env) {
    const l1Signer = l1Provider.getSigner();
    const address = await l1Signer.getAddress();
    const signature = await l1Signer.signMessage(DEFAULT_CONNECTION_MESSAGE);
    const iframe = await getOrSetupIFrame(env);
    return new Promise((resolve, reject) => {
        const listener = (event) => {
            messageResponseListener(iframe, event, ResponseEventType.CONNECT_WALLET_RESPONSE, (messageDetails) => {
                window.removeEventListener(COMMUNICATION_TYPE, listener);
                if (!messageDetails.success) {
                    reject(new Error(CONNECTION_FAILED_ERROR));
                }
                resolve(new ImxSigner(messageDetails.data.starkPublicKey, iframe));
            });
        };
        window.addEventListener(COMMUNICATION_TYPE, listener);
        postRequestMessage(iframe, {
            type: RequestEventType.CONNECT_WALLET_REQUEST,
            details: { ethAddress: address, signature },
        });
    });
}
async function disconnect(imxSigner) {
    const iframe = imxSigner.getIFrame();
    return new Promise((resolve, reject) => {
        const listener = (event) => {
            messageResponseListener(iframe, event, ResponseEventType.DISCONNECT_WALLET_RESPONSE, (messageDetails) => {
                window.removeEventListener(COMMUNICATION_TYPE, listener);
                if (!messageDetails.success && messageDetails.error) {
                    reject(messageDetails.error);
                }
                iframe.remove();
                resolve();
            });
        };
        window.addEventListener(COMMUNICATION_TYPE, listener);
        postRequestMessage(iframe, {
            type: RequestEventType.DISCONNECT_WALLET_REQUEST,
            details: { starkPublicKey: imxSigner.getAddress() },
        });
    });
}

var ProviderErrorType;
(function (ProviderErrorType) {
    ProviderErrorType["PROVIDER_CONNECTION_ERROR"] = "PROVIDER_CONNECTION_ERROR";
    ProviderErrorType["WALLET_CONNECTION_ERROR"] = "WALLET_CONNECTION_ERROR";
})(ProviderErrorType || (ProviderErrorType = {}));
class ProviderError extends Error {
    type;
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
const withProviderError = async (fn, customError) => {
    try {
        return await fn();
    }
    catch (error) {
        const errorMessage = customError.message || `${error.message}` || 'UnknownError';
        throw new ProviderError(errorMessage, customError.type);
    }
};

class MetaMaskIMXProvider extends GenericIMXProvider {
    static imxSigner;
    static async connect(config) {
        return await withProviderError(async () => {
            const metaMaskProvider = await connect$1({
                chainID: config.immutableXConfig.ethConfiguration.chainID,
            });
            this.imxSigner = await connect(metaMaskProvider, config.baseConfig.environment);
            return new MetaMaskIMXProvider(config, metaMaskProvider.getSigner(), this.imxSigner);
        }, { type: ProviderErrorType.WALLET_CONNECTION_ERROR });
    }
    static async disconnect() {
        if (!this.imxSigner) {
            throw new ProviderError('Attempted to disconnect from the MetaMask IMX provider without an established connection', ProviderErrorType.PROVIDER_CONNECTION_ERROR);
        }
        return withProviderError(async () => {
            await disconnect(this.imxSigner);
        }, { type: ProviderErrorType.PROVIDER_CONNECTION_ERROR });
    }
    static async signMessage(message) {
        if (!this.imxSigner) {
            throw new ProviderError('Attempted to sign a message with the MetaMask IMX provider without an established connection', ProviderErrorType.PROVIDER_CONNECTION_ERROR);
        }
        return withProviderError(async () => await this.imxSigner.signMessage(message), { type: ProviderErrorType.PROVIDER_CONNECTION_ERROR });
    }
}

class ProviderConfiguration {
    immutableXConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.immutableXConfig = overrides.immutableXConfig;
        }
        else {
            // TODO: remove once a sensible default is chosen
            // eslint-disable-next-line default-case
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.immutableXConfig = Config.SANDBOX;
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.immutableXConfig = Config.PRODUCTION;
                    break;
                }
            }
        }
    }
}

var provider = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GenericIMXProvider: GenericIMXProvider,
    MetaMaskIMXProvider: MetaMaskIMXProvider,
    ProviderConfiguration: ProviderConfiguration
});

/**
 * @constant {string} ETH_SEPOLIA_CHAIN_ID - The chain ID for the Ethereum Sepolia testnet (EIP-155 compatible format).
 */
const ETH_SEPOLIA_CHAIN_ID = '11155111';
/**
 * @constant {string} ETH_MAINNET_CHAIN_ID - The chain ID for the Ethereum mainnet (EIP-155 compatible format).
 */
const ETH_MAINNET_CHAIN_ID = '1';
/**
 * @constant {string} ZKEVM_DEVNET_CHAIN_ID - The chain ID for the zkEVM devnet (EIP-155 compatible format).
 */
const ZKEVM_DEVNET_CHAIN_ID = '13473';
/**
 * @constant {string} ZKEVM_TESTNET_CHAIN_ID - The chain ID for the zkEVM testnet (EIP-155 compatible format).
 */
const ZKEVM_TESTNET_CHAIN_ID = '13473';
/**
 * @constant {string} ZKEVM_MAINNET_CHAIN_ID - The chain ID for the zkEVM mainnet (EIP-155 compatible format).
 */
const ZKEVM_MAINNET_CHAIN_ID = '13371';
/**
 * @constant {string} L2_STATE_SENDER_ADDRESS - Address of bridge contract to the rootchain
 */
const L2_STATE_SENDER_ADDRESS = '0x0000000000000000000000000000000000001002';
/**
 * The constant value representing the native token in the token bridge context.
 * The key is used to indicate the native token of a blockchain network (like Ether in Ethereum)
 *  in methods that normally require a token address.
 * @constant {string}
 */
const NATIVE_TOKEN_BRIDGE_KEY = '0x0000000000000000000000000000000000000001';
/**
 * @constant {BridgeInstance} ETH_SEPOLIA_TO_ZKEVM_DEVNET - A bridge instance configuration for bridging between
 * the Ethereum Sepolia testnet and the zkEVM devnet.
 */
const ETH_SEPOLIA_TO_ZKEVM_DEVNET = {
    rootChainID: ETH_SEPOLIA_CHAIN_ID,
    childChainID: ZKEVM_DEVNET_CHAIN_ID,
};
/**
 * @constant {BridgeInstance} ETH_SEPOLIA_TO_ZKEVM_TESTNET - A bridge instance configuration for bridging
 * between the Ethereum Sepolia testnet and the zkEVM testnet.
 */
const ETH_SEPOLIA_TO_ZKEVM_TESTNET = {
    rootChainID: ETH_SEPOLIA_CHAIN_ID,
    childChainID: ZKEVM_TESTNET_CHAIN_ID,
};
/**
 * @constant {BridgeInstance} ETH_MAINNET_TO_ZKEVM_MAINNET - A bridge instance configuration for bridging
 * between the Ethereum mainnet and the zkEVM mainnet.
 */
const ETH_MAINNET_TO_ZKEVM_MAINNET = {
    rootChainID: ETH_MAINNET_CHAIN_ID,
    childChainID: ZKEVM_MAINNET_CHAIN_ID,
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bn = {exports: {}};

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require('buffer').Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [number & 0x3ffffff];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [0];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this._strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // '0' - '9'
	    if (c >= 48 && c <= 57) {
	      return c - 48;
	    // 'A' - 'F'
	    } else if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    } else {
	      assert(false, 'Invalid character in ' + string);
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this._strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var b = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        b = c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        b = c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        b = c;
	      }
	      assert(c >= 0 && b < mul, 'Invalid character');
	      r += b;
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [0];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this._strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  function move (dest, src) {
	    dest.words = src.words;
	    dest.length = src.length;
	    dest.negative = src.negative;
	    dest.red = src.red;
	  }

	  BN.prototype._move = function _move (dest) {
	    move(dest, this);
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype._strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  // Check Symbol.for because not everywhere where Symbol defined
	  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
	  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
	    try {
	      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
	    } catch (e) {
	      BN.prototype.inspect = inspect;
	    }
	  } else {
	    BN.prototype.inspect = inspect;
	  }

	  function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  }

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modrn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16, 2);
	  };

	  if (Buffer) {
	    BN.prototype.toBuffer = function toBuffer (endian, length) {
	      return this.toArrayLike(Buffer, endian, length);
	    };
	  }

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  var allocate = function allocate (ArrayType, size) {
	    if (ArrayType.allocUnsafe) {
	      return ArrayType.allocUnsafe(size);
	    }
	    return new ArrayType(size);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    this._strip();

	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    var res = allocate(ArrayType, reqLength);
	    var postfix = endian === 'le' ? 'LE' : 'BE';
	    this['_toArrayLike' + postfix](res, byteLength);
	    return res;
	  };

	  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
	    var position = 0;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position++] = word & 0xff;
	      if (position < res.length) {
	        res[position++] = (word >> 8) & 0xff;
	      }
	      if (position < res.length) {
	        res[position++] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position < res.length) {
	          res[position++] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position < res.length) {
	      res[position++] = carry;

	      while (position < res.length) {
	        res[position++] = 0;
	      }
	    }
	  };

	  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
	    var position = res.length - 1;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position--] = word & 0xff;
	      if (position >= 0) {
	        res[position--] = (word >> 8) & 0xff;
	      }
	      if (position >= 0) {
	        res[position--] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position >= 0) {
	          res[position--] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position >= 0) {
	      res[position--] = carry;

	      while (position >= 0) {
	        res[position--] = 0;
	      }
	    }
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] >>> wbit) & 0x01;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this._strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this._strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this._strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this._strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this._strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this._strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  function jumboMulTo (self, num, out) {
	    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
	    // var fftm = new FFTM();
	    // return fftm.mulp(self, num, out);
	    return bigMulTo(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this._strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) <= num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this._strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this._strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this._strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q._strip();
	    }
	    a._strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modrn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modrn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modrn = function modrn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return isNegNum ? -acc : acc;
	  };

	  // WARNING: DEPRECATED
	  BN.prototype.modn = function modn (num) {
	    return this.modrn(num);
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    this._strip();
	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this._strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is a BN v4 instance
	        r.strip();
	      } else {
	        // r is a BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

	    move(a, a.umod(this.m)._forceRed(this));
	    return a;
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn));

var bnExports = bn.exports;
var BN$1 = /*@__PURE__*/getDefaultExportFromCjs(bnExports);

const version$b = "logger/5.7.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$b);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$a = "bytes/5.7.0";

const logger$e = new Logger(version$a);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$e.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$e.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$e.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$e.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$e.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$e.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$e.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$e.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$e.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}

const version$9 = "bignumber/5.7.0";

var BN = BN$1.BN;
const logger$d = new Logger(version$9);
const _constructorGuard$1 = {};
const MAX_SAFE = 0x1fffffffffffff;
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$d.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$d.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$d.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$d.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$d.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$1, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$1, toHex(new BN(value)));
            }
            return logger$d.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$d.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$d.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$d.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}

const version$8 = "properties/5.7.0";

var __awaiter$3 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$c = new Logger(version$8);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter$3(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$c.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$c.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$7 = "abi/5.7.0";

const logger$b = new Logger(version$7);
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$b.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$b.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$b.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$b.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$b.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$b.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$b.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$b.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$b.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$b.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$b.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$b.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$b.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$b.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$b.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$b.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$b.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$b.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$b.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$b.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$b.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$b.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$b.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$b.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$b.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$b.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$b.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$b.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$b.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$b.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

const logger$a = new Logger(version$7);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$a.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$a.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$a.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

var sha3$1 = {exports: {}};

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */

(function (module) {
	/*jslint bitwise: true */
	(function () {

	  var INPUT_ERROR = 'input is invalid type';
	  var FINALIZE_ERROR = 'finalize already called';
	  var WINDOW = typeof window === 'object';
	  var root = WINDOW ? window : {};
	  if (root.JS_SHA3_NO_WINDOW) {
	    WINDOW = false;
	  }
	  var WEB_WORKER = !WINDOW && typeof self === 'object';
	  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
	  if (NODE_JS) {
	    root = commonjsGlobal;
	  } else if (WEB_WORKER) {
	    root = self;
	  }
	  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
	  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
	  var HEX_CHARS = '0123456789abcdef'.split('');
	  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
	  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
	  var KECCAK_PADDING = [1, 256, 65536, 16777216];
	  var PADDING = [6, 1536, 393216, 100663296];
	  var SHIFT = [0, 8, 16, 24];
	  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
	    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
	    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
	    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
	    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
	  var BITS = [224, 256, 384, 512];
	  var SHAKE_BITS = [128, 256];
	  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
	  var CSHAKE_BYTEPAD = {
	    '128': 168,
	    '256': 136
	  };

	  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
	    Array.isArray = function (obj) {
	      return Object.prototype.toString.call(obj) === '[object Array]';
	    };
	  }

	  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
	    ArrayBuffer.isView = function (obj) {
	      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
	    };
	  }

	  var createOutputMethod = function (bits, padding, outputType) {
	    return function (message) {
	      return new Keccak(bits, padding, bits).update(message)[outputType]();
	    };
	  };

	  var createShakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits) {
	      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
	    };
	  };

	  var createCshakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits, n, s) {
	      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
	    };
	  };

	  var createKmacOutputMethod = function (bits, padding, outputType) {
	    return function (key, message, outputBits, s) {
	      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
	    };
	  };

	  var createOutputMethods = function (method, createMethod, bits, padding) {
	    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
	      var type = OUTPUT_TYPES[i];
	      method[type] = createMethod(bits, padding, type);
	    }
	    return method;
	  };

	  var createMethod = function (bits, padding) {
	    var method = createOutputMethod(bits, padding, 'hex');
	    method.create = function () {
	      return new Keccak(bits, padding, bits);
	    };
	    method.update = function (message) {
	      return method.create().update(message);
	    };
	    return createOutputMethods(method, createOutputMethod, bits, padding);
	  };

	  var createShakeMethod = function (bits, padding) {
	    var method = createShakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits) {
	      return new Keccak(bits, padding, outputBits);
	    };
	    method.update = function (message, outputBits) {
	      return method.create(outputBits).update(message);
	    };
	    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
	  };

	  var createCshakeMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createCshakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits, n, s) {
	      if (!n && !s) {
	        return methods['shake' + bits].create(outputBits);
	      } else {
	        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
	      }
	    };
	    method.update = function (message, outputBits, n, s) {
	      return method.create(outputBits, n, s).update(message);
	    };
	    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
	  };

	  var createKmacMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createKmacOutputMethod(bits, padding, 'hex');
	    method.create = function (key, outputBits, s) {
	      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
	    };
	    method.update = function (key, message, outputBits, s) {
	      return method.create(key, outputBits, s).update(message);
	    };
	    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
	  };

	  var algorithms = [
	    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
	    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
	    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
	  ];

	  var methods = {}, methodNames = [];

	  for (var i = 0; i < algorithms.length; ++i) {
	    var algorithm = algorithms[i];
	    var bits = algorithm.bits;
	    for (var j = 0; j < bits.length; ++j) {
	      var methodName = algorithm.name + '_' + bits[j];
	      methodNames.push(methodName);
	      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
	      if (algorithm.name !== 'sha3') {
	        var newMethodName = algorithm.name + bits[j];
	        methodNames.push(newMethodName);
	        methods[newMethodName] = methods[methodName];
	      }
	    }
	  }

	  function Keccak(bits, padding, outputBits) {
	    this.blocks = [];
	    this.s = [];
	    this.padding = padding;
	    this.outputBits = outputBits;
	    this.reset = true;
	    this.finalized = false;
	    this.block = 0;
	    this.start = 0;
	    this.blockCount = (1600 - (bits << 1)) >> 5;
	    this.byteCount = this.blockCount << 2;
	    this.outputBlocks = outputBits >> 5;
	    this.extraBytes = (outputBits & 31) >> 3;

	    for (var i = 0; i < 50; ++i) {
	      this.s[i] = 0;
	    }
	  }

	  Keccak.prototype.update = function (message) {
	    if (this.finalized) {
	      throw new Error(FINALIZE_ERROR);
	    }
	    var notString, type = typeof message;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (message === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
	          message = new Uint8Array(message);
	        } else if (!Array.isArray(message)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
	      blockCount = this.blockCount, index = 0, s = this.s, i, code;

	    while (index < length) {
	      if (this.reset) {
	        this.reset = false;
	        blocks[0] = this.block;
	        for (i = 1; i < blockCount + 1; ++i) {
	          blocks[i] = 0;
	        }
	      }
	      if (notString) {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	        }
	      } else {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          code = message.charCodeAt(index);
	          if (code < 0x80) {
	            blocks[i >> 2] |= code << SHIFT[i++ & 3];
	          } else if (code < 0x800) {
	            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else if (code < 0xd800 || code >= 0xe000) {
	            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else {
	            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
	            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          }
	        }
	      }
	      this.lastByteIndex = i;
	      if (i >= byteCount) {
	        this.start = i - byteCount;
	        this.block = blocks[blockCount];
	        for (i = 0; i < blockCount; ++i) {
	          s[i] ^= blocks[i];
	        }
	        f(s);
	        this.reset = true;
	      } else {
	        this.start = i;
	      }
	    }
	    return this;
	  };

	  Keccak.prototype.encode = function (x, right) {
	    var o = x & 255, n = 1;
	    var bytes = [o];
	    x = x >> 8;
	    o = x & 255;
	    while (o > 0) {
	      bytes.unshift(o);
	      x = x >> 8;
	      o = x & 255;
	      ++n;
	    }
	    if (right) {
	      bytes.push(n);
	    } else {
	      bytes.unshift(n);
	    }
	    this.update(bytes);
	    return bytes.length;
	  };

	  Keccak.prototype.encodeString = function (str) {
	    var notString, type = typeof str;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (str === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
	          str = new Uint8Array(str);
	        } else if (!Array.isArray(str)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var bytes = 0, length = str.length;
	    if (notString) {
	      bytes = length;
	    } else {
	      for (var i = 0; i < str.length; ++i) {
	        var code = str.charCodeAt(i);
	        if (code < 0x80) {
	          bytes += 1;
	        } else if (code < 0x800) {
	          bytes += 2;
	        } else if (code < 0xd800 || code >= 0xe000) {
	          bytes += 3;
	        } else {
	          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
	          bytes += 4;
	        }
	      }
	    }
	    bytes += this.encode(bytes * 8);
	    this.update(str);
	    return bytes;
	  };

	  Keccak.prototype.bytepad = function (strs, w) {
	    var bytes = this.encode(w);
	    for (var i = 0; i < strs.length; ++i) {
	      bytes += this.encodeString(strs[i]);
	    }
	    var paddingBytes = w - bytes % w;
	    var zeros = [];
	    zeros.length = paddingBytes;
	    this.update(zeros);
	    return this;
	  };

	  Keccak.prototype.finalize = function () {
	    if (this.finalized) {
	      return;
	    }
	    this.finalized = true;
	    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
	    blocks[i >> 2] |= this.padding[i & 3];
	    if (this.lastByteIndex === this.byteCount) {
	      blocks[0] = blocks[blockCount];
	      for (i = 1; i < blockCount + 1; ++i) {
	        blocks[i] = 0;
	      }
	    }
	    blocks[blockCount - 1] |= 0x80000000;
	    for (i = 0; i < blockCount; ++i) {
	      s[i] ^= blocks[i];
	    }
	    f(s);
	  };

	  Keccak.prototype.toString = Keccak.prototype.hex = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var hex = '', block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        block = s[i];
	        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
	          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
	          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
	          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	        i = 0;
	      }
	    }
	    if (extraBytes) {
	      block = s[i];
	      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
	      if (extraBytes > 1) {
	        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
	      }
	      if (extraBytes > 2) {
	        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
	      }
	    }
	    return hex;
	  };

	  Keccak.prototype.arrayBuffer = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var bytes = this.outputBits >> 3;
	    var buffer;
	    if (extraBytes) {
	      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
	    } else {
	      buffer = new ArrayBuffer(bytes);
	    }
	    var array = new Uint32Array(buffer);
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        array[j] = s[i];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      array[i] = s[i];
	      buffer = buffer.slice(0, bytes);
	    }
	    return buffer;
	  };

	  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

	  Keccak.prototype.digest = Keccak.prototype.array = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var array = [], offset, block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        offset = j << 2;
	        block = s[i];
	        array[offset] = block & 0xFF;
	        array[offset + 1] = (block >> 8) & 0xFF;
	        array[offset + 2] = (block >> 16) & 0xFF;
	        array[offset + 3] = (block >> 24) & 0xFF;
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      offset = j << 2;
	      block = s[i];
	      array[offset] = block & 0xFF;
	      if (extraBytes > 1) {
	        array[offset + 1] = (block >> 8) & 0xFF;
	      }
	      if (extraBytes > 2) {
	        array[offset + 2] = (block >> 16) & 0xFF;
	      }
	    }
	    return array;
	  };

	  function Kmac(bits, padding, outputBits) {
	    Keccak.call(this, bits, padding, outputBits);
	  }

	  Kmac.prototype = new Keccak();

	  Kmac.prototype.finalize = function () {
	    this.encode(this.outputBits, true);
	    return Keccak.prototype.finalize.call(this);
	  };

	  var f = function (s) {
	    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
	      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
	      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
	      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
	    for (n = 0; n < 48; n += 2) {
	      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

	      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
	      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
	      s[0] ^= h;
	      s[1] ^= l;
	      s[10] ^= h;
	      s[11] ^= l;
	      s[20] ^= h;
	      s[21] ^= l;
	      s[30] ^= h;
	      s[31] ^= l;
	      s[40] ^= h;
	      s[41] ^= l;
	      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
	      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
	      s[2] ^= h;
	      s[3] ^= l;
	      s[12] ^= h;
	      s[13] ^= l;
	      s[22] ^= h;
	      s[23] ^= l;
	      s[32] ^= h;
	      s[33] ^= l;
	      s[42] ^= h;
	      s[43] ^= l;
	      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
	      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
	      s[4] ^= h;
	      s[5] ^= l;
	      s[14] ^= h;
	      s[15] ^= l;
	      s[24] ^= h;
	      s[25] ^= l;
	      s[34] ^= h;
	      s[35] ^= l;
	      s[44] ^= h;
	      s[45] ^= l;
	      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
	      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
	      s[6] ^= h;
	      s[7] ^= l;
	      s[16] ^= h;
	      s[17] ^= l;
	      s[26] ^= h;
	      s[27] ^= l;
	      s[36] ^= h;
	      s[37] ^= l;
	      s[46] ^= h;
	      s[47] ^= l;
	      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
	      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
	      s[8] ^= h;
	      s[9] ^= l;
	      s[18] ^= h;
	      s[19] ^= l;
	      s[28] ^= h;
	      s[29] ^= l;
	      s[38] ^= h;
	      s[39] ^= l;
	      s[48] ^= h;
	      s[49] ^= l;

	      b0 = s[0];
	      b1 = s[1];
	      b32 = (s[11] << 4) | (s[10] >>> 28);
	      b33 = (s[10] << 4) | (s[11] >>> 28);
	      b14 = (s[20] << 3) | (s[21] >>> 29);
	      b15 = (s[21] << 3) | (s[20] >>> 29);
	      b46 = (s[31] << 9) | (s[30] >>> 23);
	      b47 = (s[30] << 9) | (s[31] >>> 23);
	      b28 = (s[40] << 18) | (s[41] >>> 14);
	      b29 = (s[41] << 18) | (s[40] >>> 14);
	      b20 = (s[2] << 1) | (s[3] >>> 31);
	      b21 = (s[3] << 1) | (s[2] >>> 31);
	      b2 = (s[13] << 12) | (s[12] >>> 20);
	      b3 = (s[12] << 12) | (s[13] >>> 20);
	      b34 = (s[22] << 10) | (s[23] >>> 22);
	      b35 = (s[23] << 10) | (s[22] >>> 22);
	      b16 = (s[33] << 13) | (s[32] >>> 19);
	      b17 = (s[32] << 13) | (s[33] >>> 19);
	      b48 = (s[42] << 2) | (s[43] >>> 30);
	      b49 = (s[43] << 2) | (s[42] >>> 30);
	      b40 = (s[5] << 30) | (s[4] >>> 2);
	      b41 = (s[4] << 30) | (s[5] >>> 2);
	      b22 = (s[14] << 6) | (s[15] >>> 26);
	      b23 = (s[15] << 6) | (s[14] >>> 26);
	      b4 = (s[25] << 11) | (s[24] >>> 21);
	      b5 = (s[24] << 11) | (s[25] >>> 21);
	      b36 = (s[34] << 15) | (s[35] >>> 17);
	      b37 = (s[35] << 15) | (s[34] >>> 17);
	      b18 = (s[45] << 29) | (s[44] >>> 3);
	      b19 = (s[44] << 29) | (s[45] >>> 3);
	      b10 = (s[6] << 28) | (s[7] >>> 4);
	      b11 = (s[7] << 28) | (s[6] >>> 4);
	      b42 = (s[17] << 23) | (s[16] >>> 9);
	      b43 = (s[16] << 23) | (s[17] >>> 9);
	      b24 = (s[26] << 25) | (s[27] >>> 7);
	      b25 = (s[27] << 25) | (s[26] >>> 7);
	      b6 = (s[36] << 21) | (s[37] >>> 11);
	      b7 = (s[37] << 21) | (s[36] >>> 11);
	      b38 = (s[47] << 24) | (s[46] >>> 8);
	      b39 = (s[46] << 24) | (s[47] >>> 8);
	      b30 = (s[8] << 27) | (s[9] >>> 5);
	      b31 = (s[9] << 27) | (s[8] >>> 5);
	      b12 = (s[18] << 20) | (s[19] >>> 12);
	      b13 = (s[19] << 20) | (s[18] >>> 12);
	      b44 = (s[29] << 7) | (s[28] >>> 25);
	      b45 = (s[28] << 7) | (s[29] >>> 25);
	      b26 = (s[38] << 8) | (s[39] >>> 24);
	      b27 = (s[39] << 8) | (s[38] >>> 24);
	      b8 = (s[48] << 14) | (s[49] >>> 18);
	      b9 = (s[49] << 14) | (s[48] >>> 18);

	      s[0] = b0 ^ (~b2 & b4);
	      s[1] = b1 ^ (~b3 & b5);
	      s[10] = b10 ^ (~b12 & b14);
	      s[11] = b11 ^ (~b13 & b15);
	      s[20] = b20 ^ (~b22 & b24);
	      s[21] = b21 ^ (~b23 & b25);
	      s[30] = b30 ^ (~b32 & b34);
	      s[31] = b31 ^ (~b33 & b35);
	      s[40] = b40 ^ (~b42 & b44);
	      s[41] = b41 ^ (~b43 & b45);
	      s[2] = b2 ^ (~b4 & b6);
	      s[3] = b3 ^ (~b5 & b7);
	      s[12] = b12 ^ (~b14 & b16);
	      s[13] = b13 ^ (~b15 & b17);
	      s[22] = b22 ^ (~b24 & b26);
	      s[23] = b23 ^ (~b25 & b27);
	      s[32] = b32 ^ (~b34 & b36);
	      s[33] = b33 ^ (~b35 & b37);
	      s[42] = b42 ^ (~b44 & b46);
	      s[43] = b43 ^ (~b45 & b47);
	      s[4] = b4 ^ (~b6 & b8);
	      s[5] = b5 ^ (~b7 & b9);
	      s[14] = b14 ^ (~b16 & b18);
	      s[15] = b15 ^ (~b17 & b19);
	      s[24] = b24 ^ (~b26 & b28);
	      s[25] = b25 ^ (~b27 & b29);
	      s[34] = b34 ^ (~b36 & b38);
	      s[35] = b35 ^ (~b37 & b39);
	      s[44] = b44 ^ (~b46 & b48);
	      s[45] = b45 ^ (~b47 & b49);
	      s[6] = b6 ^ (~b8 & b0);
	      s[7] = b7 ^ (~b9 & b1);
	      s[16] = b16 ^ (~b18 & b10);
	      s[17] = b17 ^ (~b19 & b11);
	      s[26] = b26 ^ (~b28 & b20);
	      s[27] = b27 ^ (~b29 & b21);
	      s[36] = b36 ^ (~b38 & b30);
	      s[37] = b37 ^ (~b39 & b31);
	      s[46] = b46 ^ (~b48 & b40);
	      s[47] = b47 ^ (~b49 & b41);
	      s[8] = b8 ^ (~b0 & b2);
	      s[9] = b9 ^ (~b1 & b3);
	      s[18] = b18 ^ (~b10 & b12);
	      s[19] = b19 ^ (~b11 & b13);
	      s[28] = b28 ^ (~b20 & b22);
	      s[29] = b29 ^ (~b21 & b23);
	      s[38] = b38 ^ (~b30 & b32);
	      s[39] = b39 ^ (~b31 & b33);
	      s[48] = b48 ^ (~b40 & b42);
	      s[49] = b49 ^ (~b41 & b43);

	      s[0] ^= RC[n];
	      s[1] ^= RC[n + 1];
	    }
	  };

	  if (COMMON_JS) {
	    module.exports = methods;
	  } else {
	    for (i = 0; i < methodNames.length; ++i) {
	      root[methodNames[i]] = methods[methodNames[i]];
	    }
	  }
	})(); 
} (sha3$1));

var sha3Exports = sha3$1.exports;
var sha3 = /*@__PURE__*/getDefaultExportFromCjs(sha3Exports);

function keccak256(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$6 = "rlp/5.7.0";

const logger$9 = new Logger(version$6);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!isBytesLike(object)) {
        logger$9.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger$9.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger$9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger$9.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$9.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger$9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
}
function decode(data) {
    const bytes = arrayify(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger$9.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}

const version$5 = "address/5.7.0";

const logger$8 = new Logger(version$5);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$8.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$8.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger$8.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}

class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

const logger$7 = new Logger(version$7);
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$7.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$7.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$7.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$7.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$7.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$7.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));
const Zero = ( /*#__PURE__*/BigNumber.from(0));
const One = ( /*#__PURE__*/BigNumber.from(1));
const MaxUint256 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version$4 = "strings/5.7.0";

const logger$6 = new Logger(version$4);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$6.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$6.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

const logger$5 = new Logger(version$7);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$5.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$5.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$5.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$5.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256(toUtf8Bytes(text));
}

const logger$4 = new Logger(version$7);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger$4.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger$4.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger$4.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger$4.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger$4.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger$4.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger$4.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger$4.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger$4.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: hexlify(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger$4.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            if (param.type.match(/^u?int/)) {
                value = BigNumber.from(value).toHexString();
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger$4.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger$4.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger$4.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger$4.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

const version$3 = "abstract-provider/5.7.0";

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$3 = new Logger(version$3);
///////////////////////////////
// Exported Abstracts
class Provider {
    constructor() {
        logger$3.checkAbstract(new.target, Provider);
        defineReadOnly(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const { block, gasPrice } = yield resolveProperties({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error) => {
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                lastBaseFeePerGas = block.baseFeePerGas;
                maxPriorityFeePerGas = BigNumber.from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}

const version$2 = "abstract-signer/5.7.0";

var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$2 = new Logger(version$2);
const allowedTransactionKeys = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
const forwardErrors = [
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
];
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
        logger$2.checkAbstract(new.target, Signer);
        defineReadOnly(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("call");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger$2.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then((result) => {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    logger$2.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to) => __awaiter$1(this, void 0, void 0, function* () {
                    if (to == null) {
                        return null;
                    }
                    const address = yield this.resolveName(to);
                    if (address == null) {
                        logger$2.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return address;
                }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error) => { });
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                logger$2.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            }
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                logger$2.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            }
            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
            }
            else if (tx.type === 0 || tx.type === 1) {
                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                }
            }
            else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        }
                        else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                    }
                    else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) {
                            logger$2.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            });
                        }
                        // Populate missing fee data
                        if (tx.gasPrice == null) {
                            tx.gasPrice = feeData.gasPrice;
                        }
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    }
                    else {
                        // getFeeData has failed us.
                        logger$2.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                    }
                }
                else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                }
            }
            if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
            }
            if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch((error) => {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                    }
                    return logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                        error: error,
                        tx: tx
                    });
                });
            }
            if (tx.chainId == null) {
                tx.chainId = this.getChainId();
            }
            else {
                tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                ]).then((results) => {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                        logger$2.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                });
            }
            return yield resolveProperties(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) {
            logger$2.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(() => {
            logger$2.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}

const version$1 = "transactions/5.7.0";

const logger$1 = new Logger(version$1);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function accessSetify(addr, storageKeys) {
    return {
        address: getAddress(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if (hexDataLength(storageKey) !== 32) {
                logger$1.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    logger$1.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}

const version = "contracts/5.7.0";

var __awaiter = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new Logger(version);
function resolveName(resolver, nameOrPromise) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield nameOrPromise;
        if (typeof (name) !== "string") {
            logger.throwArgumentError("invalid address or ENS name", "name", name);
        }
        // If it is already an address, just use it (after adding checksum)
        try {
            return getAddress(name);
        }
        catch (error) { }
        if (!resolver) {
            logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName"
            });
        }
        const address = yield resolver.resolveName(name);
        if (address == null) {
            logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        }
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(paramType)) {
            return yield Promise.all(paramType.map((paramType, index) => {
                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);
            }));
        }
        if (paramType.type === "address") {
            return yield resolveName(resolver, value);
        }
        if (paramType.type === "tuple") {
            return yield resolveAddresses(resolver, value, paramType.components);
        }
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) {
                return Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value
                }));
            }
            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter(this, void 0, void 0, function* () {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            overrides = shallowCopy(args.pop());
        }
        // Make sure the parameter count matches
        logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) {
                // Contracts with a Signer are from the Signer's frame-of-reference;
                // but we allow overriding "from" if it matches the signer
                overrides.from = resolveProperties({
                    override: resolveName(contract.signer, overrides.from),
                    signer: contract.signer.getAddress()
                }).then((check) => __awaiter(this, void 0, void 0, function* () {
                    if (getAddress(check.signer) !== check.override) {
                        logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "overrides.from"
                        });
                    }
                    return check.override;
                }));
            }
            else {
                overrides.from = contract.signer.getAddress();
            }
        }
        else if (overrides.from) {
            overrides.from = resolveName(contract.provider, overrides.from);
            //} else {
            // Contracts without a signer can override "from", and if
            // unspecified the zero address is used
            //overrides.from = AddressZero;
        }
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield resolveProperties({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (resolveProperties(overrides) || {})
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) {
            tx.nonce = BigNumber.from(ro.nonce).toNumber();
        }
        if (ro.gasLimit != null) {
            tx.gasLimit = BigNumber.from(ro.gasLimit);
        }
        if (ro.gasPrice != null) {
            tx.gasPrice = BigNumber.from(ro.gasPrice);
        }
        if (ro.maxFeePerGas != null) {
            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
        }
        if (ro.maxPriorityFeePerGas != null) {
            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
        }
        if (ro.from != null) {
            tx.from = ro.from;
        }
        if (ro.type != null) {
            tx.type = ro.type;
        }
        if (ro.accessList != null) {
            tx.accessList = accessListify(ro.accessList);
        }
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = arrayify(data);
            for (let i = 0; i < bytes.length; i++) {
                intrinsic += 4;
                if (bytes[i]) {
                    intrinsic += 64;
                }
            }
            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = BigNumber.from(ro.value);
            if (!roValue.isZero() && !fragment.payable) {
                logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: overrides.value
                });
            }
            tx.value = roValue;
        }
        if (ro.customData) {
            tx.customData = shallowCopy(ro.customData);
        }
        if (ro.ccipReadEnabled) {
            tx.ccipReadEnabled = !!ro.ccipReadEnabled;
        }
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        delete overrides.ccipReadEnabled;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));
        if (leftovers.length) {
            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides",
                overrides: leftovers
            });
        }
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function (...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!signerOrProvider) {
                logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "estimateGas"
                });
            }
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
        return wait(confirmations).then((receipt) => {
            receipt.events = receipt.logs.map((log) => {
                let event = deepCopy(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                }
                catch (e) { }
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics) => {
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = () => { return contract.provider; };
                event.getBlock = () => {
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = () => {
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = () => {
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
                const overrides = shallowCopy(args.pop());
                if (overrides.blockTag != null) {
                    blockTag = yield overrides.blockTag;
                }
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed(blockTag);
            }
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) {
                    value = value[0];
                }
                return value;
            }
            catch (error) {
                if (error.code === Logger.errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contract.signer) {
                logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction"
                });
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed();
            }
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
        return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
}
function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
        return "*";
    }
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
        if (Array.isArray(topic)) {
            return topic.join("|");
        }
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({ listener: listener, once: once });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
            if (done || item.listener !== listener) {
                return true;
            }
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i) => i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(() => {
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !(item.once);
        });
        return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [event];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor() {
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) {
                logger.throwArgumentError("topic mismatch", "topics", topics);
            }
            filter.topics = topics.slice();
        }
        else {
            filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        }
        catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
            throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface) {
        super("*", { address: address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics) => {
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        }
        catch (error) {
            // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider) {
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            defineReadOnly(this, "provider", null);
            defineReadOnly(this, "signer", null);
        }
        else if (Signer.isSigner(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider.provider || null);
            defineReadOnly(this, "signer", signerOrProvider);
        }
        else if (Provider.isProvider(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider);
            defineReadOnly(this, "signer", null);
        }
        else {
            logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature) => {
                const event = this.interface.events[eventSignature];
                defineReadOnly(this.filters, eventSignature, (...args) => {
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) {
                    uniqueFilters[event.name] = [];
                }
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name) => {
                const filters = uniqueFilters[name];
                if (filters.length === 1) {
                    defineReadOnly(this.filters, name, this.filters[filters[0]]);
                }
                else {
                    logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
                }
            });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
            logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
            defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        }
        else {
            try {
                defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
            }
            catch (error) {
                // Without a provider, we cannot use ENS names
                logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract"
                });
            }
        }
        // Swallow bad ENS names to prevent Unhandled Exceptions
        this.resolvedAddress.catch((e) => { });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) {
                    uniqueNames[`%${name}`] = [];
                }
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) {
                defineReadOnly(this, signature, buildDefault(this, fragment, true));
            }
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) {
                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
            }
            if (this.callStatic[signature] == null) {
                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
            }
            if (this.populateTransaction[signature] == null) {
                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
            }
            if (this.estimateGas[signature] == null) {
                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
            }
        });
        Object.keys(uniqueNames).forEach((name) => {
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) {
                return;
            }
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) {
                    defineReadOnly(this, name, this[signature]);
                }
            }
            catch (e) { }
            if (this.functions[name] == null) {
                defineReadOnly(this.functions, name, this.functions[signature]);
            }
            if (this.callStatic[name] == null) {
                defineReadOnly(this.callStatic, name, this.callStatic[signature]);
            }
            if (this.populateTransaction[name] == null) {
                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
            }
            if (this.estimateGas[name] == null) {
                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
            }
        });
    }
    static getContractAddress(transaction) {
        return getContractAddress(transaction);
    }
    static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
            return contractInterface;
        }
        return new Interface(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) {
                this._deployedPromise = this.deployTransaction.wait().then(() => {
                    return this;
                });
            }
            else {
                // @TODO: Once we allow a timeout to be passed in, we will wait
                // up to that many blocks for getCode
                // Otherwise, poll for our code to be deployed
                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
                    if (code === "0x") {
                        logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                            contractAddress: this.address,
                            operation: "getDeployed"
                        });
                    }
                    return this;
                });
            }
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) {
            logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function (key) {
            if (tx[key] == null) {
                return;
            }
            logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof (signerOrProvider) === "string") {
            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
            defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) {
            return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof (eventName) === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") {
                return this._normalizeRunningEvent(new ErrorRunningEvent());
            }
            // Listen for any event that is registered
            if (eventName === "event") {
                return this._normalizeRunningEvent(new RunningEvent("event", null));
            }
            // Listen for any event
            if (eventName === "*") {
                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            }
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof (topic) !== "string") {
                    throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                }
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            }
            catch (error) { }
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
            if (!listener) {
                return;
            }
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };
        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };
        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
            logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no hard in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log) => {
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) {
                    try {
                        const args = runningEvent.getEmit(event);
                        this.emit(runningEvent.filter, ...args);
                    }
                    catch (error) {
                        event.decodeError = error.error;
                    }
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) {
                    this.emit("event", event);
                }
                // Emit "error" if there was an error
                if (event.decodeError != null) {
                    this.emit("error", event.decodeError, event);
                }
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) {
                this.provider.on(runningEvent.filter, wrappedEmit);
            }
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof (fromBlockOrBlockhash) === "string" && isHexString(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) {
                logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            }
            filter.blockHash = fromBlockOrBlockhash;
        }
        else {
            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);
            filter.toBlock = ((toBlock != null) ? toBlock : "latest");
        }
        return this.provider.getLogs(filter).then((logs) => {
            return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) {
            return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = (runningEvent.run(args) > 0);
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) {
            return 0;
        }
        if (eventName == null) {
            return Object.keys(this._runningEvents).reduce((accum, key) => {
                return accum + this._runningEvents[key].listenerCount();
            }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) {
            return [];
        }
        if (eventName == null) {
            const result = [];
            for (let tag in this._runningEvents) {
                this._runningEvents[tag].listeners().forEach((listener) => {
                    result.push(listener);
                });
            }
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) {
            return this;
        }
        if (eventName == null) {
            for (const tag in this._runningEvents) {
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) {
            return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}

/**
 * @typedef {Object} CompletionStatus
 * @property {string} SUCCESS - The transaction has been successfully synced.
 * @property {string} PENDING - The transaction is still pending.
 * @property {string} FAILED - The transaction has failed.
 */
var CompletionStatus;
(function (CompletionStatus) {
    CompletionStatus["SUCCESS"] = "SUCCESS";
    CompletionStatus["PENDING"] = "PENDING";
    CompletionStatus["FAILED"] = "FAILED";
})(CompletionStatus || (CompletionStatus = {}));

const ROOT_ERC20_PREDICATE = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'depositor',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'ERC20Deposit',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'withdrawer',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'ERC20Withdraw',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
        ],
        name: 'TokenMapped',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DEPOSIT_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'MAP_TOKEN_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'WITHDRAW_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childERC20Predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childTokenTemplate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'deposit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
        ],
        name: 'depositNativeTo',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'depositTo',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'exitHelper',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newStateSender',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newExitHelper',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildERC20Predicate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildTokenTemplate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'nativeTokenRootAddress',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
        ],
        name: 'mapToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'onL2StateReceive',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'rootTokenToChildToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'stateSender',
        outputs: [
            {
                internalType: 'contract IStateSender',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

const ERC20 = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_from',
                type: 'address',
            },
            {
                name: '_to',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_to',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'transfer',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
            {
                name: '_spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        payable: true,
        stateMutability: 'payable',
        type: 'fallback',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
];

/**
 * @enum {string} BridgeErrorType - Enumeration of different types of bridge errors.
 */
var BridgeErrorType;
(function (BridgeErrorType) {
    BridgeErrorType["UNSUPPORTED_ERROR"] = "UNSUPPORTED_ERROR";
    BridgeErrorType["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    BridgeErrorType["INVALID_AMOUNT"] = "INVALID_AMOUNT";
    BridgeErrorType["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    BridgeErrorType["PROVIDER_ERROR"] = "PROVIDER_ERROR";
    BridgeErrorType["TRANSACTION_REVERTED"] = "TRANSACTION_REVERTED";
    BridgeErrorType["INVALID_TOKEN"] = "INVALID_TOKEN";
    BridgeErrorType["INVALID_TRANSACTION"] = "INVALID_TRANSACTION";
})(BridgeErrorType || (BridgeErrorType = {}));
/**
 * Represents a custom error for bridge operations.
 * @extends Error
 */
class BridgeError extends Error {
    /**
     * @property {BridgeErrorType} type - The type of the bridge error.
     */
    type;
    /**
     * Constructs a BridgeError instance.
     *
     * @param {string} message - The error message.
     * @param {BridgeErrorType} type - The type of the bridge error.
     */
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
/**
 * A helper function that wraps a Promise function with error handling for bridge operations.
 *
 * @template T - The type of the value that the Promise resolves to.
 * @param {() => Promise<T>} fn - The function to wrap with error handling.
 * @param {BridgeErrorType} customErrorType - The custom error type to use for the error.
 * @param {string} [details] - Additional details to add to the error message.
 * @returns {Promise<T>} The result of the wrapped function or a rejected promise with a BridgeError.
 */
const withBridgeError = async (fn, customErrorType, details) => {
    try {
        return await fn();
    }
    catch (error) {
        let errorMessage = `${customErrorType}: ${error.message}` || 'UnknownError';
        if (details) {
            errorMessage = `${details}: ${errorMessage}`;
        }
        throw new BridgeError(errorMessage, customErrorType);
    }
};

const ROOT_STATE_SENDER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'StateSynced',
        type: 'event',
    },
    {
        inputs: [],
        name: 'MAX_LENGTH',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'counter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'syncState',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const CHILD_STATE_RECEIVER = [
    {
        inputs: [
            {
                internalType: 'string',
                name: 'only',
                type: 'string',
            },
        ],
        name: 'Unauthorized',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'startId',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'uint256',
                name: 'endId',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'root',
                type: 'bytes32',
            },
        ],
        name: 'NewCommitment',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'counter',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bool',
                name: 'status',
                type: 'bool',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'message',
                type: 'bytes',
            },
        ],
        name: 'StateSyncResult',
        type: 'event',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN_CONTRACT',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'SYSTEM',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32[][]',
                name: 'proofs',
                type: 'bytes32[][]',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'id',
                        type: 'uint256',
                    },
                    {
                        internalType: 'address',
                        name: 'sender',
                        type: 'address',
                    },
                    {
                        internalType: 'address',
                        name: 'receiver',
                        type: 'address',
                    },
                    {
                        internalType: 'bytes',
                        name: 'data',
                        type: 'bytes',
                    },
                ],
                internalType: 'struct StateReceiver.StateSync[]',
                name: 'objs',
                type: 'tuple[]',
            },
        ],
        name: 'batchExecute',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'startId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'endId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'root',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct StateReceiver.StateSyncCommitment',
                name: 'commitment',
                type: 'tuple',
            },
            {
                internalType: 'bytes',
                name: 'signature',
                type: 'bytes',
            },
            {
                internalType: 'bytes',
                name: 'bitmap',
                type: 'bytes',
            },
        ],
        name: 'commit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'commitmentCounter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'commitmentIds',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'commitments',
        outputs: [
            {
                internalType: 'uint256',
                name: 'startId',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'endId',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'root',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'id',
                        type: 'uint256',
                    },
                    {
                        internalType: 'address',
                        name: 'sender',
                        type: 'address',
                    },
                    {
                        internalType: 'address',
                        name: 'receiver',
                        type: 'address',
                    },
                    {
                        internalType: 'bytes',
                        name: 'data',
                        type: 'bytes',
                    },
                ],
                internalType: 'struct StateReceiver.StateSync',
                name: 'obj',
                type: 'tuple',
            },
        ],
        name: 'execute',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'getCommitmentByStateSyncId',
        outputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'startId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'endId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'root',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct StateReceiver.StateSyncCommitment',
                name: '',
                type: 'tuple',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'getRootByStateSyncId',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'lastCommittedId',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'processedStateSyncs',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

async function getBlockNumberClosestToTimestamp(provider, targetTimestamp, blockTime, clockInaccuracy) {
    let lowerBlockNumber = 0;
    let upperBlockNumber = await provider.getBlockNumber();
    while (upperBlockNumber !== lowerBlockNumber + 1) {
        const midBlockNumber = Math.floor((lowerBlockNumber + upperBlockNumber) / 2);
        // This is a valid use case to disable as results depend on previous results
        // eslint-disable-next-line no-await-in-loop
        const midBlock = await provider.getBlock(midBlockNumber);
        const timeDifference = targetTimestamp - midBlock.timestamp;
        if (timeDifference > clockInaccuracy && timeDifference < (blockTime + clockInaccuracy)) {
            return midBlockNumber;
        }
        if (midBlock.timestamp < targetTimestamp) {
            lowerBlockNumber = midBlockNumber;
        }
        else {
            upperBlockNumber = midBlockNumber;
        }
    }
    return lowerBlockNumber;
}

const CHILD_ERC20_PREDICATE = [
    {
        inputs: [
            {
                internalType: 'string',
                name: 'only',
                type: 'string',
            },
        ],
        name: 'Unauthorized',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'L2ERC20Deposit',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'L2ERC20Withdraw',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
        ],
        name: 'L2TokenMapped',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DEPOSIT_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'MAP_TOKEN_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN_CONTRACT',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'SYSTEM',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'WITHDRAW_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childTokenTemplate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newL2StateSender',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newStateReceiver',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newRootERC20Predicate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildTokenTemplate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newNativeTokenRootAddress',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'l2StateSender',
        outputs: [
            {
                internalType: 'contract IStateSender',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'onStateReceive',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'rootERC20Predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'rootTokenToChildToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'stateReceiver',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IChildERC20',
                name: 'childToken',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'withdraw',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IChildERC20',
                name: 'childToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'withdrawTo',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const CHECKPOINT_MANAGER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DOMAIN',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'bls',
        outputs: [
            {
                internalType: 'contract IBLS',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'bn256G2',
        outputs: [
            {
                internalType: 'contract IBN256G2',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'chainId',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'checkpointBlockNumbers',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'checkpoints',
        outputs: [
            {
                internalType: 'uint256',
                name: 'epoch',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'eventRoot',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentCheckpointBlockNumber',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentEpoch',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'currentValidatorSet',
        outputs: [
            {
                internalType: 'address',
                name: '_address',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'votingPower',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentValidatorSetHash',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentValidatorSetLength',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
        ],
        name: 'getCheckpointBlock',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'leaf',
                type: 'bytes32',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'getEventMembershipByBlockNumber',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'epoch',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'leaf',
                type: 'bytes32',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'getEventMembershipByEpoch',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
        ],
        name: 'getEventRootByBlock',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IBLS',
                name: 'newBls',
                type: 'address',
            },
            {
                internalType: 'contract IBN256G2',
                name: 'newBn256G2',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'chainId_',
                type: 'uint256',
            },
            {
                components: [
                    {
                        internalType: 'address',
                        name: '_address',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256[4]',
                        name: 'blsKey',
                        type: 'uint256[4]',
                    },
                    {
                        internalType: 'uint256',
                        name: 'votingPower',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct ICheckpointManager.Validator[]',
                name: 'newValidatorSet',
                type: 'tuple[]',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'bytes32',
                        name: 'blockHash',
                        type: 'bytes32',
                    },
                    {
                        internalType: 'uint256',
                        name: 'blockRound',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'currentValidatorSetHash',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct ICheckpointManager.CheckpointMetadata',
                name: 'checkpointMetadata',
                type: 'tuple',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'epoch',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'blockNumber',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'eventRoot',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct ICheckpointManager.Checkpoint',
                name: 'checkpoint',
                type: 'tuple',
            },
            {
                internalType: 'uint256[2]',
                name: 'signature',
                type: 'uint256[2]',
            },
            {
                components: [
                    {
                        internalType: 'address',
                        name: '_address',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256[4]',
                        name: 'blsKey',
                        type: 'uint256[4]',
                    },
                    {
                        internalType: 'uint256',
                        name: 'votingPower',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct ICheckpointManager.Validator[]',
                name: 'newValidatorSet',
                type: 'tuple[]',
            },
            {
                internalType: 'bytes',
                name: 'bitmap',
                type: 'bytes',
            },
        ],
        name: 'submit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalVotingPower',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

function decodeExtraData(extraData) {
    const decoded = decode(`0x${extraData.substring(66)}`);
    const blockExtraData = {
        validators: decoded[0],
        parent: decoded[1],
        committed: decoded[2],
        checkpoint: {
            blockRound: decoded[3][0],
            epochNumber: parseInt(decoded[3][1], 16),
            currentValidatorHash: decoded[3][2],
            nextValidatorHash: decoded[3][3],
            eventRoot: decoded[3][4],
        },
    };
    return blockExtraData;
}

const L2_STATE_SENDER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'L2StateSynced',
        type: 'event',
    },
    {
        inputs: [],
        name: 'MAX_LENGTH',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'counter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'syncState',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const EXIT_HELPER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bool',
                name: 'success',
                type: 'bool',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'returnData',
                type: 'bytes',
            },
        ],
        name: 'ExitProcessed',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'blockNumber',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'leafIndex',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes',
                        name: 'unhashedLeaf',
                        type: 'bytes',
                    },
                    {
                        internalType: 'bytes32[]',
                        name: 'proof',
                        type: 'bytes32[]',
                    },
                ],
                internalType: 'struct IExitHelper.BatchExitInput[]',
                name: 'inputs',
                type: 'tuple[]',
            },
        ],
        name: 'batchExit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'checkpointManager',
        outputs: [
            {
                internalType: 'contract ICheckpointManager',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes',
                name: 'unhashedLeaf',
                type: 'bytes',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'exit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract ICheckpointManager',
                name: 'newCheckpointManager',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'processedExits',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

const CHILD_ERC20 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'address',
                name: 'userAddress',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'relayerAddress',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'functionSignature',
                type: 'bytes',
            },
        ],
        name: 'MetaTransactionExecuted',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'burn',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                internalType: 'uint8',
                name: '',
                type: 'uint8',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'subtractedValue',
                type: 'uint256',
            },
        ],
        name: 'decreaseAllowance',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'userAddress',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'functionSignature',
                type: 'bytes',
            },
            {
                internalType: 'bytes32',
                name: 'sigR',
                type: 'bytes32',
            },
            {
                internalType: 'bytes32',
                name: 'sigS',
                type: 'bytes32',
            },
            {
                internalType: 'uint8',
                name: 'sigV',
                type: 'uint8',
            },
        ],
        name: 'executeMetaTransaction',
        outputs: [
            {
                internalType: 'bytes',
                name: '',
                type: 'bytes',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'user',
                type: 'address',
            },
        ],
        name: 'getNonce',
        outputs: [
            {
                internalType: 'uint256',
                name: 'nonce',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'addedValue',
                type: 'uint256',
            },
        ],
        name: 'increaseAllowance',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'rootToken_',
                type: 'address',
            },
            {
                internalType: 'string',
                name: 'name_',
                type: 'string',
            },
            {
                internalType: 'string',
                name: 'symbol_',
                type: 'string',
            },
            {
                internalType: 'uint8',
                name: 'decimals_',
                type: 'uint8',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'offset',
                type: 'uint256',
            },
        ],
        name: 'invalidateNext',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'mint',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'name',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'rootToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transfer',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

/**
 * Represents a token bridge, which manages asset transfers between two chains.
 */
class TokenBridge {
    /**
     * @property {BridgeConfiguration} config - The bridge configuration object.
     */
    config;
    /**
     * Constructs a TokenBridge instance.
     *
     * @param {BridgeConfiguration} config - The bridge configuration object.
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Retrieves the bridge fee for depositing a specific token, used to reimburse the bridge-relayer.
     * It is clipped from the deposit amount.
     *
     * @param {BridgeFeeRequest} req - The fee request object containing the token address for which the fee is required.
     * @returns {Promise<BridgeFeeResponse>} - A promise that resolves to an object containing the bridge fee for the specified
     * token and a flag indicating if the token is bridgeable.
     * @throws {BridgeError} - If an error occurs during the fee retrieval, a BridgeError will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - INVALID_ADDRESS: The token address provided in the request is invalid.
     *
     * @example
     * const feeRequest = {
     *   token: '0x123456...', // token
     * };
     *
     * @example
     * const feeRequest = {
     *   token: 'NATIVE', // token
     * };
     *
     * bridgeSdk.getFee(feeRequest)
     *   .then((feeResponse) => {
     *     console.log('Bridgeable:', feeResponse.bridgeable);
     *     console.log('Fee Amount:', feeResponse.feeAmount.toString());
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getFee(req) {
        this.validateChainConfiguration();
        if (req.token !== 'NATIVE' && !isAddress(req.token)) {
            throw new BridgeError(`token address ${req.token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        return {
            bridgeable: true,
            feeAmount: BigNumber.from(0),
        };
    }
    /**
     * Retrieves the unsigned approval transaction for a deposit to the bridge.
     * Approval is required before depositing tokens to the bridge using
     *
     * @param {ApproveBridgeRequest} req - The approve bridge request object containing the depositor address,
     * token address, and deposit amount.
     * @returns {Promise<ApproveBridgeResponse>} - A promise that resolves to an object containing the unsigned
     * approval transaction and a flag indicating if the approval is required.
     * @throws {BridgeError} - If an error occurs during the transaction creation, a BridgeError will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - UNSUPPORTED_ERROR: The operation is not supported. Currently thrown when attempting to deposit native tokens.
     * - INVALID_ADDRESS: An Ethereum address provided in the request is invalid.
     * - INVALID_AMOUNT: The deposit amount provided in the request is invalid (less than or equal to 0).
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     * - PROVIDER_ERROR: An error occurred while interacting with the Ethereum provider. This includes issues calling the ERC20 smart contract
     *
     * @example
     * const approveRequest = {
     *   depositorAddress: '0x123456...', // Depositor's Ethereum address
     *   token: '0xabcdef...', // ERC20 token address
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in token's smallest unit (e.g., wei for Ether)
     * };
     *
     * bridgeSdk.getUnsignedApproveDepositBridgeTx(approveRequest)
     *   .then((approveResponse) => {
     *     if (approveResponse.unsignedTx) {
     *       // Send the unsigned approval transaction to the depositor to sign and send
     *     } else {
     *      // No approval is required
     *     }
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedApproveDepositBridgeTx(req) {
        this.validateChainConfiguration();
        TokenBridge.validateDepositArgs(req.depositorAddress, req.depositAmount, req.token);
        // If the token is NATIVE, no approval is required
        if (req.token === 'NATIVE') {
            return {
                unsignedTx: null,
            };
        }
        const erc20Contract = await withBridgeError(async () => new Contract(req.token, ERC20, this.config.rootProvider), BridgeErrorType.PROVIDER_ERROR);
        // Get the current approved allowance of the RootERC20Predicate
        const rootERC20PredicateAllowance = await withBridgeError(() => erc20Contract
            .allowance(req.depositorAddress, this.config.bridgeContracts.rootChainERC20Predicate), BridgeErrorType.PROVIDER_ERROR);
        // If the allowance is greater than or equal to the deposit amount, no approval is required
        if (rootERC20PredicateAllowance.gte(req.depositAmount)) {
            return {
                unsignedTx: null,
            };
        }
        // Calculate the amount of tokens that need to be approved for deposit
        const approvalAmountRequired = req.depositAmount.sub(rootERC20PredicateAllowance);
        // Encode the approve function call data for the ERC20 contract
        const data = await withBridgeError(async () => erc20Contract.interface
            .encodeFunctionData('approve', [
            this.config.bridgeContracts.rootChainERC20Predicate,
            approvalAmountRequired,
        ]), BridgeErrorType.INTERNAL_ERROR);
        // Create the unsigned transaction for the approval
        const unsignedTx = {
            data,
            to: req.token,
            value: 0,
            from: req.depositorAddress,
        };
        return {
            unsignedTx,
        };
    }
    /**
     * Generates an unsigned deposit transaction for a user to sign and submit to the bridge.
     * Must be called after bridgeSdk.getUnsignedApproveDepositBridgeTx to ensure user has approved sufficient tokens for deposit.
     *
     * @param {BridgeDepositRequest} req - The deposit request object containing the required data for depositing tokens.
     * @returns {Promise<BridgeDepositResponse>} - A promise that resolves to an object containing the unsigned transaction data.
     * @throws {BridgeError} - If an error occurs during the generation of the unsigned transaction, a BridgeError
     * will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - UNSUPPORTED_ERROR: The operation is not supported. Currently thrown when attempting to deposit native tokens.
     * - INVALID_ADDRESS: An Ethereum address provided in the request is invalid. This could be the depositor's,
     * recipient's or the token's address.
     * - INVALID_AMOUNT: The deposit amount provided in the request is invalid (less than or equal to 0).
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     *
     * @example
     * const depositERC20Request = {
     *   token: '0x123456...', // ERC20 token address
     *   depositorAddress: '0xabcdef...', // User's wallet address
     *   recipientAddress: '0x987654...', // Destination wallet address on the target chain
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in wei
     * };
     *
     * @example
     * const depositEtherTokenRequest = {
     *   token: 'NATIVE',
     *   depositorAddress: '0xabcdef...', // User's wallet address
     *   recipientAddress: '0x987654...', // Destination wallet address on the target chain
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in wei
     * };
     *
     * bridgeSdk.getUnsignedDepositTx(depositRequest)
     *   .then((depositResponse) => {
     *     console.log(depositResponse.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedDepositTx(req) {
        this.validateChainConfiguration();
        TokenBridge.validateDepositArgs(req.recipientAddress, req.depositAmount, req.token);
        const rootERC20PredicateContract = await withBridgeError(async () => {
            const contract = new Contract(this.config.bridgeContracts.rootChainERC20Predicate, ROOT_ERC20_PREDICATE);
            return contract;
        }, BridgeErrorType.INTERNAL_ERROR);
        // Convert the addresses to correct format addresses (e.g. prepend 0x if not already)
        const receipient = getAddress(req.recipientAddress);
        // Handle return if it is a native token
        if (req.token === 'NATIVE') {
            // Encode the function data into a payload
            const data = await withBridgeError(async () => rootERC20PredicateContract.interface.encodeFunctionData('depositNativeTo', [receipient]), BridgeErrorType.INTERNAL_ERROR);
            return {
                unsignedTx: {
                    data,
                    to: this.config.bridgeContracts.rootChainERC20Predicate,
                    value: req.depositAmount,
                },
            };
        }
        // Handle return for ERC20
        const token = getAddress(req.token);
        // Encode the function data into a payload
        const data = await withBridgeError(async () => rootERC20PredicateContract.interface.encodeFunctionData('depositTo', [token, receipient, req.depositAmount]), BridgeErrorType.INTERNAL_ERROR);
        return {
            unsignedTx: {
                data,
                to: this.config.bridgeContracts.rootChainERC20Predicate,
                value: 0,
            },
        };
    }
    /**
     * Waits for the deposit transaction to be confirmed and synced from the root chain to the child chain.
     *
     * @param {WaitForDepositRequest} req - The wait for request object containing the transaction hash.
     * @returns {Promise<WaitForDepositResponse>} - A promise that resolves to an object containing the status of the deposit transaction.
     * @throws {BridgeError} - If an error occurs during the transaction confirmation or state sync, a BridgeError will be
     * thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred with the Ethereum provider during transaction confirmation or state synchronization.
     * - TRANSACTION_REVERTED: The transaction on the root chain was reverted.
     *
     * @example
     * const waitForRequest = {
     *   transactionHash: '0x123456...', // Deposit transaction hash on the root chain
     * };
     *
     * bridgeSdk.waitForDeposit(waitForRequest)
     *   .then((waitForResponse) => {
     *     console.log('Deposit Transaction Status:', waitForResponse.status);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async waitForDeposit(req) {
        this.validateChainConfiguration();
        const rootTxReceipt = await withBridgeError(async () => this.config.rootProvider.waitForTransaction(req.transactionHash, this.config.rootChainFinalityBlocks), BridgeErrorType.PROVIDER_ERROR);
        // Throw an error if the transaction was reverted
        if (rootTxReceipt.status !== 1) {
            throw new BridgeError(`${rootTxReceipt.transactionHash} on rootchain was reverted`, BridgeErrorType.TRANSACTION_REVERTED);
        }
        // Get the state sync ID from the transaction receipt
        const stateSyncID = await withBridgeError(async () => this.getRootStateSyncID(rootTxReceipt), BridgeErrorType.PROVIDER_ERROR);
        // Get the block for the timestamp
        const rootBlock = await withBridgeError(async () => await this.config.rootProvider.getBlock(rootTxReceipt.blockNumber), BridgeErrorType.PROVIDER_ERROR, `failed to query block ${rootTxReceipt.blockNumber} on rootchain`);
        // Get the minimum block on childchain which corresponds with the timestamp on rootchain
        const minBlockRange = await withBridgeError(async () => getBlockNumberClosestToTimestamp(this.config.childProvider, rootBlock.timestamp, this.config.blockTime, this.config.clockInaccuracy), BridgeErrorType.PROVIDER_ERROR);
        // Get the upper bound for which we expect the StateSync event to occur
        const maxBlockRange = minBlockRange + this.config.maxDepositBlockDelay;
        // Poll till event observed
        const result = await withBridgeError(async () => this.waitForChildStateSync(stateSyncID, this.config.pollInterval, minBlockRange, maxBlockRange), BridgeErrorType.PROVIDER_ERROR);
        return {
            status: result,
        };
    }
    /**
   * Retrieves the corresponding child token address for a given root token address.
   * This function is used to map a root token to its child token in the context of a bridging system between chains.
   * If the token is native, a special key is used to represent it.
   *
   * @param {ChildTokenRequest} req - The request object containing the root token address or the string 'NATIVE'.
   * @returns {Promise<ChildTokenResponse>} - A promise that resolves to an object containing the child token address.
   * @throws {BridgeError} - If an error occurs during the query, a BridgeError will be thrown with a specific error type.
   *
   * Possible BridgeError types include:
   * - INVALID_ADDRESS: If the Ethereum address provided in the request is invalid.
   * - PROVIDER_ERROR: If there's an error in querying the getChildToken mapping.
   * - INTERNAL_ERROR: An unexpected error occurred during the execution.
   *
   * @example
   * const request = {
   *   rootToken: '0x123456...', // Root token address or 'NATIVE'
   * };
   *
   * bridgeSdk.getChildToken(request)
   *   .then((response) => {
   *     console.log(response.childToken); // Child token address
   *   })
   *   .catch((error) => {
   *     console.error('Error:', error.message);
   *   });
   */
    async getChildToken(req) {
        // Validate the chain configuration to ensure proper setup
        this.validateChainConfiguration();
        // If the root token is native, use the native token key; otherwise, use the provided root token address
        const reqTokenAddress = (req.rootToken === 'NATIVE') ? NATIVE_TOKEN_BRIDGE_KEY : req.rootToken;
        // Validate the request token address
        if (!isAddress(reqTokenAddress)) {
            throw new BridgeError(`token address ${reqTokenAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // Create an instance of the root ERC20 predicate contract
        const childTokenAddress = await withBridgeError(async () => {
            const rootERC20Predicate = new Contract(this.config.bridgeContracts.rootChainERC20Predicate, ROOT_ERC20_PREDICATE, this.config.rootProvider);
            return await rootERC20Predicate.rootTokenToChildToken(reqTokenAddress);
        }, BridgeErrorType.PROVIDER_ERROR, 'failed to query rootTokenToChildToken mapping');
        // Return the child token address
        return {
            childToken: childTokenAddress,
        };
    }
    /**
   * Retrieves the corresponding root token address for a given child token address.
   * This function is used to map a child token back to its root token in the context of a bridging system between chains.
   *
   * If the root token address matches the address designated for the native token, the method will return 'NATIVE'.
   *
   * @param {RootTokenRequest} req - The request object containing the child token address.
   * @returns {Promise<RootTokenResponse>} - A promise that resolves to an object containing the root token address.
   * @throws {BridgeError} - If an error occurs during the query, a BridgeError will be thrown with a specific error type.
   *
   * Possible BridgeError types include:
   * - PROVIDER_ERROR: If there's an error in querying the root token from the child token contract.
   * - INVALID_TOKEN: If the token being withdrawed is not a valid bridgeable token
   *
   * @example
   * const request = {
   *   childToken: '0x123456...', // Child token address
   * };
   *
   * bridgeSdk.getRootToken(request)
   *   .then((response) => {
   *     console.log(response.rootToken); // Outputs: 'NATIVE' or Root token address
   *   })
   *   .catch((error) => {
   *     console.error('Error:', error.message);
   *   });
   */
    async getRootToken(req) {
        // Validate the chain configuration to ensure proper setup
        this.validateChainConfiguration();
        // Query the corresponding root token address using the child token contract
        const rootToken = await withBridgeError(async () => {
            // Create an instance of the child token contract using the given child token address
            const childToken = new Contract(req.childToken, CHILD_ERC20, this.config.childProvider);
            return await childToken.rootToken();
        }, BridgeErrorType.PROVIDER_ERROR, 'failed to query the root token from the child token contract');
        // Check if the rootToken address is the designated native token address.
        // If it is, return 'NATIVE'. Else, return the root token address.
        return {
            rootToken: (rootToken === NATIVE_TOKEN_BRIDGE_KEY) ? 'NATIVE' : rootToken,
        };
    }
    /**
     * Generates an unsigned transaction that a user can use to initiate a token withdrawal from the bridge.
     * The user must sign and submit this transaction to execute the withdrawal.
     *
     * @param {BridgeWithdrawRequest} req - The withdrawal request object containing the necessary data for withdrawing tokens.
     * @returns {Promise<BridgeWithdrawResponse>} - A promise that resolves to an object containing the unsigned transaction data.
     *
     * @throws {BridgeError} - If an error occurs during the generation of the unsigned transaction,
     * a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - INVALID_ADDRESS: The Ethereum address provided in the request is invalid. This could be the user's address or the token's address.
     * - INVALID_AMOUNT: The withdrawal amount provided in the request is invalid (less than or equal to 0).
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     *
     * @example
     * const withdrawRequest = {
     *   token: '0x123456...', // ERC20 token address
     *   recipientAddress: '0xabcdef...', // Address to receive the withdrawn tokens
     *   withdrawAmount: ethers.utils.parseUnits('100', 18), // Withdraw amount in wei
     * };
     *
     * bridgeSdk.getUnsignedWithdrawTx(withdrawRequest)
     *   .then((withdrawalResponse) => {
     *     console.log(withdrawalResponse.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedWithdrawTx(req) {
        // Ensure the configuration of chains is valid.
        this.validateChainConfiguration();
        // Validate the recipient address, withdrawal amount, and token.
        TokenBridge.validateWithdrawArgs(req.recipientAddress, req.withdrawAmount, req.token);
        // Create a contract instance for interacting with the ChildERC20Predicate
        const childERC20PredicateContract = await withBridgeError(async () => {
            const contract = new Contract(this.config.bridgeContracts.childChainERC20Predicate, CHILD_ERC20_PREDICATE);
            return contract;
        }, BridgeErrorType.INTERNAL_ERROR);
        // Encode the withdrawTo function call data for the ERC20 contract
        const data = await withBridgeError(async () => childERC20PredicateContract.interface
            .encodeFunctionData('withdrawTo', [
            req.token,
            req.recipientAddress,
            req.withdrawAmount,
        ]), BridgeErrorType.INTERNAL_ERROR);
        // Construct the unsigned transaction for the withdrawal
        return {
            unsignedTx: {
                data,
                to: this.config.bridgeContracts.childChainERC20Predicate,
                value: 0,
            },
        };
    }
    /**
     * Waits for the withdrawal transaction to be confirmed in the root chain by continuously
     * polling until the transaction is included in a checkpoint.
     * This function is intended to be used after executing a withdrawal transaction.
     *
     * @param {WaitForWithdrawalRequest} req - The request object containing the transaction hash of the withdrawal transaction.
     * @returns {Promise<WaitForWithdrawalResponse>} - A promise that resolves to an empty object once the withdrawal
     * transaction has been confirmed in the root chain.
     *
     * @throws {BridgeError} - If an error occurs during the waiting process, a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     *
     * @example
     * const waitForWithdrawalRequest = {
     *   transactionHash: '0x123456...', // Transaction hash of the withdrawal transaction
     * };
     *
     * bridgeSdk.waitForWithdrawal(waitForWithdrawalRequest)
     *   .then(() => {
     *     console.log('Withdrawal transaction has been confirmed in the root chain.');
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async waitForWithdrawal(req) {
        // Ensure the configuration of chains is valid.
        this.validateChainConfiguration();
        // Helper function to pause execution for a specified interval
        const pause = () => new Promise((resolve) => {
            setTimeout(resolve, this.config.pollInterval);
        });
        await withBridgeError(async () => {
            // Fetch the receipt of the withdrawal transaction
            const transactionReceipt = await this.config.childProvider.getTransactionReceipt(req.transactionHash);
            // Fetch the block in which the withdrawal transaction was included
            const block = await this.config.childProvider.getBlock(transactionReceipt.blockNumber);
            // Decode the extra data field from the block header
            const decodedExtraData = decodeExtraData(block.extraData);
            // Instantiate the checkpoint manager contract
            const checkpointManager = new Contract(this.config.bridgeContracts.rootChainCheckpointManager, CHECKPOINT_MANAGER, this.config.rootProvider);
            // Recursive function to keep checking for the child deposit event
            const waitForRootEpoch = async () => {
                // Fetch the current checkpoint epoch from the root chain
                const currentEpoch = await checkpointManager.currentEpoch();
                // If the current epoch is greater than or equal to the epoch number of the checkpoint in which
                // the withdrawal transaction was included, the withdrawal has been confirmed in the root chain
                if (currentEpoch >= decodedExtraData.checkpoint.epochNumber) {
                    return null;
                }
                // Pause execution for a specified interval before checking again
                await pause();
                // Recursive call
                return waitForRootEpoch();
            };
            // Start waiting for the withdrawal transaction to be confirmed in the root chain
            await waitForRootEpoch();
        }, BridgeErrorType.PROVIDER_ERROR);
        // Return an empty object once the withdrawal transaction has been confirmed in the root chain
        return {};
    }
    /**
     * Creates an unsigned exit transaction which, when executed, will exit the assets from the child chain to the root chain.
     * This function should be used after a withdraw transaction has been executed on the child chain.
     * It should only be executed after `waitForWithdrawal` has completed successfully.
     *
     * @param {ExitRequest} req - The request object containing the transaction hash of the withdraw transaction.
     * @returns {Promise<ExitResponse>} - A promise that resolves to an object containing the unsigned exit transaction.
     *
     * @throws {BridgeError} - If an error occurs during the exit transaction creation process,
     * a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     * - INVALID_TRANSACTION: The deposit transaction is invalid or the L2StateSynced event log does not match the expected format.
     * - INTERNAL_ERROR: An internal error occurred during the function call encoding process.
     *
     * @example
     * const exitRequest = {
     *   transactionHash: '0x123456...', // Transaction hash of the deposit transaction
     * };
     *
     * bridgeSdk.getUnsignedExitTx(exitRequest)
     *   .then((response) => {
     *     console.log('Unsigned exit transaction:', response.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedExitTx(req) {
        // Ensure the configuration of chains is valid
        this.validateChainConfiguration();
        // Fetch the receipt of the deposit transaction
        const txReceipt = await withBridgeError(async () => await this.config.childProvider.getTransactionReceipt(req.transactionHash), BridgeErrorType.PROVIDER_ERROR);
        // Filter out the StateSynced event log from the transaction receipt
        const stateSenderLogs = txReceipt.logs.filter((log) => log.address.toLowerCase() === L2_STATE_SENDER_ADDRESS);
        if (stateSenderLogs.length !== 1) {
            throw new BridgeError(`expected 1 log in tx ${txReceipt.transactionHash} from address ${L2_STATE_SENDER_ADDRESS}`, BridgeErrorType.INVALID_TRANSACTION);
        }
        // Parse the StateSynced event log
        const l2StateSyncEvent = await withBridgeError(async () => {
            const l2StateSenderInterface = new Interface(L2_STATE_SENDER);
            const event = l2StateSenderInterface.parseLog(stateSenderLogs[0]);
            // Throw an error if the event log doesn't match the expected format
            if (event.signature !== 'L2StateSynced(uint256,address,address,bytes)') {
                throw new Error(`expected L2StateSynced event in tx ${txReceipt.transactionHash}`);
            }
            return event;
        }, BridgeErrorType.INVALID_TRANSACTION);
        // Instantiate the exit helper contract
        const exitHelper = await withBridgeError(async () => new Contract(this.config.bridgeContracts.rootChainExitHelper, EXIT_HELPER, this.config.rootProvider), BridgeErrorType.PROVIDER_ERROR);
        // Generate the exit proof
        const exitProof = await withBridgeError(async () => this.config.childProvider
            .send('bridge_generateExitProof', [l2StateSyncEvent.args.id.toHexString()]), BridgeErrorType.PROVIDER_ERROR);
        // Encode the exit function call data
        const encodedExitTx = await withBridgeError(async () => {
            const exitEventEncoded = defaultAbiCoder.encode(['uint256', 'address', 'address', 'bytes'], l2StateSyncEvent.args);
            return exitHelper.interface.encodeFunctionData('exit', [exitProof.Metadata.CheckpointBlock, exitProof.Metadata.LeafIndex, exitEventEncoded, exitProof.Data]);
        }, BridgeErrorType.INTERNAL_ERROR);
        // Create the unsigned exit transaction
        const unsignedTx = {
            data: encodedExitTx,
            to: this.config.bridgeContracts.rootChainExitHelper,
            value: 0,
        };
        // Return the unsigned exit transaction
        return { unsignedTx };
    }
    async waitForChildStateSync(stateSyncID, interval, minBlockRange, maxBlockRange) {
        // Initialize the child state receiver contract
        const childStateReceiver = new Contract(this.config.bridgeContracts.childChainStateReceiver, CHILD_STATE_RECEIVER, this.config.childProvider);
        // Create an event filter for the StateSyncResult event emitted by the contract
        // This will be used to listen for specific instances of the event where the stateSyncID matches our expected ID
        const eventFilter = childStateReceiver.filters.StateSyncResult(stateSyncID, null, null);
        // Define a helper function that queries the blockchain for the StateSyncResult events that match our filter
        // This function scans the block range from minBlockRange to maxBlockRange
        const getEventsWithStateSyncID = async () => childStateReceiver
            .queryFilter(eventFilter, minBlockRange, maxBlockRange);
        // Define a helper function that pauses execution of our program for a certain interval (in milliseconds)
        // This is used to wait between checks for the StateSyncResult event on the blockchain
        const pause = () => new Promise((resolve) => {
            setTimeout(resolve, interval);
        });
        // Define a recursive function that keeps checking the blockchain for our specific StateSyncResult event
        // It calls the helper function getEventsWithStateSyncID() to get the list of matching events
        // If it finds more than one matching event, it throws an error because we only expect one event with our specific stateSyncID
        // If it finds exactly one matching event, it returns that event
        // If it doesn't find any matching event, it waits for a while (using the pause() function) and then checks again (recursive call)
        const checkForChildDepositEvent = async () => {
            const events = await getEventsWithStateSyncID();
            if (events.length > 1) {
                throw new Error(`expected maximum of 1 events with statesync id ${stateSyncID} but found ${events.length}`);
            }
            if (events.length === 1) {
                return events[0];
            }
            // Pause execution for a specified interval before checking again
            await pause();
            // Recursive call
            return checkForChildDepositEvent();
        };
        // Call our recursive function and wait for it to find the StateSyncResult event
        const childDepositEvent = await checkForChildDepositEvent();
        // Perform some error checking on the event:
        // - If there's no event, throw an error
        // - If the event doesn't have arguments, throw an error
        // - If the event's arguments don't include a status, throw an error
        if (!childDepositEvent)
            throw new Error('failed to find child deposit event');
        if (!childDepositEvent.args)
            throw new Error('child deposit event has no args');
        if (childDepositEvent.args.status == null)
            throw new Error('child deposit event has no status');
        // If the event's status argument is present, we consider that the state sync operation was successful
        if (childDepositEvent.args.status) {
            return CompletionStatus.SUCCESS;
        }
        // If not, we consider that the operation failed
        return CompletionStatus.FAILED;
    }
    async getRootStateSyncID(txReceipt) {
        const stateSenderInterface = new Interface(ROOT_STATE_SENDER);
        // Get the StateSynced event log from the transaction receipt
        const stateSenderLogs = txReceipt
            .logs
            .filter((log) => log.address.toLowerCase() === this.config.bridgeContracts.rootChainStateSender.toLowerCase());
        if (stateSenderLogs.length !== 1) {
            throw new Error(`expected at least 1 log in tx ${txReceipt.transactionHash}`);
        }
        const stateSyncEvent = stateSenderInterface.parseLog(stateSenderLogs[0]);
        // Throw an error if the event log doesn't match the expected format
        if (stateSyncEvent.signature !== 'StateSynced(uint256,address,address,bytes)') {
            throw new Error(`expected state sync event in tx ${txReceipt.transactionHash}`);
        }
        // Return the state sync ID as a number
        return parseInt(stateSyncEvent.args.id, 10);
    }
    static validateDepositArgs(depositorOrRecipientAddress, depositAmount, token) {
        if (!isAddress(depositorOrRecipientAddress)) {
            throw new BridgeError(`address ${depositorOrRecipientAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // The deposit amount cannot be <= 0
        if (depositAmount.isNegative() || depositAmount.isZero()) {
            throw new BridgeError(`deposit amount ${depositAmount.toString()} is invalid`, BridgeErrorType.INVALID_AMOUNT);
        }
        // If the token is not native, it must be a valid address
        if (token !== 'NATIVE' && !isAddress(token)) {
            throw new BridgeError(`token address ${token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
    }
    static validateWithdrawArgs(withdrawerOrRecipientAddress, withdrawAmount, token) {
        // Validate the withdrawer address
        if (!isAddress(withdrawerOrRecipientAddress)) {
            throw new BridgeError(`withdrawer address ${withdrawerOrRecipientAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // Validate the withdrawal amount. It cannot be zero or negative.
        if (withdrawAmount.isNegative() || withdrawAmount.isZero()) {
            throw new BridgeError(`withdraw amount ${withdrawAmount.toString()} is invalid`, BridgeErrorType.INVALID_AMOUNT);
        }
        // Check if the ERC20 Token is a valid address
        if (!isAddress(token)) {
            throw new BridgeError(`token address ${token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
    }
    // Query the rootchain and childchain providers to ensure the chainID is as expected by the SDK.
    // This is to prevent the SDK from being used on the wrong chain, especially after a chain reset.
    async validateChainConfiguration() {
        const errMessage = 'Please upgrade to the latest version of the Bridge SDK or provide valid configuration';
        const rootNetwork = await withBridgeError(async () => this.config.rootProvider.getNetwork(), BridgeErrorType.PROVIDER_ERROR);
        if (rootNetwork.chainId.toString() !== this.config.bridgeInstance.rootChainID) {
            throw new BridgeError(`Rootchain provider chainID ${rootNetwork.chainId} does not match expected chainID ${this.config.bridgeInstance.rootChainID}. ${errMessage}`, BridgeErrorType.UNSUPPORTED_ERROR);
        }
        const childNetwork = await this.config.childProvider.getNetwork();
        if (childNetwork.chainId.toString() !== this.config.bridgeInstance.childChainID) {
            throw new BridgeError(`Childchain provider chainID ${childNetwork.chainId} does not match expected chainID ${this.config.bridgeInstance.childChainID}. ${errMessage}`, BridgeErrorType.UNSUPPORTED_ERROR);
        }
    }
}

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

/**
 * @constant {BridgeInstance[]} SupportedSandboxBridges - An array of supported bridge instances for the sandbox environment.
 */
const SUPPORTED_SANDBOX_BRIDGES = [ETH_SEPOLIA_TO_ZKEVM_DEVNET, ETH_SEPOLIA_TO_ZKEVM_TESTNET];
/**
 * @constant {BridgeInstance[]} SUPPORTED_PRODUCTION_BRIDGES - An array of supported bridge instances for the production environment.
 */
const SUPPORTED_PRODUCTION_BRIDGES = [];
/**
 * @constant {Object} SUPPORTED_BRIDGES_FOR_ENVIRONMENT - An object mapping environment types to their supported bridge instances.
 */
const SUPPORTED_BRIDGES_FOR_ENVIRONMENT = {
    [Environment.SANDBOX]: SUPPORTED_SANDBOX_BRIDGES,
    [Environment.PRODUCTION]: SUPPORTED_PRODUCTION_BRIDGES,
};
/**
 * @constant {Map<BridgeInstance, BridgeContracts>} CONTRACTS_FOR_BRIDGE - A map of bridge instances to their associated contract addresses.
 */
const CONTRACTS_FOR_BRIDGE = new Map()
    .set(ETH_SEPOLIA_TO_ZKEVM_DEVNET, {
    rootChainERC20Predicate: '0x75E468cF088F947B96422996132FbE71160F21F1',
    rootChainStateSender: '0xbdC11416f01b122b7621855e61c99C7ED986F894',
    rootChainCheckpointManager: '0x0721b564a96466b864A998D31846Ba409d21092B',
    rootChainExitHelper: '0x0a2cb3f90aE65429E5c516af500F59d8fed51844',
    childChainERC20Predicate: '0x0000000000000000000000000000000000001004',
    childChainStateReceiver: '0x0000000000000000000000000000000000001001',
})
    .set(ETH_SEPOLIA_TO_ZKEVM_TESTNET, {
    rootChainERC20Predicate: '0x1118Cc83780d07ef99F84fD1C0E10CEd49AF3613',
    rootChainStateSender: '0x41716a0DD85ae257DD011A97cE1470F609871270',
    rootChainCheckpointManager: '0xfD69e3FCd72C6374623eeb156dd2C4159eBa7327',
    rootChainExitHelper: '0x270D2B290c8183De23eCD17C7DaAE59fd084fE70',
    childChainERC20Predicate: '0x0000000000000000000000000000000000001004',
    childChainStateReceiver: '0x0000000000000000000000000000000000001001',
})
    .set(ETH_MAINNET_TO_ZKEVM_MAINNET, {
    rootChainERC20Predicate: '0x',
    rootChainStateSender: '0x',
    rootChainCheckpointManager: '0x',
    rootChainExitHelper: '0x',
    childChainERC20Predicate: '0x',
    childChainStateReceiver: '0x',
});
/**
 * Represents the configuration for a bridge between two chains.
 */
class BridgeConfiguration {
    /**
     * @property {ImmutableConfiguration} baseConfig - The base configuration for the module.
     * @property {BridgeInstance} bridgeInstance - The bridge instance configuration for the root and child chains.
     * @property {BridgeContracts} bridgeContracts - The configuration of the contracts associated with the bridge.
     * @property {ethers.providers.Provider} rootProvider - The Ethereum provider for the root chain.
     * @property {ethers.providers.Provider} childProvider - The Ethereum provider for the child chain.
     * @property {number} blockTime - The approximate block time
     * @property {number} pollInterval - The time to wait between polls to the blockchain
     * @property {number} maxDepositBlockDelay - The maximum number of blocks it should take on child chain for deposit to be observed
     * @property {number} clockInaccuracy - The maximum number of seconds of inaccuracy of blockchain timestamps
     * @property {number} rootChainFinalityBlocks - The number of blocks to wait for on the rootchain before accepting finality
    */
    baseConfig;
    bridgeInstance;
    bridgeContracts;
    rootProvider;
    childProvider;
    blockTime;
    pollInterval;
    maxDepositBlockDelay;
    clockInaccuracy;
    rootChainFinalityBlocks;
    /**
     * Constructs a BridgeConfiguration instance.
     *
     * @param {BridgeModuleConfiguration} options - The configuration options for the bridge module.
     */
    constructor({ bridgeInstance, rootProvider, childProvider, baseConfig, overrides, }) {
        this.baseConfig = baseConfig;
        this.bridgeInstance = bridgeInstance;
        this.rootProvider = rootProvider;
        this.childProvider = childProvider;
        // Does not need to be exact, just approximate
        this.blockTime = 12;
        // How frequently we poll the childchain for StateSync events
        this.pollInterval = 5 * 1000; // 5 seconds
        // The upper bound of the block range we poll for StateSync events
        this.maxDepositBlockDelay = 250;
        // Assume that the clock timestamp is at most 900 seconds inaccurate, see for more ->
        // https://github.com/ethereum/wiki/blob/c02254611f218f43cbb07517ca8e5d00fd6d6d75/Block-Protocol-2.0.md
        this.clockInaccuracy = 900;
        // How many blocks to wait for on the root chain before accepting rootchain finality
        this.rootChainFinalityBlocks = 3;
        if (overrides) {
            this.bridgeContracts = overrides.bridgeContracts;
            return;
        }
        const supported = SUPPORTED_BRIDGES_FOR_ENVIRONMENT[baseConfig.environment].includes(bridgeInstance);
        if (!supported) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        if (!CONTRACTS_FOR_BRIDGE.has(bridgeInstance)) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        const bridgeContracts = CONTRACTS_FOR_BRIDGE.get(bridgeInstance);
        if (!bridgeContracts) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        this.bridgeContracts = bridgeContracts;
    }
}

/**
 * @enum {string} Errors that can be returned by the Exchange.
 */
var ExchangeErrorCode;
(function (ExchangeErrorCode) {
    ExchangeErrorCode["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    ExchangeErrorCode["INVALID_SLIPPAGE"] = "INVALID_SLIPPAGE";
    ExchangeErrorCode["INVALID_MAX_HOPS"] = "INVALID_MAX_HOPS";
    ExchangeErrorCode["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    ExchangeErrorCode["DUPLICATE_ADDRESSES"] = "DUPLICATE_ADDRESSES";
    ExchangeErrorCode["CHAIN_NOT_SUPPORTED"] = "CHAIN_NOT_SUPPORTED";
    ExchangeErrorCode["NO_ROUTES_AVAILABLE"] = "NO_ROUTES_AVAILABLE";
    ExchangeErrorCode["PROVIDER_CALL_ERROR"] = "PROVIDER_CALL_ERROR";
    ExchangeErrorCode["APPROVE_ERROR"] = "APPROVE_ERROR";
    ExchangeErrorCode["ALREADY_APPROVED_ERROR"] = "ALREADY_APPROVED_ERROR";
})(ExchangeErrorCode || (ExchangeErrorCode = {}));
/**
 * The {@link ExchangeError} error class that extends the {@link Error} class.
 * Contains a message string and a type that corresponds to an {@link ExchangeErrorCode}.
 * It has a constructor that takes in a message string and a type.
 */
class ExchangeError extends Error {
    message;
    code;
    constructor(message, code) {
        super(message);
        this.message = message;
        this.code = code;
    }
}
class InvalidConfigurationError extends ExchangeError {
    constructor(message) {
        super(message || 'Invalid configuration', ExchangeErrorCode.INVALID_CONFIGURATION);
    }
}
class ChainNotSupportedError extends ExchangeError {
    constructor(chain, environment) {
        const message = `Chain with ID ${chain} is not a supported chain in environment ${environment}`;
        super(message, ExchangeErrorCode.CHAIN_NOT_SUPPORTED);
    }
}
class InvalidSlippageError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_SLIPPAGE);
    }
}
class InvalidMaxHopsError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_MAX_HOPS);
    }
}
class InvalidAddressError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_ADDRESS);
    }
}
class DuplicateAddressesError extends ExchangeError {
    constructor() {
        super('token in and token out addresses must be different', ExchangeErrorCode.DUPLICATE_ADDRESSES);
    }
}
class NoRoutesAvailableError extends ExchangeError {
    constructor() {
        super('no routes available', ExchangeErrorCode.NO_ROUTES_AVAILABLE);
    }
}
class ProviderCallError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.PROVIDER_CALL_ERROR);
    }
}
class ApproveError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.APPROVE_ERROR);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$3 = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_spender",
                type: "address",
            },
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                name: "spender",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
];
class ERC20__factory {
    static abi = _abi$3;
    static createInterface() {
        return new utils$1.Interface(_abi$3);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$3, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$2 = [
    {
        inputs: [],
        name: "getCurrentBlockTimestamp",
        outputs: [
            {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "addr",
                type: "address",
            },
        ],
        name: "getEthBalance",
        outputs: [
            {
                internalType: "uint256",
                name: "balance",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "target",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "gasLimit",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes",
                    },
                ],
                internalType: "struct UniswapInterfaceMulticall.Call[]",
                name: "calls",
                type: "tuple[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256",
            },
            {
                components: [
                    {
                        internalType: "bool",
                        name: "success",
                        type: "bool",
                    },
                    {
                        internalType: "uint256",
                        name: "gasUsed",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes",
                        name: "returnData",
                        type: "bytes",
                    },
                ],
                internalType: "struct UniswapInterfaceMulticall.Result[]",
                name: "returnData",
                type: "tuple[]",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
const _bytecode$2 = "0x608060405234801561001057600080fd5b50610567806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80630f28c97d146100465780631749e1e3146100645780634d2301cc14610085575b600080fd5b61004e610098565b60405161005b919061041f565b60405180910390f35b6100776100723660046102a7565b61009c565b60405161005b929190610428565b61004e610093366004610286565b610220565b4290565b8051439060609067ffffffffffffffff811180156100b957600080fd5b506040519080825280602002602001820160405280156100f357816020015b6100e061023a565b8152602001906001900390816100d85790505b50905060005b835181101561021a57600080600086848151811061011357fe5b60200260200101516000015187858151811061012b57fe5b60200260200101516020015188868151811061014357fe5b60200260200101516040015192509250925060005a90506000808573ffffffffffffffffffffffffffffffffffffffff1685856040516101839190610403565b60006040518083038160008787f1925050503d80600081146101c1576040519150601f19603f3d011682016040523d82523d6000602084013e6101c6565b606091505b509150915060005a8403905060405180606001604052808415158152602001828152602001838152508989815181106101fb57fe5b60200260200101819052505050505050505080806001019150506100f9565b50915091565b73ffffffffffffffffffffffffffffffffffffffff163190565b604051806060016040528060001515815260200160008152602001606081525090565b803573ffffffffffffffffffffffffffffffffffffffff8116811461028157600080fd5b919050565b600060208284031215610297578081fd5b6102a08261025d565b9392505050565b600060208083850312156102b9578182fd5b823567ffffffffffffffff808211156102d0578384fd5b818501915085601f8301126102e3578384fd5b8135818111156102ef57fe5b6102fc8485830201610506565b81815284810190848601875b848110156103f457813587017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0606081838f03011215610346578a8bfd5b60408051606081018181108b8211171561035c57fe5b8252610369848d0161025d565b8152818401358c82015260608401358a811115610384578d8efd5b8085019450508e603f850112610398578c8dfd5b8b8401358a8111156103a657fe5b6103b68d85601f84011601610506565b93508084528f838287010111156103cb578d8efd5b808386018e86013783018c018d9052908101919091528552509287019290870190600101610308565b50909998505050505050505050565b6000825161041581846020870161052a565b9190910192915050565b90815260200190565b600060408083018584526020828186015281865180845260609350838701915083838202880101838901875b838110156104f6578983037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa001855281518051151584528681015187850152880151888401889052805188850181905260806104b582828801858c0161052a565b96880196601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01694909401909301925090850190600101610454565b50909a9950505050505050505050565b60405181810167ffffffffffffffff8111828210171561052257fe5b604052919050565b60005b8381101561054557818101518382015260200161052d565b83811115610554576000848401525b5050505056fea164736f6c6343000706000a";
const isSuperArgs$2 = (xs) => xs.length > 1;
class Multicall__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs$2(args)) {
            super(...args);
        }
        else {
            super(_abi$2, _bytecode$2, args[0]);
        }
    }
    deploy(overrides) {
        return super.deploy(overrides || {});
    }
    getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode$2;
    static abi = _abi$2;
    static createInterface() {
        return new utils$1.Interface(_abi$2);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$2, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$1 = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_admin",
                type: "address",
            },
            {
                internalType: "address",
                name: "_uniRouter",
                type: "address",
            },
            {
                internalType: "address",
                name: "_wimx",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [],
        name: "ContractPaused",
        type: "error",
    },
    {
        inputs: [],
        name: "DeadlinePassed",
        type: "error",
    },
    {
        inputs: [],
        name: "FailedToRefundNativeTokens",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "address payable",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "FailedToSendFees",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "required",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "actual",
                type: "uint256",
            },
        ],
        name: "FailedToUnwrapNativeTokens",
        type: "error",
    },
    {
        inputs: [],
        name: "FailedToWithdrawNativeTokens",
        type: "error",
    },
    {
        inputs: [],
        name: "FeeTooHigh",
        type: "error",
    },
    {
        inputs: [],
        name: "IncorrectRecipient",
        type: "error",
    },
    {
        inputs: [],
        name: "InputTokenNotWrapped",
        type: "error",
    },
    {
        inputs: [],
        name: "NativeTokenAmountMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "Unauthorized",
        type: "error",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "feeToken",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "feePayer",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "feeRecipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "feeAmount",
                type: "uint256",
            },
        ],
        name: "FeeTaken",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "feePayer",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "feeRecipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "feeAmount",
                type: "uint256",
            },
        ],
        name: "FeeTaken",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "Paused",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousAdminRole",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newAdminRole",
                type: "bytes32",
            },
        ],
        name: "RoleAdminChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
        ],
        name: "RoleGranted",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
        ],
        name: "RoleRevoked",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "Unpaused",
        type: "event",
    },
    {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address payable",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "address",
                        name: "tokenIn",
                        type: "address",
                    },
                    {
                        internalType: "address",
                        name: "tokenOut",
                        type: "address",
                    },
                    {
                        internalType: "uint24",
                        name: "fee",
                        type: "uint24",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountIn",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOutMinimum",
                        type: "uint256",
                    },
                    {
                        internalType: "uint160",
                        name: "sqrtPriceLimitX96",
                        type: "uint160",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactInputSingleParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactInputSingleWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "amountOut",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address payable",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "bytes",
                        name: "path",
                        type: "bytes",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountIn",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOutMinimum",
                        type: "uint256",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactInputParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactInputWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "amountOut",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address payable",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "address",
                        name: "tokenIn",
                        type: "address",
                    },
                    {
                        internalType: "address",
                        name: "tokenOut",
                        type: "address",
                    },
                    {
                        internalType: "uint24",
                        name: "fee",
                        type: "uint24",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOut",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountInMaximum",
                        type: "uint256",
                    },
                    {
                        internalType: "uint160",
                        name: "sqrtPriceLimitX96",
                        type: "uint160",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactOutputSingleWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address payable",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "bytes",
                        name: "path",
                        type: "bytes",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOut",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountInMaximum",
                        type: "uint256",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactOutputParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactOutputWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
        ],
        name: "getRoleAdmin",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "hasRole",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "deadline",
                type: "uint256",
            },
            {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "bytes[]",
                name: "",
                type: "bytes[]",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "bytes[]",
                name: "results",
                type: "bytes[]",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "paused",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4",
            },
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "amountMinimum",
                type: "uint256",
            },
        ],
        name: "unwrapNativeToken",
        outputs: [],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "address",
                name: "erc20",
                type: "address",
            },
        ],
        name: "withdrawFunds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
        ],
        name: "withdrawFunds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        stateMutability: "payable",
        type: "receive",
    },
];
const _bytecode$1 = "0x60806040523480156200001157600080fd5b50604051620031e1380380620031e183398101604081905262000034916200015c565b6001805460ff191690556200004b6000846200009e565b600180546001600160a01b039384166101008102610100600160a81b03199092169190911790915560038054929093166001600160a01b03199283161790925560028054909116909117905550620001a6565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166200013b576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620000fa3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b80516001600160a01b03811681146200015757600080fd5b919050565b6000806000606084860312156200017257600080fd5b6200017d846200013f565b92506200018d602085016200013f565b91506200019d604085016200013f565b90509250925092565b61302b80620001b66000396000f3fe6080604052600436106101175760003560e01c806358e81a50116100a05780638456cb59116100645780638456cb59146102c457806391d14854146102d9578063a217fddf146102f9578063ac9650d81461030e578063d547741f1461032e57600080fd5b806358e81a50146102465780635ae401dc146102595780635c975abb146102795780635ebca7991461029157806368742da6146102a457600080fd5b80632f2ff15d116100e75780632f2ff15d146101cb57806336568abe146101eb578063383ebb0b1461020b5780633f4ba83a1461021e5780635640f6591461023357600080fd5b80620fa9fb1461012357806301ffc9a714610145578063116944b21461017a578063248a9ca31461019b57600080fd5b3661011e57005b600080fd5b34801561012f57600080fd5b5061014361013e3660046127c3565b61034e565b005b34801561015157600080fd5b506101656101603660046127fc565b61041a565b60405190151581526020015b60405180910390f35b61018d61018836600461298d565b610451565b604051908152602001610171565b3480156101a757600080fd5b5061018d6101b63660046129e2565b60009081526020819052604090206001015490565b3480156101d757600080fd5b506101436101e63660046129fb565b6106d3565b3480156101f757600080fd5b506101436102063660046129fb565b6106f8565b61018d610219366004612ae3565b61077b565b34801561022a57600080fd5b50610143610ae7565b61018d610241366004612ae3565b610b37565b61018d61025436600461298d565b610db2565b61026c610267366004612b8f565b6110e4565b6040516101719190612c2a565b34801561028557600080fd5b5060015460ff16610165565b61014361029f3660046129e2565b611119565b3480156102b057600080fd5b506101436102bf366004612c8c565b611266565b3480156102d057600080fd5b506101436112e1565b3480156102e557600080fd5b506101656102f43660046129fb565b61132f565b34801561030557600080fd5b5061018d600081565b34801561031a57600080fd5b5061026c610329366004612ca9565b611358565b34801561033a57600080fd5b506101436103493660046129fb565b61144c565b6103787f7a8dc26796a1e50e6e190b70259f58f6a4edd5b22280ceecc82b687b8e9828693361132f565b610394576040516282b42960e81b815260040160405180910390fd5b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa1580156103db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ff9190612cea565b90506104156001600160a01b0383168483611471565b505050565b60006001600160e01b03198216637965db0b60e01b148061044b57506301ffc9a760e01b6001600160e01b03198316145b92915050565b600061045f60015460ff1690565b1561047d5760405163ab35696f60e01b815260040160405180910390fd5b61048a82606001516114d4565b6104a75760405163519bdea760e01b815260040160405180910390fd5b4780156105e757826080015181146104d2576040516342f7487960e11b815260040160405180910390fd5b60035483516001600160a01b03908116911614610502576040516324d0121760e01b815260040160405180910390fd5b61056283608001518686808060200260200160405190810160405280939291908181526020016000905b828210156105585761054960408302860136819003810190612d03565b8152602001906001019061052c565b50505050506114fa565b608084018190526001546040516304e45aaf60e01b81526101009091046001600160a01b0316916304e45aaf9161059d908790600401612d5a565b60206040518083038185885af11580156105bb573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906105e09190612cea565b91506106cb565b61064c836000015184608001518787808060200260200160405190810160405280939291908181526020016000905b828210156106425761063360408302860136819003810190612d03565b81526020019060010190610616565b505050505061154c565b60808401526001546040516304e45aaf60e01b81526101009091046001600160a01b0316906304e45aaf90610685908690600401612d5a565b6020604051808303816000875af11580156106a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c89190612cea565b91505b509392505050565b6000828152602081905260409020600101546106ee816115a9565b61041583836115b3565b6001600160a01b038116331461076d5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b6107778282611637565b5050565b600061078960015460ff1690565b156107a75760405163ab35696f60e01b815260040160405180910390fd5b6107b482602001516114d4565b6107d15760405163519bdea760e01b815260040160405180910390fd5b60006107e0836000015161169c565b9050478015610992576003546001600160a01b03838116911614610817576040516324d0121760e01b815260040160405180910390fd5b8360600151811461083b576040516342f7487960e11b815260040160405180910390fd5b60008061089e86606001518989808060200260200160405190810160405280939291908181526020016000905b828210156108945761088560408302860136819003810190612d03565b81526020019060010190610868565b50505050506116ca565b606088018190526001546040516304dc09a360e11b81529294509092506000916101009091046001600160a01b0316906309b813469084906108e4908b90600401612e00565b60206040518083038185885af1158015610902573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906109279190612cea565b905061098681848b8b808060200260200160405190810160405280939291908181526020016000905b8282101561097c5761096d60408302860136819003810190612d03565b81526020019060010190610950565b505050505061171d565b95505050505050610ae0565b6000806109f68487606001518a8a808060200260200160405190810160405280939291908181526020016000905b828210156109ec576109dd60408302860136819003810190612d03565b815260200190600101906109c0565b5050505050611811565b606088018190526001546040516304dc09a360e11b81529294509092506000916101009091046001600160a01b0316906309b8134690610a3a908a90600401612e00565b6020604051808303816000875af1158015610a59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7d9190612cea565b90506109868582858c8c808060200260200160405190810160405280939291908181526020016000905b82821015610ad357610ac460408302860136819003810190612d03565b81526020019060010190610aa7565b505050505061186b565b50505b9392505050565b610b117fe7276a2a84d8de556657ec9cf93a55a7d66f096e529d0582ed08e9e2208b92b53361132f565b610b2d576040516282b42960e81b815260040160405180910390fd5b610b356118c7565b565b6000610b4560015460ff1690565b15610b635760405163ab35696f60e01b815260040160405180910390fd5b610b7082602001516114d4565b610b8d5760405163519bdea760e01b815260040160405180910390fd5b6000610b9c8360000151611919565b9050478015610cd25783604001518114610bc9576040516342f7487960e11b815260040160405180910390fd5b6003546001600160a01b03838116911614610bf7576040516324d0121760e01b815260040160405180910390fd5b610c4d84604001518787808060200260200160405190810160405280939291908181526020016000905b8282101561055857610c3e60408302860136819003810190612d03565b81526020019060010190610c21565b6040858101829052600154905163b858183f60e01b81526101009091046001600160a01b03169163b858183f91610c88908890600401612e00565b60206040518083038185885af1158015610ca6573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610ccb9190612cea565b9250610add565b610d298285604001518888808060200260200160405190810160405280939291908181526020016000905b8282101561064257610d1a60408302860136819003810190612d03565b81526020019060010190610cfd565b604085810191909152600154905163b858183f60e01b81526101009091046001600160a01b03169063b858183f90610d65908790600401612e00565b6020604051808303816000875af1158015610d84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610da89190612cea565b9695505050505050565b6000610dc060015460ff1690565b15610dde5760405163ab35696f60e01b815260040160405180910390fd5b610deb82606001516114d4565b610e085760405163519bdea760e01b815260040160405180910390fd5b478015610fa55760035483516001600160a01b03908116911614610e3f576040516324d0121760e01b815260040160405180910390fd5b8260a001518114610e63576040516342f7487960e11b815260040160405180910390fd5b600080610ebc8560a001518888808060200260200160405190810160405280939291908181526020016000905b8282101561089457610ead60408302860136819003810190612d03565b81526020019060010190610e90565b60a08701819052600154604051635023b4df60e01b81529294509092506000916101009091046001600160a01b031690635023b4df908490610f02908a90600401612d5a565b60206040518083038185885af1158015610f20573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610f459190612cea565b9050610f9a81848a8a808060200260200160405190810160405280939291908181526020016000905b8282101561097c57610f8b60408302860136819003810190612d03565b81526020019060010190610f6e565b945050505050610ae0565b60008061100385600001518660a001518989808060200260200160405190810160405280939291908181526020016000905b828210156109ec57610ff460408302860136819003810190612d03565b81526020019060010190610fd7565b60a08701819052600154604051635023b4df60e01b81529294509092506000916101009091046001600160a01b031690635023b4df90611047908990600401612d5a565b6020604051808303816000875af1158015611066573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061108a9190612cea565b9050610f9a866000015182858b8b808060200260200160405190810160405280939291908181526020016000905b82821015610ad3576110d560408302860136819003810190612d03565b815260200190600101906110b8565b6060834211156111075760405163387b2e5560e11b815260040160405180910390fd5b6111118383611358565b949350505050565b6003546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa158015611162573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111869190612cea565b9050818110156111cc5760405162461bcd60e51b8152602060048201526011602482015270092dce6eaccccd2c6d2cadce840ae929ab607b1b6044820152606401610764565b801561077757600354604051632e1a7d4d60e01b8152600481018390526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b15801561121857600080fd5b505af115801561122c573d6000803e3d6000fd5b50505050600061123c3383611925565b905080610415576040516342fb4ceb60e11b81526004810184905260248101839052604401610764565b6112907f7a8dc26796a1e50e6e190b70259f58f6a4edd5b22280ceecc82b687b8e9828693361132f565b6112ac576040516282b42960e81b815260040160405180910390fd5b47156112de5760006112be8247611925565b90508061077757604051633398652560e11b815260040160405180910390fd5b50565b61130b7ffcb9fcbfa83b897fb2d5cf4b58962164105c1e71489a37ef3ae0db3fdce576f63361132f565b611327576040516282b42960e81b815260040160405180910390fd5b610b356119cf565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6060816001600160401b038111156113725761137261286a565b6040519080825280602002602001820160405280156113a557816020015b60608152602001906001900390816113905790505b50905060005b8281101561144557611415308585848181106113c9576113c9612e13565b90506020028101906113db9190612e29565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611a0a92505050565b82828151811061142757611427612e13565b6020026020010181905250808061143d90612e85565b9150506113ab565b5092915050565b600082815260208190526040902060010154611467816115a9565b6104158383611637565b6040516001600160a01b03831660248201526044810182905261041590849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611a2f565b60006001600160a01b03821633148061044b57506001600160a01b038216301492915050565b600061150582611b04565b506000806115138585611b77565b90925090506115228286612e9e565b945061152d81611ca0565b600354611543906001600160a01b031686611d7f565b50929392505050565b600061155782611b04565b506000806115658585611b77565b90925090506115748286612e9e565b94506115808682611e7c565b6115956001600160a01b038716333088611f85565b61159f8686611d7f565b5092949350505050565b6112de8133611fc3565b6115bd828261132f565b610777576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556115f33390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b611641828261132f565b15610777576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600080601483516116ad9190612e9e565b905060006116bd8483601461201c565b9050611111816000612129565b60008060006116d884611b04565b905060006116e882612710612eb1565b90506116f7866127108361218e565b600354909350611710906001600160a01b031684611d7f565b85935050505b9250929050565b600080600061172c8685611b77565b9150915061173981611ca0565b600260009054906101000a90046001600160a01b03166001600160a01b03166312210e8a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561178957600080fd5b505af115801561179d573d6000803e3d6000fd5b5050505060008287876117b09190612e9e565b6117ba9190612e9e565b604051909150600090339083156108fc0290849084818181858888f193505050509050806117fb576040516382e4f46960e01b815260040160405180910390fd5b6118058489612eb1565b98975050505050505050565b600080600061181f84611b04565b9050600061182f82612710612eb1565b905061183e866127108361218e565b925061184a8784611d7f565b61185f6001600160a01b038816333089611f85565b50939590945092505050565b600080600061187a8685611b77565b9150915061188887826121ce565b6118b233836118978989612e9e565b6118a19190612e9e565b6001600160a01b038a169190611471565b6118bc8287612eb1565b979650505050505050565b6118cf6122d5565b6001805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600061044b8282612129565b6000814710156119775760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e63650000006044820152606401610764565b6040516001600160a01b038416908390600081818185875af1925050503d80600081146119c0576040519150601f19603f3d011682016040523d82523d6000602084013e6119c5565b606091505b5090949350505050565b6119d761231e565b6001805460ff1916811790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258336118fc565b6060610ae08383604051806060016040528060278152602001612fcf60279139612364565b6000611a84826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166123d29092919063ffffffff16565b9050805160001480611aa5575080806020019051810190611aa59190612ec4565b6104155760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610764565b6000805b8251811015611b4e57828181518110611b2357611b23612e13565b60200260200101516020015182611b3a9190612eb1565b915080611b4681612e85565b915050611b08565b506103e8811115611b725760405163cd4e616760e01b815260040160405180910390fd5b919050565b6000606082516001600160401b03811115611b9457611b9461286a565b604051908082528060200260200182016040528015611bd957816020015b6040805180820190915260008082526020820152815260200190600190039081611bb25790505b50905060005b8351811015611c98576000611c1e858381518110611bff57611bff612e13565b602002602001015160200151612710886123e19092919063ffffffff16565b90506040518060400160405280868481518110611c3d57611c3d612e13565b6020026020010151600001516001600160a01b0316815260200182815250838381518110611c6d57611c6d612e13565b6020908102919091010152611c828185612eb1565b9350508080611c9090612e85565b915050611bdf565b509250929050565b60005b8151811015610777576000828281518110611cc057611cc0612e13565b602002602001015190506000611cde82600001518360200151611925565b905080611d1557815160208301516040516208c3b360e61b81526001600160a01b0390921660048301526024820152604401610764565b81600001516001600160a01b0316336001600160a01b03167fe0e765ab26c1caf691c510426951246128b96830e49cc81d8c093fd551abac358460200151604051611d6291815260200190565b60405180910390a350508080611d7790612e85565b915050611ca3565b600154604051636eb1769f60e11b81523060048201526001600160a01b0361010090920482166024820152829184169063dd62ed3e90604401602060405180830381865afa158015611dd5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611df99190612cea565b10156107775760015460405163095ea7b360e01b81526101009091046001600160a01b039081166004830152600019602483015283169063095ea7b3906044016020604051808303816000875af1158015611e58573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104159190612ec4565b60005b815181101561041557611ee233838381518110611e9e57611e9e612e13565b602002602001015160000151848481518110611ebc57611ebc612e13565b602002602001015160200151866001600160a01b0316611f85909392919063ffffffff16565b818181518110611ef457611ef4612e13565b6020026020010151600001516001600160a01b0316336001600160a01b0316846001600160a01b03167f1f9a9fdac86b6ca3c5300bec0b61555cded1f1a234378602dcca6c27085eac8e858581518110611f5057611f50612e13565b602002602001015160200151604051611f6b91815260200190565b60405180910390a480611f7d81612e85565b915050611e7f565b6040516001600160a01b0380851660248301528316604482015260648101829052611fbd9085906323b872dd60e01b9060840161149d565b50505050565b611fcd828261132f565b61077757611fda81612483565b611fe5836020612495565b604051602001611ff6929190612ee6565b60408051601f198184030181529082905262461bcd60e51b825261076491600401612f5b565b60608161202a81601f612eb1565b10156120695760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b6044820152606401610764565b6120738284612eb1565b845110156120b75760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b6044820152606401610764565b6060821580156120d65760405191506000825260208201604052612120565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561210f5780518352602092830192016120f7565b5050858452601f01601f1916604052505b50949350505050565b6000612136826014612eb1565b8351101561217e5760405162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b6044820152606401610764565b500160200151600160601b900490565b600061219b8484846123e1565b9050600082806121ad576121ad612f6e565b8486091115610ae05760001981106121c457600080fd5b6001019392505050565b60005b8151811015610415576122328282815181106121ef576121ef612e13565b60200260200101516000015183838151811061220d5761220d612e13565b602002602001015160200151856001600160a01b03166114719092919063ffffffff16565b81818151811061224457612244612e13565b6020026020010151600001516001600160a01b0316336001600160a01b0316846001600160a01b03167f1f9a9fdac86b6ca3c5300bec0b61555cded1f1a234378602dcca6c27085eac8e8585815181106122a0576122a0612e13565b6020026020010151602001516040516122bb91815260200190565b60405180910390a4806122cd81612e85565b9150506121d1565b60015460ff16610b355760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152606401610764565b60015460ff1615610b355760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610764565b6060600080856001600160a01b0316856040516123819190612f84565b600060405180830381855af49150503d80600081146123bc576040519150601f19603f3d011682016040523d82523d6000602084013e6123c1565b606091505b5091509150610da886838387612630565b606061111184846000856126a9565b6000838302816000198587098281108382030391505080841161240357600080fd5b8060000361241657508290049050610ae0565b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b606061044b6001600160a01b03831660145b606060006124a4836002612fa0565b6124af906002612eb1565b6001600160401b038111156124c6576124c661286a565b6040519080825280601f01601f1916602001820160405280156124f0576020820181803683370190505b509050600360fc1b8160008151811061250b5761250b612e13565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061253a5761253a612e13565b60200101906001600160f81b031916908160001a905350600061255e846002612fa0565b612569906001612eb1565b90505b60018111156125e1576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061259d5761259d612e13565b1a60f81b8282815181106125b3576125b3612e13565b60200101906001600160f81b031916908160001a90535060049490941c936125da81612fb7565b905061256c565b508315610ae05760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610764565b6060831561269f578251600003612698576001600160a01b0385163b6126985760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610764565b5081611111565b6111118383612779565b60608247101561270a5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610764565b600080866001600160a01b031685876040516127269190612f84565b60006040518083038185875af1925050503d8060008114612763576040519150601f19603f3d011682016040523d82523d6000602084013e612768565b606091505b50915091506118bc87838387612630565b8151156127895781518083602001fd5b8060405162461bcd60e51b81526004016107649190612f5b565b6001600160a01b03811681146112de57600080fd5b8035611b72816127a3565b600080604083850312156127d657600080fd5b82356127e1816127a3565b915060208301356127f1816127a3565b809150509250929050565b60006020828403121561280e57600080fd5b81356001600160e01b031981168114610ae057600080fd5b60008083601f84011261283857600080fd5b5081356001600160401b0381111561284f57600080fd5b6020830191508360208260061b850101111561171657600080fd5b634e487b7160e01b600052604160045260246000fd5b60405160e081016001600160401b03811182821017156128a2576128a261286a565b60405290565b604051608081016001600160401b03811182821017156128a2576128a261286a565b604051601f8201601f191681016001600160401b03811182821017156128f2576128f261286a565b604052919050565b600060e0828403121561290c57600080fd5b612914612880565b90508135612921816127a3565b81526020820135612931816127a3565b6020820152604082013562ffffff8116811461294c57600080fd5b604082015261295d606083016127b8565b60608201526080820135608082015260a082013560a082015261298260c083016127b8565b60c082015292915050565b600080600061010084860312156129a357600080fd5b83356001600160401b038111156129b957600080fd5b6129c586828701612826565b90945092506129d9905085602086016128fa565b90509250925092565b6000602082840312156129f457600080fd5b5035919050565b60008060408385031215612a0e57600080fd5b8235915060208301356127f1816127a3565b600060808284031215612a3257600080fd5b612a3a6128a8565b905081356001600160401b0380821115612a5357600080fd5b818401915084601f830112612a6757600080fd5b8135602082821115612a7b57612a7b61286a565b612a8d601f8301601f191682016128ca565b92508183528681838601011115612aa357600080fd5b81818501828501376000818385010152828552612ac18187016127b8565b8186015250505050604082013560408201526060820135606082015292915050565b600080600060408486031215612af857600080fd5b83356001600160401b0380821115612b0f57600080fd5b612b1b87838801612826565b90955093506020860135915080821115612b3457600080fd5b50612b4186828701612a20565b9150509250925092565b60008083601f840112612b5d57600080fd5b5081356001600160401b03811115612b7457600080fd5b6020830191508360208260051b850101111561171657600080fd5b600080600060408486031215612ba457600080fd5b8335925060208401356001600160401b03811115612bc157600080fd5b612bcd86828701612b4b565b9497909650939450505050565b60005b83811015612bf5578181015183820152602001612bdd565b50506000910152565b60008151808452612c16816020860160208601612bda565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015612c7f57603f19888603018452612c6d858351612bfe565b94509285019290850190600101612c51565b5092979650505050505050565b600060208284031215612c9e57600080fd5b8135610ae0816127a3565b60008060208385031215612cbc57600080fd5b82356001600160401b03811115612cd257600080fd5b612cde85828601612b4b565b90969095509350505050565b600060208284031215612cfc57600080fd5b5051919050565b600060408284031215612d1557600080fd5b604051604081018181106001600160401b0382111715612d3757612d3761286a565b6040528235612d45816127a3565b81526020928301359281019290925250919050565b60e0810161044b828480516001600160a01b03908116835260208083015182169084015260408083015162ffffff16908401526060808301518216908401526080808301519084015260a0828101519084015260c09182015116910152565b6000815160808452612dce6080850182612bfe565b6020848101516001600160a01b0316908601526040808501519086015260609384015193909401929092525090919050565b602081526000610ae06020830184612db9565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112612e4057600080fd5b8301803591506001600160401b03821115612e5a57600080fd5b60200191503681900382131561171657600080fd5b634e487b7160e01b600052601160045260246000fd5b600060018201612e9757612e97612e6f565b5060010190565b8181038181111561044b5761044b612e6f565b8082018082111561044b5761044b612e6f565b600060208284031215612ed657600080fd5b81518015158114610ae057600080fd5b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351612f1e816017850160208801612bda565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612f4f816028840160208801612bda565b01602801949350505050565b602081526000610ae06020830184612bfe565b634e487b7160e01b600052601260045260246000fd5b60008251612f96818460208701612bda565b9190910192915050565b808202811582820484141761044b5761044b612e6f565b600081612fc657612fc6612e6f565b50600019019056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122060463b8c42f8b619093981b0f594938e67042d40ad9d5eadd4922e9bc3000dde64736f6c63430008130033";
const isSuperArgs$1 = (xs) => xs.length > 1;
class SecondaryFee__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs$1(args)) {
            super(...args);
        }
        else {
            super(_abi$1, _bytecode$1, args[0]);
        }
    }
    deploy(_admin, _uniRouter, _wimx, overrides) {
        return super.deploy(_admin, _uniRouter, _wimx, overrides || {});
    }
    getDeployTransaction(_admin, _uniRouter, _wimx, overrides) {
        return super.getDeployTransaction(_admin, _uniRouter, _wimx, overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode$1;
    static abi = _abi$1;
    static createInterface() {
        return new utils$1.Interface(_abi$1);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$1, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        name: "Burn",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        name: "Collect",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        name: "CollectProtocol",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "paid0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "paid1",
                type: "uint256",
            },
        ],
        name: "Flash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint16",
                name: "observationCardinalityNextOld",
                type: "uint16",
            },
            {
                indexed: false,
                internalType: "uint16",
                name: "observationCardinalityNextNew",
                type: "uint16",
            },
        ],
        name: "IncreaseObservationCardinalityNext",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                indexed: false,
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
        ],
        name: "Initialize",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        name: "Mint",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol0Old",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol1Old",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol0New",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol1New",
                type: "uint8",
            },
        ],
        name: "SetFeeProtocol",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "int256",
                name: "amount0",
                type: "int256",
            },
            {
                indexed: false,
                internalType: "int256",
                name: "amount1",
                type: "int256",
            },
            {
                indexed: false,
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "liquidity",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
        ],
        name: "Swap",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
        ],
        name: "burn",
        outputs: [
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount0Requested",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1Requested",
                type: "uint128",
            },
        ],
        name: "collect",
        outputs: [
            {
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "uint128",
                name: "amount0Requested",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1Requested",
                type: "uint128",
            },
        ],
        name: "collectProtocol",
        outputs: [
            {
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "factory",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "fee",
        outputs: [
            {
                internalType: "uint24",
                name: "",
                type: "uint24",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "feeGrowthGlobal0X128",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "feeGrowthGlobal1X128",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "flash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint16",
                name: "observationCardinalityNext",
                type: "uint16",
            },
        ],
        name: "increaseObservationCardinalityNext",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "liquidity",
        outputs: [
            {
                internalType: "uint128",
                name: "",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "maxLiquidityPerTick",
        outputs: [
            {
                internalType: "uint128",
                name: "",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "mint",
        outputs: [
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        name: "observations",
        outputs: [
            {
                internalType: "uint32",
                name: "blockTimestamp",
                type: "uint32",
            },
            {
                internalType: "int56",
                name: "tickCumulative",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityCumulativeX128",
                type: "uint160",
            },
            {
                internalType: "bool",
                name: "initialized",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint32[]",
                name: "secondsAgos",
                type: "uint32[]",
            },
        ],
        name: "observe",
        outputs: [
            {
                internalType: "int56[]",
                name: "tickCumulatives",
                type: "int56[]",
            },
            {
                internalType: "uint160[]",
                name: "secondsPerLiquidityCumulativeX128s",
                type: "uint160[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "positions",
        outputs: [
            {
                internalType: "uint128",
                name: "liquidity",
                type: "uint128",
            },
            {
                internalType: "uint256",
                name: "feeGrowthInside0LastX128",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "feeGrowthInside1LastX128",
                type: "uint256",
            },
            {
                internalType: "uint128",
                name: "tokensOwed0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "tokensOwed1",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "protocolFees",
        outputs: [
            {
                internalType: "uint128",
                name: "token0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "token1",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "feeProtocol0",
                type: "uint8",
            },
            {
                internalType: "uint8",
                name: "feeProtocol1",
                type: "uint8",
            },
        ],
        name: "setFeeProtocol",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "slot0",
        outputs: [
            {
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
            {
                internalType: "uint16",
                name: "observationIndex",
                type: "uint16",
            },
            {
                internalType: "uint16",
                name: "observationCardinality",
                type: "uint16",
            },
            {
                internalType: "uint16",
                name: "observationCardinalityNext",
                type: "uint16",
            },
            {
                internalType: "uint8",
                name: "feeProtocol",
                type: "uint8",
            },
            {
                internalType: "bool",
                name: "unlocked",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
        ],
        name: "snapshotCumulativesInside",
        outputs: [
            {
                internalType: "int56",
                name: "tickCumulativeInside",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityInsideX128",
                type: "uint160",
            },
            {
                internalType: "uint32",
                name: "secondsInside",
                type: "uint32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "bool",
                name: "zeroForOne",
                type: "bool",
            },
            {
                internalType: "int256",
                name: "amountSpecified",
                type: "int256",
            },
            {
                internalType: "uint160",
                name: "sqrtPriceLimitX96",
                type: "uint160",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "swap",
        outputs: [
            {
                internalType: "int256",
                name: "amount0",
                type: "int256",
            },
            {
                internalType: "int256",
                name: "amount1",
                type: "int256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int16",
                name: "",
                type: "int16",
            },
        ],
        name: "tickBitmap",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "tickSpacing",
        outputs: [
            {
                internalType: "int24",
                name: "",
                type: "int24",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "",
                type: "int24",
            },
        ],
        name: "ticks",
        outputs: [
            {
                internalType: "uint128",
                name: "liquidityGross",
                type: "uint128",
            },
            {
                internalType: "int128",
                name: "liquidityNet",
                type: "int128",
            },
            {
                internalType: "uint256",
                name: "feeGrowthOutside0X128",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "feeGrowthOutside1X128",
                type: "uint256",
            },
            {
                internalType: "int56",
                name: "tickCumulativeOutside",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityOutsideX128",
                type: "uint160",
            },
            {
                internalType: "uint32",
                name: "secondsOutside",
                type: "uint32",
            },
            {
                internalType: "bool",
                name: "initialized",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "token0",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "token1",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
];
const _bytecode = "0x6101606040523480156200001257600080fd5b503060601b60805260408051630890357360e41b81529051600091339163890357309160048082019260a092909190829003018186803b1580156200005657600080fd5b505afa1580156200006b573d6000803e3d6000fd5b505050506040513d60a08110156200008257600080fd5b508051602080830151604084015160608086015160809096015160e896871b6001600160e81b0319166101005291811b6001600160601b031990811660e05292811b831660c0529390931b1660a052600282810b900b90921b610120529150620000f79082906200010f811b62002b8417901c565b60801b6001600160801b03191661014052506200017d565b60008082600281900b620d89e719816200012557fe5b05029050600083600281900b620d89e8816200013d57fe5b0502905060008460020b83830360020b816200015557fe5b0560010190508062ffffff166001600160801b038016816200017357fe5b0495945050505050565b60805160601c60a05160601c60c05160601c60e05160601c6101005160e81c6101205160e81c6101405160801c61567e6200024a60003980611fee5280614b5f5280614b96525080610c0052806128fd5280614bca5280614bfc525080610cef52806119cb5280611a0252806129455250806111c75280611a855280611ef4528061244452806129215280613e6b5250806108d252806112f55280611a545280611e8e52806123be5280613d2252508061207b528061227d52806128d9525080612bfb525061567e6000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806370cf754a116100ee578063c45a015511610097578063ddca3f4311610071578063ddca3f4314610800578063f305839914610820578063f30dba9314610828578063f637731d146108aa576101ae565b8063c45a0155146107d1578063d0c93a7c146107d9578063d21220a7146107f8576101ae565b8063883bdbfd116100c8578063883bdbfd14610633578063a34123a71461073c578063a38807f214610776576101ae565b806370cf754a146105c65780638206a4d1146105ce57806385b66729146105f6576101ae565b80633850c7bd1161015b578063490e6cbc11610135578063490e6cbc146104705780634f1eb3d8146104fc578063514ea4bf1461054d5780635339c296146105a6576101ae565b80633850c7bd1461035b5780633c8a7d8d146103b45780634614131914610456576101ae565b80631ad8b03b1161018c5780631ad8b03b146102aa578063252c09d7146102e157806332148f6714610338576101ae565b80630dfe1681146101b3578063128acb08146101d75780631a68650214610286575b600080fd5b6101bb6108d0565b604080516001600160a01b039092168252519081900360200190f35b61026d600480360360a08110156101ed57600080fd5b6001600160a01b0382358116926020810135151592604082013592606083013516919081019060a08101608082013564010000000081111561022e57600080fd5b82018360208201111561024057600080fd5b8035906020019184600183028401116401000000008311171561026257600080fd5b5090925090506108f4565b6040805192835260208301919091528051918290030190f35b61028e6114ad565b604080516001600160801b039092168252519081900360200190f35b6102b26114bc565b60405180836001600160801b03168152602001826001600160801b031681526020019250505060405180910390f35b6102fe600480360360208110156102f757600080fd5b50356114d6565b6040805163ffffffff909516855260069390930b60208501526001600160a01b039091168383015215156060830152519081900360800190f35b6103596004803603602081101561034e57600080fd5b503561ffff1661151c565b005b610363611616565b604080516001600160a01b03909816885260029690960b602088015261ffff9485168787015292841660608701529216608085015260ff90911660a0840152151560c0830152519081900360e00190f35b61026d600480360360a08110156103ca57600080fd5b6001600160a01b03823516916020810135600290810b92604083013590910b916001600160801b036060820135169181019060a08101608082013564010000000081111561041757600080fd5b82018360208201111561042957600080fd5b8035906020019184600183028401116401000000008311171561044b57600080fd5b509092509050611666565b61045e611922565b60408051918252519081900360200190f35b6103596004803603608081101561048657600080fd5b6001600160a01b0382351691602081013591604082013591908101906080810160608201356401000000008111156104bd57600080fd5b8201836020820111156104cf57600080fd5b803590602001918460018302840111640100000000831117156104f157600080fd5b509092509050611928565b6102b2600480360360a081101561051257600080fd5b506001600160a01b03813516906020810135600290810b91604081013590910b906001600160801b0360608201358116916080013516611d83565b61056a6004803603602081101561056357600080fd5b5035611f9d565b604080516001600160801b0396871681526020810195909552848101939093529084166060840152909216608082015290519081900360a00190f35b61045e600480360360208110156105bc57600080fd5b503560010b611fda565b61028e611fec565b610359600480360360408110156105e457600080fd5b5060ff81358116916020013516612010565b6102b26004803603606081101561060c57600080fd5b506001600160a01b03813516906001600160801b036020820135811691604001351661220f565b6106a36004803603602081101561064957600080fd5b81019060208101813564010000000081111561066457600080fd5b82018360208201111561067657600080fd5b8035906020019184602083028401116401000000008311171561069857600080fd5b5090925090506124dc565b604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b838110156106e75781810151838201526020016106cf565b50505050905001838103825284818151815260200191508051906020019060200280838360005b8381101561072657818101518382015260200161070e565b5050505090500194505050505060405180910390f35b61026d6004803603606081101561075257600080fd5b508035600290810b91602081013590910b90604001356001600160801b0316612569565b6107a06004803603604081101561078c57600080fd5b508035600290810b9160200135900b6126e0565b6040805160069490940b84526001600160a01b03909216602084015263ffffffff1682820152519081900360600190f35b6101bb6128d7565b6107e16128fb565b6040805160029290920b8252519081900360200190f35b6101bb61291f565b610808612943565b6040805162ffffff9092168252519081900360200190f35b61045e612967565b6108486004803603602081101561083e57600080fd5b503560020b61296d565b604080516001600160801b039099168952600f9790970b602089015287870195909552606087019390935260069190910b60808601526001600160a01b031660a085015263ffffffff1660c0840152151560e083015251908190036101000190f35b610359600480360360208110156108c057600080fd5b50356001600160a01b03166129db565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000806108ff612bf0565b85610936576040805162461bcd60e51b8152602060048201526002602482015261415360f01b604482015290519081900360640190fd5b6040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b900b602083015261ffff600160b81b8204811693830193909352600160c81b810483166060830152600160d81b8104909216608082015260ff600160e81b8304811660a0830152600160f01b909204909116151560c082018190526109ef576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b87610a3a5780600001516001600160a01b0316866001600160a01b0316118015610a35575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038716105b610a6c565b80600001516001600160a01b0316866001600160a01b0316108015610a6c57506401000276a36001600160a01b038716115b610aa3576040805162461bcd60e51b815260206004820152600360248201526214d41360ea1b604482015290519081900360640190fd5b6000805460ff60f01b191681556040805160c08101909152808a610ad25760048460a0015160ff16901c610ae5565b60108460a0015160ff1681610ae357fe5b065b60ff1681526004546001600160801b03166020820152604001610b06612c27565b63ffffffff168152602001600060060b815260200160006001600160a01b031681526020016000151581525090506000808913905060006040518060e001604052808b81526020016000815260200185600001516001600160a01b03168152602001856020015160020b81526020018c610b8257600254610b86565b6001545b815260200160006001600160801b0316815260200184602001516001600160801b031681525090505b805115801590610bd55750886001600160a01b031681604001516001600160a01b031614155b15610f9f57610be261560e565b60408201516001600160a01b031681526060820151610c25906006907f00000000000000000000000000000000000000000000000000000000000000008f612c2b565b15156040830152600290810b810b60208301819052620d89e719910b1215610c5657620d89e7196020820152610c75565b6020810151620d89e860029190910b1315610c7557620d89e860208201525b610c828160200151612d6d565b6001600160a01b031660608201526040820151610d13908d610cbc578b6001600160a01b031683606001516001600160a01b031611610cd6565b8b6001600160a01b031683606001516001600160a01b0316105b610ce4578260600151610ce6565b8b5b60c085015185517f000000000000000000000000000000000000000000000000000000000000000061309f565b60c085015260a084015260808301526001600160a01b031660408301528215610d7557610d498160c00151826080015101613291565b825103825260a0810151610d6b90610d6090613291565b6020840151906132a7565b6020830152610db0565b610d828160a00151613291565b825101825260c08101516080820151610daa91610d9f9101613291565b6020840151906132c3565b60208301525b835160ff1615610df6576000846000015160ff168260c0015181610dd057fe5b60c0840180519290910491829003905260a0840180519091016001600160801b03169052505b60c08201516001600160801b031615610e3557610e298160c00151600160801b8460c001516001600160801b03166132d9565b60808301805190910190525b80606001516001600160a01b031682604001516001600160a01b03161415610f5e57806040015115610f35578360a00151610ebf57610e9d846040015160008760200151886040015188602001518a606001516008613389909695949392919063ffffffff16565b6001600160a01b03166080860152600690810b900b6060850152600160a08501525b6000610f0b82602001518e610ed657600154610edc565b84608001515b8f610eeb578560800151610eef565b6002545b608089015160608a015160408b0151600595949392919061351c565b90508c15610f17576000035b610f258360c00151826135ef565b6001600160801b031660c0840152505b8b610f44578060200151610f4d565b60018160200151035b600290810b900b6060830152610f99565b80600001516001600160a01b031682604001516001600160a01b031614610f9957610f8c82604001516136a5565b600290810b900b60608301525b50610baf565b836020015160020b816060015160020b1461107a57600080610fed86604001518660400151886020015188602001518a606001518b6080015160086139d1909695949392919063ffffffff16565b604085015160608601516000805461ffff60c81b1916600160c81b61ffff958616021761ffff60b81b1916600160b81b95909416949094029290921762ffffff60a01b1916600160a01b62ffffff60029490940b93909316929092029190911773ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909116179055506110ac9050565b60408101516000805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b039092169190911790555b8060c001516001600160801b031683602001516001600160801b0316146110f25760c0810151600480546001600160801b0319166001600160801b039092169190911790555b8a1561114257608081015160015560a08101516001600160801b03161561113d5760a0810151600380546001600160801b031981166001600160801b03918216909301169190911790555b611188565b608081015160025560a08101516001600160801b0316156111885760a0810151600380546001600160801b03808216600160801b92839004821690940116029190911790555b8115158b1515146111a157602081015181518b036111ae565b80600001518a0381602001515b90965094508a156112e75760008512156111f0576111f07f00000000000000000000000000000000000000000000000000000000000000008d87600003613b86565b60006111fa613cd4565b9050336001600160a01b031663fa461e3388888c8c6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b15801561127e57600080fd5b505af1158015611292573d6000803e3d6000fd5b5050505061129e613cd4565b6112a88289613e0d565b11156112e1576040805162461bcd60e51b815260206004820152600360248201526249494160e81b604482015290519081900360640190fd5b50611411565b600086121561131e5761131e7f00000000000000000000000000000000000000000000000000000000000000008d88600003613b86565b6000611328613e1d565b9050336001600160a01b031663fa461e3388888c8c6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b1580156113ac57600080fd5b505af11580156113c0573d6000803e3d6000fd5b505050506113cc613e1d565b6113d68288613e0d565b111561140f576040805162461bcd60e51b815260206004820152600360248201526249494160e81b604482015290519081900360640190fd5b505b60408082015160c083015160608085015184518b8152602081018b90526001600160a01b03948516818701526001600160801b039093169183019190915260020b60808201529151908e169133917fc42079f94a6350d7e6235f29174924f928cc2ac818eb64fed8004e115fbcca679181900360a00190a350506000805460ff60f01b1916600160f01b17905550919890975095505050505050565b6004546001600160801b031681565b6003546001600160801b0380821691600160801b90041682565b60088161ffff81106114e757600080fd5b015463ffffffff81169150640100000000810460060b90600160581b81046001600160a01b031690600160f81b900460ff1684565b600054600160f01b900460ff16611560576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19169055611575612bf0565b60008054600160d81b900461ffff169061159160088385613eb5565b6000805461ffff808416600160d81b810261ffff60d81b19909316929092179092559192508316146115fe576040805161ffff80851682528316602082015281517fac49e518f90a358f652e4400164f05a5d8f7e35e7747279bc3a93dbf584e125a929181900390910190a15b50506000805460ff60f01b1916600160f01b17905550565b6000546001600160a01b03811690600160a01b810460020b9061ffff600160b81b8204811691600160c81b8104821691600160d81b8204169060ff600160e81b8204811691600160f01b90041687565b600080548190600160f01b900460ff166116ad576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b191690556001600160801b0385166116cd57600080fd5b60008061171b60405180608001604052808c6001600160a01b031681526020018b60020b81526020018a60020b81526020016117118a6001600160801b0316613f58565b600f0b9052613f69565b9250925050819350809250600080600086111561173d5761173a613cd4565b91505b841561174e5761174b613e1d565b90505b336001600160a01b031663d348799787878b8b6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b1580156117d057600080fd5b505af11580156117e4573d6000803e3d6000fd5b50505050600086111561183b576117f9613cd4565b6118038388613e0d565b111561183b576040805162461bcd60e51b815260206004820152600260248201526104d360f41b604482015290519081900360640190fd5b841561188b57611849613e1d565b6118538287613e0d565b111561188b576040805162461bcd60e51b81526020600482015260026024820152614d3160f01b604482015290519081900360640190fd5b8960020b8b60020b8d6001600160a01b03167f7a53080ba414158be7ec69b987b5fb7d07dee101fe85488f0853ae16239d0bde338d8b8b60405180856001600160a01b03168152602001846001600160801b0316815260200183815260200182815260200194505050505060405180910390a450506000805460ff60f01b1916600160f01b17905550919890975095505050505050565b60025481565b600054600160f01b900460ff1661196c576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19169055611981612bf0565b6004546001600160801b0316806119c3576040805162461bcd60e51b81526020600482015260016024820152601360fa1b604482015290519081900360640190fd5b60006119f8867f000000000000000000000000000000000000000000000000000000000000000062ffffff16620f42406141a9565b90506000611a2f867f000000000000000000000000000000000000000000000000000000000000000062ffffff16620f42406141a9565b90506000611a3b613cd4565b90506000611a47613e1d565b90508815611a7a57611a7a7f00000000000000000000000000000000000000000000000000000000000000008b8b613b86565b8715611aab57611aab7f00000000000000000000000000000000000000000000000000000000000000008b8a613b86565b336001600160a01b031663e9cbafb085858a8a6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b158015611b2d57600080fd5b505af1158015611b41573d6000803e3d6000fd5b505050506000611b4f613cd4565b90506000611b5b613e1d565b905081611b688588613e0d565b1115611ba0576040805162461bcd60e51b8152602060048201526002602482015261046360f41b604482015290519081900360640190fd5b80611bab8487613e0d565b1115611be3576040805162461bcd60e51b8152602060048201526002602482015261463160f01b604482015290519081900360640190fd5b8382038382038115611c725760008054600160e81b9004600f16908115611c16578160ff168481611c1057fe5b04611c19565b60005b90506001600160801b03811615611c4c57600380546001600160801b038082168401166001600160801b03199091161790555b611c66818503600160801b8d6001600160801b03166132d9565b60018054909101905550505b8015611cfd5760008054600160e81b900460041c600f16908115611ca2578160ff168381611c9c57fe5b04611ca5565b60005b90506001600160801b03811615611cd757600380546001600160801b03600160801b8083048216850182160291161790555b611cf1818403600160801b8d6001600160801b03166132d9565b60028054909101905550505b8d6001600160a01b0316336001600160a01b03167fbdbdb71d7860376ba52b25a5028beea23581364a40522f6bcfb86bb1f2dca6338f8f86866040518085815260200184815260200183815260200182815260200194505050505060405180910390a350506000805460ff60f01b1916600160f01b179055505050505050505050505050565b600080548190600160f01b900460ff16611dca576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19168155611de460073389896141e3565b60038101549091506001600160801b0390811690861611611e055784611e14565b60038101546001600160801b03165b60038201549093506001600160801b03600160801b909104811690851611611e3c5783611e52565b6003810154600160801b90046001600160801b03165b91506001600160801b03831615611eb7576003810180546001600160801b031981166001600160801b03918216869003821617909155611eb7907f0000000000000000000000000000000000000000000000000000000000000000908a908616613b86565b6001600160801b03821615611f1d576003810180546001600160801b03600160801b808304821686900382160291811691909117909155611f1d907f0000000000000000000000000000000000000000000000000000000000000000908a908516613b86565b604080516001600160a01b038a1681526001600160801b0380861660208301528416818301529051600288810b92908a900b9133917f70935338e69775456a85ddef226c395fb668b63fa0115f5f20610b388e6ca9c0919081900360600190a4506000805460ff60f01b1916600160f01b17905590969095509350505050565b60076020526000908152604090208054600182015460028301546003909301546001600160801b0392831693919281811691600160801b90041685565b60066020526000908152604090205481565b7f000000000000000000000000000000000000000000000000000000000000000081565b600054600160f01b900460ff16612054576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916905560408051638da5cb5b60e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001691638da5cb5b916004808301926020929190829003018186803b1580156120c157600080fd5b505afa1580156120d5573d6000803e3d6000fd5b505050506040513d60208110156120eb57600080fd5b50516001600160a01b0316331461210157600080fd5b60ff82161580612124575060048260ff16101580156121245750600a8260ff1611155b801561214e575060ff8116158061214e575060048160ff161015801561214e5750600a8160ff1611155b61215757600080fd5b60008054610ff0600484901b16840160ff908116600160e81b9081027fffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff841617909355919004167f973d8d92bb299f4af6ce49b52a8adb85ae46b9f214c4c4fc06ac77401237b1336010826040805160ff9390920683168252600f600486901c16602083015286831682820152918516606082015290519081900360800190a150506000805460ff60f01b1916600160f01b17905550565b600080548190600160f01b900460ff16612256576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916905560408051638da5cb5b60e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001691638da5cb5b916004808301926020929190829003018186803b1580156122c357600080fd5b505afa1580156122d7573d6000803e3d6000fd5b505050506040513d60208110156122ed57600080fd5b50516001600160a01b0316331461230357600080fd5b6003546001600160801b039081169085161161231f578361232c565b6003546001600160801b03165b6003549092506001600160801b03600160801b9091048116908416116123525782612366565b600354600160801b90046001600160801b03165b90506001600160801b038216156123e7576003546001600160801b038381169116141561239557600019909101905b600380546001600160801b031981166001600160801b039182168590038216179091556123e7907f00000000000000000000000000000000000000000000000000000000000000009087908516613b86565b6001600160801b0381161561246d576003546001600160801b03828116600160801b90920416141561241857600019015b600380546001600160801b03600160801b80830482168590038216029181169190911790915561246d907f00000000000000000000000000000000000000000000000000000000000000009087908416613b86565b604080516001600160801b0380851682528316602082015281516001600160a01b0388169233927f596b573906218d3411850b26a6b437d6c4522fdb43d2d2386263f86d50b8b151929081900390910190a36000805460ff60f01b1916600160f01b1790559094909350915050565b6060806124e7612bf0565b61255e6124f2612c27565b858580806020026020016040519081016040528093929190818152602001838360200280828437600092018290525054600454600896959450600160a01b820460020b935061ffff600160b81b8304811693506001600160801b0390911691600160c81b900416614247565b915091509250929050565b600080548190600160f01b900460ff166125b0576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916815560408051608081018252338152600288810b602083015287900b918101919091528190819061260990606081016125fc6001600160801b038a16613f58565b600003600f0b9052613f69565b925092509250816000039450806000039350600085118061262a5750600084115b15612669576003830180546001600160801b038082168089018216600160801b93849004831689019092169092029091176001600160801b0319161790555b604080516001600160801b0388168152602081018790528082018690529051600289810b92908b900b9133917f0c396cd989a39f4459b5fa1aed6a9a8dcdbc45908acfd67e028cd568da98982c919081900360600190a450506000805460ff60f01b1916600160f01b179055509094909350915050565b60008060006126ed612bf0565b6126f785856143a1565b600285810b810b60009081526005602052604080822087840b90930b825281206003830154600681900b9367010000000000000082046001600160a01b0316928492600160d81b810463ffffffff169284929091600160f81b900460ff168061275f57600080fd5b6003820154600681900b985067010000000000000081046001600160a01b03169650600160d81b810463ffffffff169450600160f81b900460ff16806127a457600080fd5b50506040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b810b6020840181905261ffff600160b81b8404811695850195909552600160c81b830485166060850152600160d81b8304909416608084015260ff600160e81b8304811660a0850152600160f01b909204909116151560c08301529093508e810b91900b1215905061284d575093909403965090039350900390506128d0565b8a60020b816020015160020b12156128c1576000612869612c27565b602083015160408401516004546060860151939450600093849361289f936008938893879392916001600160801b031690613389565b9a9003989098039b5050949096039290920396509091030392506128d0915050565b50949093039650039350900390505b9250925092565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60015481565b60056020526000908152604090208054600182015460028301546003909301546001600160801b03831693600160801b909304600f0b9290600681900b9067010000000000000081046001600160a01b031690600160d81b810463ffffffff1690600160f81b900460ff1688565b6000546001600160a01b031615612a1e576040805162461bcd60e51b8152602060048201526002602482015261414960f01b604482015290519081900360640190fd5b6000612a29826136a5565b9050600080612a41612a39612c27565b60089061446a565b6040805160e0810182526001600160a01b038816808252600288810b6020808501829052600085870181905261ffff898116606088018190529089166080880181905260a08801839052600160c0909801979097528154600160f01b73ffffffffffffffffffffffffffffffffffffffff19909116871762ffffff60a01b1916600160a01b62ffffff9787900b9790971696909602959095177fffffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffff16600160c81b9091021761ffff60d81b1916600160d81b909602959095177fff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1692909217909355835191825281019190915281519395509193507f98636036cb66a9c19a37435efc1e90142190214e8abeb821bdba3f2990dd4c9592918290030190a150505050565b60008082600281900b620d89e71981612b9957fe5b05029050600083600281900b620d89e881612bb057fe5b0502905060008460020b83830360020b81612bc757fe5b0560010190508062ffffff166001600160801b03801681612be457fe5b0493505050505b919050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614612c2557600080fd5b565b4290565b60008060008460020b8660020b81612c3f57fe5b05905060008660020b128015612c6657508460020b8660020b81612c5f57fe5b0760020b15155b15612c7057600019015b8315612ce557600080612c82836144b6565b600182810b810b600090815260208d9052604090205460ff83169190911b80016000190190811680151597509294509092509085612cc757888360ff16860302612cda565b88612cd1826144c8565b840360ff168603025b965050505050612d63565b600080612cf4836001016144b6565b91509150600060018260ff166001901b031990506000818b60008660010b60010b8152602001908152602001600020541690508060001415955085612d4657888360ff0360ff16866001010102612d5c565b8883612d5183614568565b0360ff168660010101025b9650505050505b5094509492505050565b60008060008360020b12612d84578260020b612d8c565b8260020b6000035b9050620d89e8811115612dca576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b600060018216612dde57600160801b612df0565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615612e24576ffff97272373d413259a46990580e213a0260801c5b6004821615612e43576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615612e62576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615612e81576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615612ea0576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615612ebf576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615612ede576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615612efe576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615612f1e576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615612f3e576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615612f5e576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615612f7e576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615612f9e576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615612fbe576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615612fde576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615612fff576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b6202000082161561301f576e5d6af8dedb81196699c329225ee6040260801c5b6204000082161561303e576d2216e584f5fa1ea926041bedfe980260801c5b6208000082161561305b576b048a170391f7dc42444e8fa20260801c5b60008460020b131561307657806000198161307257fe5b0490505b64010000000081061561308a57600161308d565b60005b60ff16602082901c0192505050919050565b60008080806001600160a01b03808916908a1610158187128015906131245760006130d88989620f42400362ffffff16620f42406132d9565b9050826130f1576130ec8c8c8c6001614652565b6130fe565b6130fe8b8d8c60016146cd565b955085811061310f578a965061311e565b61311b8c8b838661478a565b96505b5061316e565b8161313b576131368b8b8b60006146cd565b613148565b6131488a8c8b6000614652565b935083886000031061315c5789955061316e565b61316b8b8a8a600003856147d6565b95505b6001600160a01b038a81169087161482156131d15780801561318d5750815b6131a35761319e878d8c60016146cd565b6131a5565b855b95508080156131b2575081155b6131c8576131c3878d8c6000614652565b6131ca565b845b945061321b565b8080156131db5750815b6131f1576131ec8c888c6001614652565b6131f3565b855b9550808015613200575081155b613216576132118c888c60006146cd565b613218565b845b94505b8115801561322b57508860000385115b15613237578860000394505b81801561325657508a6001600160a01b0316876001600160a01b031614155b15613265578589039350613282565b61327f868962ffffff168a620f42400362ffffff166141a9565b93505b50505095509550955095915050565b6000600160ff1b82106132a357600080fd5b5090565b808203828113156000831215146132bd57600080fd5b92915050565b818101828112156000831215146132bd57600080fd5b600080806000198587098686029250828110908390030390508061330f576000841161330457600080fd5b508290049050613382565b80841161331b57600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008063ffffffff8716613430576000898661ffff1661ffff81106133aa57fe5b60408051608081018252919092015463ffffffff8082168084526401000000008304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff16151560608301529092508a161461341c57613419818a8988614822565b90505b806020015181604001519250925050613510565b8688036000806134458c8c858c8c8c8c6148d2565b91509150816000015163ffffffff168363ffffffff161415613477578160200151826040015194509450505050613510565b805163ffffffff8481169116141561349f578060200151816040015194509450505050613510565b8151815160208085015190840151918390039286039163ffffffff80841692908516910360060b816134cd57fe5b05028460200151018263ffffffff168263ffffffff1686604001518660400151036001600160a01b031602816134ff57fe5b048560400151019650965050505050505b97509795505050505050565b600295860b860b60009081526020979097526040909620600181018054909503909455938301805490920390915560038201805463ffffffff600160d81b6001600160a01b036701000000000000008085048216909603169094027fffffffffff0000000000000000000000000000000000000000ffffffffffffff90921691909117600681810b90960390950b66ffffffffffffff1666ffffffffffffff199095169490941782810485169095039093160263ffffffff60d81b1990931692909217905554600160801b9004600f0b90565b60008082600f0b121561365457826001600160801b03168260000384039150816001600160801b03161061364f576040805162461bcd60e51b81526020600482015260026024820152614c5360f01b604482015290519081900360640190fd5b6132bd565b826001600160801b03168284019150816001600160801b031610156132bd576040805162461bcd60e51b81526020600482015260026024820152614c4160f01b604482015290519081900360640190fd5b60006401000276a36001600160a01b038316108015906136e1575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b613716576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166001600160801b03811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c979088119617909417909217179091171717608081106137b757607f810383901c91506137c1565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146139c257886001600160a01b03166139a682612d6d565b6001600160a01b031611156139bb57816139bd565b805b6139c4565b815b9998505050505050505050565b6000806000898961ffff1661ffff81106139e757fe5b60408051608081018252919092015463ffffffff8082168084526401000000008304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff161515606083015290925089161415613a575788859250925050613510565b8461ffff168461ffff16118015613a7857506001850361ffff168961ffff16145b15613a8557839150613a89565b8491505b8161ffff168960010161ffff1681613a9d57fe5b069250613aac81898989614822565b8a8461ffff1661ffff8110613abd57fe5b825191018054602084015160408501516060909501511515600160f81b027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6001600160a01b03909616600160581b027fff0000000000000000000000000000000000000000ffffffffffffffffffffff60069390930b66ffffffffffffff16640100000000026affffffffffffff000000001963ffffffff90971663ffffffff199095169490941795909516929092171692909217929092161790555097509795505050505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b1781529251825160009485949389169392918291908083835b60208310613c025780518252601f199092019160209182019101613be3565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114613c64576040519150601f19603f3d011682016040523d82523d6000602084013e613c69565b606091505b5091509150818015613c97575080511580613c975750808060200190516020811015613c9457600080fd5b50515b613ccd576040805162461bcd60e51b81526020600482015260026024820152612a2360f11b604482015290519081900360640190fd5b5050505050565b604080513060248083019190915282518083039091018152604490910182526020810180516001600160e01b03166370a0823160e01b17815291518151600093849384936001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001693919290918291908083835b60208310613d6d5780518252601f199092019160209182019101613d4e565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d8060008114613dcd576040519150601f19603f3d011682016040523d82523d6000602084013e613dd2565b606091505b5091509150818015613de657506020815110155b613def57600080fd5b808060200190516020811015613e0457600080fd5b50519250505090565b808201828110156132bd57600080fd5b604080513060248083019190915282518083039091018152604490910182526020810180516001600160e01b03166370a0823160e01b17815291518151600093849384936001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016939192909182919080838360208310613d6d5780518252601f199092019160209182019101613d4e565b6000808361ffff1611613ef3576040805162461bcd60e51b81526020600482015260016024820152604960f81b604482015290519081900360640190fd5b8261ffff168261ffff1611613f09575081613382565b825b8261ffff168161ffff161015613f4f576001858261ffff1661ffff8110613f2e57fe5b01805463ffffffff191663ffffffff92909216919091179055600101613f0b565b50909392505050565b80600f81900b8114612beb57600080fd5b6000806000613f76612bf0565b613f88846020015185604001516143a1565b6040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b900b602080840182905261ffff600160b81b8404811685870152600160c81b84048116606080870191909152600160d81b8504909116608086015260ff600160e81b8504811660a0870152600160f01b909404909316151560c08501528851908901519489015192890151939461402c9491939092909190614acf565b93508460600151600f0b6000146141a157846020015160020b816020015160020b12156140815761407a6140638660200151612d6d565b6140708760400151612d6d565b8760600151614c84565b92506141a1565b846040015160020b816020015160020b12156141775760045460408201516001600160801b03909116906140d3906140b7612c27565b60208501516060860151608087015160089493929187916139d1565b6000805461ffff60c81b1916600160c81b61ffff938416021761ffff60b81b1916600160b81b939092169290920217905581516040870151614123919061411990612d6d565b8860600151614c84565b93506141416141358760200151612d6d565b83516060890151614cc8565b92506141518187606001516135ef565b600480546001600160801b0319166001600160801b0392909216919091179055506141a1565b61419e6141878660200151612d6d565b6141948760400151612d6d565b8760600151614cc8565b91505b509193909250565b60006141b68484846132d9565b9050600082806141c257fe5b84860911156133825760001981106141d957600080fd5b6001019392505050565b6040805160609490941b6bffffffffffffffffffffffff1916602080860191909152600293840b60e890811b60348701529290930b90911b60378401528051808403601a018152603a90930181528251928201929092206000908152929052902090565b60608060008361ffff1611614287576040805162461bcd60e51b81526020600482015260016024820152604960f81b604482015290519081900360640190fd5b865167ffffffffffffffff8111801561429f57600080fd5b506040519080825280602002602001820160405280156142c9578160200160208202803683370190505b509150865167ffffffffffffffff811180156142e457600080fd5b5060405190808252806020026020018201604052801561430e578160200160208202803683370190505b50905060005b87518110156143945761433f8a8a8a848151811061432e57fe5b60200260200101518a8a8a8a613389565b84838151811061434b57fe5b6020026020010184848151811061435e57fe5b60200260200101826001600160a01b03166001600160a01b03168152508260060b60060b81525050508080600101915050614314565b5097509795505050505050565b8060020b8260020b126143e1576040805162461bcd60e51b8152602060048201526003602482015262544c5560e81b604482015290519081900360640190fd5b620d89e719600283900b1215614424576040805162461bcd60e51b8152602060048201526003602482015262544c4d60e81b604482015290519081900360640190fd5b620d89e8600282900b1315614466576040805162461bcd60e51b815260206004820152600360248201526254554d60e81b604482015290519081900360640190fd5b5050565b6040805160808101825263ffffffff9283168082526000602083018190529282019290925260016060909101819052835463ffffffff1916909117909116600160f81b17909155908190565b60020b600881901d9161010090910790565b60008082116144d657600080fd5b600160801b82106144e957608091821c91015b68010000000000000000821061450157604091821c91015b640100000000821061451557602091821c91015b62010000821061452757601091821c91015b610100821061453857600891821c91015b6010821061454857600491821c91015b6004821061455857600291821c91015b60028210612beb57600101919050565b600080821161457657600080fd5b5060ff6001600160801b0382161561459157607f1901614599565b608082901c91505b67ffffffffffffffff8216156145b257603f19016145ba565b604082901c91505b63ffffffff8216156145cf57601f19016145d7565b602082901c91505b61ffff8216156145ea57600f19016145f2565b601082901c91505b60ff821615614604576007190161460c565b600882901c91505b600f82161561461e5760031901614626565b600482901c91505b60038216156146385760011901614640565b600282901c91505b6001821615612beb5760001901919050565b6000836001600160a01b0316856001600160a01b03161115614672579293925b8161469f5761469a836001600160801b03168686036001600160a01b0316600160601b6132d9565b6146c2565b6146c2836001600160801b03168686036001600160a01b0316600160601b6141a9565b90505b949350505050565b6000836001600160a01b0316856001600160a01b031611156146ed579293925b7bffffffffffffffffffffffffffffffff000000000000000000000000606084901b166001600160a01b03868603811690871661472957600080fd5b8361475957866001600160a01b031661474c8383896001600160a01b03166132d9565b8161475357fe5b0461477f565b61477f6147708383896001600160a01b03166141a9565b886001600160a01b0316614cf7565b979650505050505050565b600080856001600160a01b0316116147a157600080fd5b6000846001600160801b0316116147b757600080fd5b816147c95761469a8585856001614d02565b6146c28585856001614de3565b600080856001600160a01b0316116147ed57600080fd5b6000846001600160801b03161161480357600080fd5b816148155761469a8585856000614de3565b6146c28585856000614d02565b61482a61564a565b600085600001518503905060405180608001604052808663ffffffff1681526020018263ffffffff168660020b0288602001510160060b81526020016000856001600160801b03161161487e576001614880565b845b6001600160801b031673ffffffff00000000000000000000000000000000608085901b16816148ab57fe5b048860400151016001600160a01b0316815260200160011515815250915050949350505050565b6148da61564a565b6148e261564a565b888561ffff1661ffff81106148f357fe5b60408051608081018252919092015463ffffffff81168083526401000000008204600690810b810b900b6020840152600160581b82046001600160a01b031693830193909352600160f81b900460ff1615156060820152925061495890899089614ed8565b15614990578663ffffffff16826000015163ffffffff16141561497a57613510565b8161498783898988614822565b91509150613510565b888361ffff168660010161ffff16816149a557fe5b0661ffff1661ffff81106149b557fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b90910416151560608201819052909250614a6c57604080516080810182528a5463ffffffff811682526401000000008104600690810b810b900b6020830152600160581b81046001600160a01b031692820192909252600160f81b90910460ff161515606082015291505b614a7b88836000015189614ed8565b614ab2576040805162461bcd60e51b815260206004820152600360248201526213d31160ea1b604482015290519081900360640190fd5b614abf8989898887614f9b565b9150915097509795505050505050565b6000614ade60078787876141e3565b60015460025491925090600080600f87900b15614c24576000614aff612c27565b6000805460045492935090918291614b499160089186918591600160a01b810460020b9161ffff600160b81b83048116926001600160801b0390921691600160c81b900416613389565b9092509050614b8360058d8b8d8b8b87898b60007f000000000000000000000000000000000000000000000000000000000000000061513b565b9450614bba60058c8b8d8b8b87898b60017f000000000000000000000000000000000000000000000000000000000000000061513b565b93508415614bee57614bee60068d7f0000000000000000000000000000000000000000000000000000000000000000615325565b8315614c2057614c2060068c7f0000000000000000000000000000000000000000000000000000000000000000615325565b5050505b600080614c3660058c8c8b8a8a61538b565b9092509050614c47878a8484615437565b600089600f0b1215614c75578315614c6457614c6460058c6155cc565b8215614c7557614c7560058b6155cc565b50505050505095945050505050565b60008082600f0b12614caa57614ca5614ca085858560016146cd565b613291565b6146c5565b614cbd614ca085858560000360006146cd565b600003949350505050565b60008082600f0b12614ce457614ca5614ca08585856001614652565b614cbd614ca08585856000036000614652565b808204910615150190565b60008115614d755760006001600160a01b03841115614d3857614d3384600160601b876001600160801b03166132d9565b614d50565b6001600160801b038516606085901b81614d4e57fe5b045b9050614d6d614d686001600160a01b03881683613e0d565b6155f8565b9150506146c5565b60006001600160a01b03841115614da357614d9e84600160601b876001600160801b03166141a9565b614dba565b614dba606085901b6001600160801b038716614cf7565b905080866001600160a01b031611614dd157600080fd5b6001600160a01b0386160390506146c5565b600082614df15750836146c5565b7bffffffffffffffffffffffffffffffff000000000000000000000000606085901b168215614e91576001600160a01b03861684810290858281614e3157fe5b041415614e6257818101828110614e6057614e5683896001600160a01b0316836141a9565b93505050506146c5565b505b614e8882614e83878a6001600160a01b03168681614e7c57fe5b0490613e0d565b614cf7565b925050506146c5565b6001600160a01b03861684810290858281614ea857fe5b04148015614eb557508082115b614ebe57600080fd5b808203614e56614d68846001600160a01b038b16846141a9565b60008363ffffffff168363ffffffff1611158015614f0257508363ffffffff168263ffffffff1611155b15614f1e578163ffffffff168363ffffffff1611159050613382565b60008463ffffffff168463ffffffff1611614f46578363ffffffff1664010000000001614f4e565b8363ffffffff165b64ffffffffff16905060008563ffffffff168463ffffffff1611614f7f578363ffffffff1664010000000001614f87565b8363ffffffff165b64ffffffffff169091111595945050505050565b614fa361564a565b614fab61564a565b60008361ffff168560010161ffff1681614fc157fe5b0661ffff169050600060018561ffff16830103905060005b506002818301048961ffff87168281614fee57fe5b0661ffff8110614ffa57fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b9091041615156060820181905290955061506557806001019250614fd9565b898661ffff16826001018161507657fe5b0661ffff811061508257fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b909104161515606082015285519094506000906150ed908b908b614ed8565b905080801561510657506151068a8a8760000151614ed8565b15615111575061512e565b8061512157600182039250615128565b8160010193505b50614fd9565b5050509550959350505050565b60028a810b900b600090815260208c90526040812080546001600160801b031682615166828d6135ef565b9050846001600160801b0316816001600160801b031611156151b4576040805162461bcd60e51b81526020600482015260026024820152614c4f60f01b604482015290519081900360640190fd5b6001600160801b03828116159082161581141594501561528a578c60020b8e60020b1361525a57600183018b9055600283018a90556003830180547fffffffffff0000000000000000000000000000000000000000ffffffffffffff166701000000000000006001600160a01b038c16021766ffffffffffffff191666ffffffffffffff60068b900b161763ffffffff60d81b1916600160d81b63ffffffff8a16021790555b6003830180547effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16600160f81b1790555b82546001600160801b0319166001600160801b038216178355856152d35782546152ce906152c990600160801b9004600f90810b810b908f900b6132c3565b613f58565b6152f4565b82546152f4906152c990600160801b9004600f90810b810b908f900b6132a7565b8354600f9190910b6001600160801b03908116600160801b0291161790925550909c9b505050505050505050505050565b8060020b8260020b8161533457fe5b0760020b1561534257600080fd5b60008061535d8360020b8560020b8161535757fe5b056144b6565b600191820b820b60009081526020979097526040909620805460ff9097169190911b90951890945550505050565b600285810b80820b60009081526020899052604080822088850b850b83529082209193849391929184918291908a900b126153d1575050600182015460028301546153e4565b8360010154880391508360020154870390505b6000808b60020b8b60020b121561540657505060018301546002840154615419565b84600101548a0391508460020154890390505b92909803979097039b96909503949094039850939650505050505050565b6040805160a08101825285546001600160801b0390811682526001870154602083015260028701549282019290925260038601548083166060830152600160801b900490911660808201526000600f85900b6154d65781516001600160801b03166154ce576040805162461bcd60e51b815260206004820152600260248201526104e560f41b604482015290519081900360640190fd5b5080516154e5565b81516154e290866135ef565b90505b60006155098360200151860384600001516001600160801b0316600160801b6132d9565b9050600061552f8460400151860385600001516001600160801b0316600160801b6132d9565b905086600f0b6000146155565787546001600160801b0319166001600160801b0384161788555b60018801869055600288018590556001600160801b03821615158061558457506000816001600160801b0316115b156155c2576003880180546001600160801b031981166001600160801b039182168501821617808216600160801b9182900483168501909216021790555b5050505050505050565b600290810b810b6000908152602092909252604082208281556001810183905590810182905560030155565b806001600160a01b0381168114612beb57600080fd5b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805160808101825260008082526020820181905291810182905260608101919091529056fea164736f6c6343000706000a";
const isSuperArgs = (xs) => xs.length > 1;
class UniswapV3Pool__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs(args)) {
            super(...args);
        }
        else {
            super(_abi, _bytecode, args[0]);
        }
    }
    deploy(overrides) {
        return super.deploy(overrides || {});
    }
    getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode;
    static abi = _abi;
    static createInterface() {
        return new utils$1.Interface(_abi);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi, signerOrProvider);
    }
}

// TODO: Better description of function and args
async function multicallSingleCallDataMultipleContracts(multicallContract, functionName, addresses) {
    // Encode args - generate calldata for contract
    const contractIFace = UniswapV3Pool__factory.createInterface();
    // TODO: fix used before defined error
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    const callData = getCallData(functionName, contractIFace);
    const calls = [];
    if (callData) {
        addresses.forEach((address) => {
            if (address) {
                calls.push({
                    target: address,
                    callData,
                    gasLimit: BigNumber$1.from('1000000'),
                });
            }
        });
    }
    return multicallContract.callStatic.multicall(calls);
}
const getCallData = (methodName, contractInterface) => {
    // Create ethers function fragment
    const fragment = contractInterface?.getFunction(methodName);
    return fragment ? contractInterface?.encodeFunctionData(fragment) : undefined;
};

// 0.1% default slippage
const DEFAULT_SLIPPAGE = 0.1;
// 15 minutes from the time the transaction was prepared
const DEFAULT_DEADLINE_SECONDS = 60 * 15;
// most swaps will be able to resolve with 2 hops
const DEFAULT_MAX_HOPS = 2;
// after 10 hops, it is very unlikely a route will be available
const MAX_MAX_HOPS = 10;
// a max hop of 1 will require a direct swap with no intermediary pools
const MIN_MAX_HOPS = 1;
// precision used to calculate percentage from basis points
const BASIS_POINT_PRECISION = 10000;
// 10% maximum secondary fee
const MAX_SECONDARY_FEE_BASIS_POINTS = 1000;

const quoteReturnMapping = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xcdca1753': ['uint256', 'uint160[]', 'uint32[]', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xc6a5026a': ['uint256', 'uint160', 'uint32', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0x2f80bb1d': ['uint256', 'uint160[]', 'uint32[]', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xbd21704a': ['uint256', 'uint160', 'uint32', 'uint256'],
};
/**
 * Returns true if poolA is equivalent to poolB
 * @param poolA one of the two pools
 * @param poolB the other pool
 */
function poolEquals(poolA, poolB) {
    return (poolA === poolB ||
        (poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1) && poolA.fee === poolB.fee));
}
const decimalsFunctionSig = ethers.utils.id('decimals()').substring(0, 10);
async function getTokenDecimals(tokenAddress, provider, nativeToken) {
    if (tokenAddress === 'native') {
        return nativeToken.decimals;
    }
    try {
        const decimalsResult = await provider.call({
            to: tokenAddress,
            data: decimalsFunctionSig,
        });
        return parseInt(decimalsResult, 16);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ProviderCallError(`failed to get ERC20 decimals: ${message}`);
    }
}
/**
 * Based on https://github.com/ethers-io/ethers.js/blob/main/src.ts/address/checks.ts#L51
 */
function isValidNonZeroAddress(address) {
    if (address === ethers.constants.AddressZero) {
        return false;
    }
    try {
        ethers.utils.getAddress(address);
        return true;
    }
    catch (error) {
        return false;
    }
}
const isValidTokenLiteral = (address) => address === 'native' ? true : isValidNonZeroAddress(address);
const erc20ToUniswapToken = (token) => 
// eslint-disable-next-line implicit-arrow-linebreak
new Uniswap.Token(token.chainId, token.address, token.decimals, token.symbol, token.name);
const uniswapTokenToERC20 = (token) => ({
    chainId: token.chainId,
    address: token.address,
    decimals: token.decimals,
    symbol: token.symbol,
    name: token.name,
    type: 'erc20',
});
const toCurrencyAmount = (amount) => {
    const token = erc20ToUniswapToken(amount.token);
    return Uniswap.CurrencyAmount.fromRawAmount(token, amount.value.toString());
};
const newAmount = (amount, token) => ({
    value: amount,
    token,
});
const isERC20Amount = (amount) => amount.token.type === 'erc20';
const isNativeAmount = (amount) => amount.token.type === 'native';
const isNative = (token) => token.type === 'native';
const addERC20Amount = (a, b) => {
    // Make sure the ERC20s have the same address
    if (a.token.address !== b.token.address)
        throw new Error('Token mismatch: token addresses must be the same');
    return { value: a.value.add(b.value), token: a.token };
};
const addNativeAmount = (a, b) => ({
    value: a.value.add(b.value),
    token: a.token,
});
const addAmount = (a, b) => {
    if (isERC20Amount(a) && isERC20Amount(b)) {
        return addERC20Amount(a, b);
    }
    if (isNativeAmount(a) && isNativeAmount(b)) {
        return addNativeAmount(a, b);
    }
    throw new Error('Token mismatch: token types must be the same');
};
const subtractERC20Amount = (a, b) => {
    // Make sure the ERC20s have the same address
    if (a.token.address !== b.token.address)
        throw new Error('Token mismatch: token addresses must be the same');
    return { value: a.value.sub(b.value), token: a.token };
};
const subtractNativeAmount = (a, b) => ({
    value: a.value.sub(b.value),
    token: a.token,
});
const subtractAmount = (a, b) => {
    if (isERC20Amount(a) && isERC20Amount(b)) {
        return subtractERC20Amount(a, b);
    }
    if (isNativeAmount(a) && isNativeAmount(b)) {
        return subtractNativeAmount(a, b);
    }
    throw new Error('Token mismatch: token types must be the same');
};
/**
 * Converts our internal token type which could be ERC20 or Native
 * into a format consumable by Checkout. They require an address to be
 * present. We populate the address with the string 'native' if it's Native.
 * If it's ERC20, we don't need to change it.
 */
const toPublicTokenType = (token) => {
    if (token.type === 'native') {
        return {
            address: 'native',
            chainId: token.chainId,
            decimals: token.decimals,
            symbol: token.symbol,
            name: token.name,
        };
    }
    return token;
};
const toPublicAmount = (amount) => ({
    token: toPublicTokenType(amount.token),
    value: amount.value,
});
const getDefaultDeadlineSeconds = () => Math.floor(Date.now() / 1000) + DEFAULT_DEADLINE_SECONDS;

const amountIndex = 0;
const gasEstimateIndex = 3;
async function getQuotesForRoutes(provider, quoterContractAddress, routes, amountSpecified, tradeType) {
    const callDatas = routes.map((route) => SwapQuoter.quoteCallParameters(route, toCurrencyAmount(amountSpecified), tradeType, {
        useQuoterV2: true,
    }).calldata);
    const promises = await Promise.allSettled(callDatas.map((data) => provider.send('eth_call', [
        { to: quoterContractAddress, data }, 'latest',
    ])));
    const decodedQuoteResults = promises.reduce((quoteResults, promiseResult, i) => {
        if (promiseResult.status === 'rejected')
            return quoteResults;
        const functionSig = callDatas[i].substring(0, 10);
        const returnTypes = quoteReturnMapping[functionSig];
        if (!returnTypes) {
            throw new Error('No quoting function signature found');
        }
        if (promiseResult.value === '0x') {
            // There is no quote result for the swap using this route, so don't include it in results
            return quoteResults;
        }
        try {
            const decodedQuoteResult = utils$1.defaultAbiCoder.decode(returnTypes, promiseResult.value);
            if (decodedQuoteResult) {
                // The 0th element in each decoded data is going to be the amountOut or amountIn.
                const quoteAmount = decodedQuoteResult[amountIndex];
                if (!(quoteAmount instanceof BigNumber$1))
                    throw new Error('Expected BigNumber');
                const input = uniswapTokenToERC20(routes[i].input);
                const output = uniswapTokenToERC20(routes[i].output);
                quoteResults.push({
                    route: routes[i],
                    amountIn: tradeType === TradeType.EXACT_INPUT ? amountSpecified : newAmount(quoteAmount, input),
                    amountOut: tradeType === TradeType.EXACT_INPUT ? newAmount(quoteAmount, output) : amountSpecified,
                    gasEstimate: BigNumber$1.from(decodedQuoteResult[gasEstimateIndex]),
                    tradeType,
                });
            }
        }
        catch {
            // Failed to get the quote for this particular route
            // Other quotes for routes may still succeed, so do nothing
            // and continue processing
        }
        return quoteResults;
    }, new Array());
    return decodedQuoteResults;
}

// Hard-coded into factory contract
const POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54';
function computePoolAddress({ factoryAddress, erc20Pair, fee, initCodeHashManualOverride, }) {
    // erc20 addresses need to be in alphabetical order to correctly identify a pool
    // eslint-disable-next-line @typescript-eslint/no-use-before-define, no-param-reassign
    erc20Pair = ensureCorrectERC20AddressOrder(erc20Pair);
    return ethers.utils.getCreate2Address(factoryAddress, keccak256$1(['bytes'], [
        ethers.utils.defaultAbiCoder.encode(['address', 'address', 'uint24'], [erc20Pair[0].address, erc20Pair[1].address, fee]),
    ]), initCodeHashManualOverride ?? POOL_INIT_CODE_HASH);
}
const ensureCorrectERC20AddressOrder = (erc20Pair) => {
    if (erc20Pair[0].address.toLowerCase() > erc20Pair[1].address.toLowerCase()) {
        const temp = erc20Pair[0];
        // eslint-disable-next-line prefer-destructuring, no-param-reassign
        erc20Pair[0] = erc20Pair[1];
        // eslint-disable-next-line no-param-reassign
        erc20Pair[1] = temp;
    }
    return erc20Pair;
};

// GenerateERC20Pairs will generate all possible ERC20 pair combinations, excluding duplicates
const generateERC20Pairs = (erc20Pair, commonRoutingERC20s) => {
    const contractAddressMap = new Map();
    const contractAddresses = [];
    [...erc20Pair, ...commonRoutingERC20s].forEach((erc20) => {
        contractAddressMap.set(erc20.address, erc20);
        contractAddresses.push(erc20.address);
    });
    const uniqueERC20Addresses = new Set([...contractAddresses]);
    const erc20Addresses = [...uniqueERC20Addresses];
    const erc20Pairs = [];
    for (let i = 0; i < erc20Addresses.length; i++) {
        for (let j = i + 1; j < erc20Addresses.length; j++) {
            const firstToken = contractAddressMap.get(erc20Addresses[i]);
            const secondToken = contractAddressMap.get(erc20Addresses[j]);
            if (firstToken && secondToken) {
                erc20Pairs.push([firstToken, secondToken]);
            }
        }
    }
    return erc20Pairs;
};

const poolFees = [
    FeeAmount.LOWEST,
    FeeAmount.LOW,
    FeeAmount.MEDIUM,
    FeeAmount.HIGH,
];
// generatePossiblePoolsFromERC20Pair will compute all possible pool combinations
// from the erc20Pair, commonRoutingERC20s and PoolFees
const generatePossiblePoolsFromERC20Pair = (erc20Pair, commonRoutingERC20s, factoryAddress) => {
    const erc20Pairs = generateERC20Pairs(erc20Pair, commonRoutingERC20s);
    const poolIDs = [];
    for (let i = 0; i < erc20Pairs.length; i++) {
        for (let j = 0; j < poolFees.length; j++) {
            // Compute the address of the pool using its unique identifier (tokenA, tokenB, fee)
            // Computing an address does not mean the pool is guaranteed to exist
            const poolAddress = computePoolAddress({
                factoryAddress,
                erc20Pair: erc20Pairs[i],
                fee: poolFees[j],
            });
            poolIDs.push({
                erc20Pair: erc20Pairs[i],
                fee: poolFees[j],
                poolAddress,
            });
        }
    }
    return poolIDs;
};

const liquidityFuncString = 'liquidity';
const slot0FuncString = 'slot0';
const noDataResult = '0x';
// TODO: Split into fetchPools and filterPools methods
// in order to allow for better error handling/separation of concerns
const fetchValidPools = async (multicallContract, erc20Pair, commonRoutingERC20s, factoryAddress) => {
    const poolIDs = generatePossiblePoolsFromERC20Pair(erc20Pair, commonRoutingERC20s, factoryAddress);
    const poolAddresses = poolIDs.map((pool) => pool.poolAddress);
    // The multicall contract returns data in the same order as the given pool addresses
    // Indexes of pool addresses will map to the indexes of the results
    let slot0Results;
    let liquidityResults;
    try {
        [slot0Results, liquidityResults] = await Promise.all([
            multicallSingleCallDataMultipleContracts(multicallContract, slot0FuncString, poolAddresses),
            multicallSingleCallDataMultipleContracts(multicallContract, liquidityFuncString, poolAddresses),
        ]);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ProviderCallError(`failed multicall: ${message}`);
    }
    const slot0s = slot0Results.returnData;
    const liquidities = liquidityResults.returnData;
    const uniswapV3Pool = UniswapV3Pool__factory.createInterface();
    const validPools = [];
    poolIDs.forEach((poolID, index) => {
        const noPriceResult = slot0Results.returnData[index].returnData === noDataResult;
        const noLiquidityResult = liquidityResults.returnData[index].returnData === noDataResult;
        // This indicates that the pool doesn't exist
        if (noPriceResult || noLiquidityResult) {
            return;
        }
        const poolSlot0 = uniswapV3Pool.decodeFunctionResult(slot0FuncString, slot0s[index].returnData);
        const poolLiquidity = uniswapV3Pool.decodeFunctionResult(liquidityFuncString, liquidities[index].returnData);
        const zeroPrice = poolSlot0.sqrtPriceX96.isZero();
        const zeroLiquidity = poolLiquidity[0].isZero();
        // If there is no price or no liquidity in the pool then we do not want to consider
        // it for swapping
        if (zeroPrice || zeroLiquidity) {
            return;
        }
        const validPool = new Pool(erc20ToUniswapToken(poolID.erc20Pair[0]), erc20ToUniswapToken(poolID.erc20Pair[1]), poolID.fee, poolSlot0.sqrtPriceX96.toString(), poolLiquidity.toString(), poolSlot0.tick);
        validPools.push(validPool);
    });
    return validPools;
};

class Router {
    provider;
    multicallContract;
    routingTokens;
    routingContracts;
    constructor(provider, multicallContract, routingTokens, routingContracts) {
        this.provider = provider;
        this.multicallContract = multicallContract;
        this.routingTokens = routingTokens;
        this.routingContracts = routingContracts;
        this.provider = provider;
        this.multicallContract = multicallContract;
        this.routingTokens = routingTokens;
        this.routingContracts = routingContracts;
    }
    async findOptimalRoute(amountSpecified, otherToken, tradeType, maxHops = 2) {
        const [tokenIn, tokenOut] = this.determineERC20InAndERC20Out(tradeType, amountSpecified, otherToken);
        const erc20Pair = [tokenIn, tokenOut];
        // Get all pools and use these to get all possible routes.
        const pools = await fetchValidPools(this.multicallContract, erc20Pair, this.routingTokens, this.routingContracts.coreFactory);
        const noValidPools = pools.length === 0;
        if (noValidPools) {
            throw new NoRoutesAvailableError();
        }
        // Get all the possible routes from the given pools
        // TODO: Fix used before defined error
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const routes = generateAllAcyclicPaths(tokenIn, tokenOut, pools, maxHops, [], [], tokenIn);
        const noValidRoute = routes.length === 0;
        if (noValidRoute) {
            throw new NoRoutesAvailableError();
        }
        // Get the best quote from all of the given routes
        return await this.getBestQuoteFromRoutes(routes, amountSpecified, tradeType);
    }
    async getBestQuoteFromRoutes(routes, amountSpecified, tradeType) {
        const quotes = await getQuotesForRoutes(this.provider, this.routingContracts.quoterV2, routes, amountSpecified, tradeType);
        if (quotes.length === 0) {
            throw new NoRoutesAvailableError();
        }
        // We want to maximise the amountOut for the EXACT_INPUT type
        if (tradeType === TradeType.EXACT_INPUT) {
            return this.bestQuoteForAmountIn(quotes);
        }
        // We want to minimise the amountIn for the EXACT_OUTPUT type
        if (tradeType === TradeType.EXACT_OUTPUT) {
            return this.bestQuoteForAmountOut(quotes);
        }
        throw new Error('Invalid trade type');
    }
    // eslint-disable-next-line class-methods-use-this
    bestQuoteForAmountIn(quotes) {
        let bestQuote = quotes[0];
        for (let i = 1; i < quotes.length; i++) {
            if (quotes[i].amountOut.value.gt(bestQuote.amountOut.value)) {
                bestQuote = quotes[i];
            }
        }
        return bestQuote;
    }
    // eslint-disable-next-line class-methods-use-this
    bestQuoteForAmountOut(quotes) {
        let bestQuote = quotes[0];
        for (let i = 1; i < quotes.length; i++) {
            if (quotes[i].amountIn.value.lt(bestQuote.amountIn.value)) {
                bestQuote = quotes[i];
            }
        }
        return bestQuote;
    }
    // eslint-disable-next-line class-methods-use-this
    determineERC20InAndERC20Out(tradeType, amountSpecified, otherToken) {
        // If the trade type is EXACT INPUT then we have specified the amount for the tokenIn
        return tradeType === TradeType.EXACT_INPUT
            ? [amountSpecified.token, otherToken]
            : [otherToken, amountSpecified.token];
    }
}
const generateAllAcyclicPaths = (tokenIn, // the currency we start with
tokenOut, // the currency we want to end up with
pools, // list of all available pools
maxHops, // the maximum number of pools that can be traversed
currentRoute = [], // list of pools already traversed
routes = [], // list of all routes found so far
startTokenIn = tokenIn) => {
    const currencyIn = erc20ToUniswapToken(tokenIn);
    const currencyOut = erc20ToUniswapToken(tokenOut);
    const startCurrencyIn = erc20ToUniswapToken(startTokenIn);
    for (const pool of pools) {
        // if the pool doesn't have the tokenIn or if it has already been traversed,
        // skip to the next pool
        const poolHasTokenIn = pool.involvesToken(currencyIn);
        const poolHasCycle = currentRoute.find((pathPool) => poolEquals(pool, pathPool));
        // eslint-disable-next-line no-continue
        if (!poolHasTokenIn || poolHasCycle)
            continue;
        // get the output token of the pool
        const outputToken = pool.token0.equals(currencyIn) ? pool.token1 : pool.token0;
        // if we have found a route to the target currency, add it to the list of routes
        const routeFound = outputToken.equals(currencyOut);
        if (routeFound) {
            routes.push(new Route([...currentRoute, pool], startCurrencyIn, currencyOut));
        }
        else if (maxHops > 1) {
            // otherwise, if we haven't exceeded the maximum number of pools that can be traversed,
            // recursively call this function with the output token as the new starting currency
            generateAllAcyclicPaths(uniswapTokenToERC20(outputToken), tokenOut, pools, maxHops - 1, [...currentRoute, pool], routes, startTokenIn);
        }
    }
    return routes;
};

const getFeeData = async (provider) => {
    const [block, maxPriorityFeePerGas] = await Promise.all([
        provider.getBlock('latest'),
        provider.send('eth_maxPriorityFeePerGas', []),
    ]);
    if (!block.baseFeePerGas)
        throw new Error('Base fee per gas not found in block');
    return {
        // https://www.blocknative.com/blog/eip-1559-fees
        maxFeePerGas: block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas),
        maxPriorityFeePerGas,
        lastBaseFeePerGas: block.baseFeePerGas,
    };
};
/**
 * Fetch the current gas price estimate. Supports both EIP-1559 and non-EIP1559 chains
 * @param {Provider} provider - The JSON RPC provider used to fetch fee data
 * @param {Native} nativeToken - The native token of the chain. Gas prices will be denominated in this token
 * @returns {CoinAmount<Native> | null} - The gas price in the smallest denomination of the chain's currency,
 *  or null if no gas price is available
 */
// eslint-disable-next-line max-len
const fetchGasPrice = async (provider, nativeToken) => {
    const feeData = await getFeeData(provider).catch(() => null);
    if (!feeData)
        return null;
    return newAmount(feeData.maxFeePerGas, nativeToken);
};
/**
 * Calculate the gas fee from the gas price and gas units used for the transaction
 *
 * @param {CoinAmount<Native>} gasPrice - The price of gas
 * @param {BigNumber} gasEstimate - The total gas units that will be used for the transaction
 * @returns - The cost of the transaction in the gas token's smallest denomination (e.g. WEI)
 */
const calculateGasFee = (gasPrice, gasEstimate) => 
// eslint-disable-next-line implicit-arrow-linebreak
newAmount(gasEstimate.mul(gasPrice.value), gasPrice.token);

/**
 * Check if the spender needs approval for the token
 *
 * @param provider - The provider to use for the call
 * @param ownerAddress - The address of the owner of the token
 * @param tokenAmount  - The amount of the token to approve
 * @param spenderAddress - The address of the spender
 * @returns - The amount of the token that needs to be approved
 */
const doesSpenderNeedApproval = async (provider, ownerAddress, tokenAmount, spenderAddress) => {
    // create an instance of the ERC20 token contract
    const erc20Contract = ERC20__factory.connect(tokenAmount.token.address, provider);
    // get the allowance for the token spender
    // the minimum allowance is 0 - no allowance
    let allowance;
    try {
        allowance = await erc20Contract.allowance(ownerAddress, spenderAddress);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ApproveError(`failed to get allowance: ${message}`);
    }
    // check if approval is needed
    const requiredAmount = tokenAmount.value.sub(allowance);
    if (requiredAmount.isNegative() || requiredAmount.isZero()) {
        return false;
    }
    return true;
};
/**
 * Get an unsigned ERC20 approve transaction
 *
 * @param ownerAddress - The address of the owner of the token
 * @param tokenAmount - The amount of the token to approve
 * @param spenderAddress - The address of the spender
 * @returns - The unsigned ERC20 approve transaction
 */
const getUnsignedERC20ApproveTransaction = (ownerAddress, tokenAmount, spenderAddress) => {
    if (ownerAddress === spenderAddress) {
        throw new ApproveError('owner and spender addresses are the same');
    }
    const erc20Contract = ERC20__factory.createInterface();
    const callData = erc20Contract.encodeFunctionData('approve', [spenderAddress, tokenAmount.value]);
    return {
        data: callData,
        to: tokenAmount.token.address,
        value: 0,
        from: ownerAddress,
    };
};
const prepareApproval = (tradeType, userSpecifiedAmount, quotedAmountWithSlippage, contracts, secondaryFees) => {
    const amountInToApprove = tradeType === TradeType.EXACT_INPUT ? userSpecifiedAmount : quotedAmountWithSlippage;
    if (!isERC20Amount(amountInToApprove)) {
        return null;
    }
    const spender = secondaryFees.length === 0 ? contracts.routerAddress : contracts.secondaryFeeAddress;
    return { spender, amount: amountInToApprove };
};
/**
 * Get an unsigned approval transaction if needed
 *
 * @param provider The provider to use for the call
 * @param ownerAddress The address of the owner of the token
 * @param tokenAddress The address of the token to approve
 * @param tokenAmount The amount of the token to approve
 * @param spenderAddress The address of the spender
 * @returns The unsigned ERC20 approve transaction, or null if no approval is needed
 */
const getApproveTransaction$1 = async (provider, ownerAddress, tokenAmount, spenderAddress) => {
    const needsApproval = await doesSpenderNeedApproval(provider, ownerAddress, tokenAmount, spenderAddress);
    // @dev approvals are not additive, so we need to approve the full amount
    return needsApproval ? getUnsignedERC20ApproveTransaction(ownerAddress, tokenAmount, spenderAddress) : null;
};
async function getApproveGasEstimate(provider, ownerAddress, spenderAddress, tokenAddress) {
    const erc20Contract = ERC20__factory.connect(tokenAddress, provider);
    return await erc20Contract.estimateGas.approve(spenderAddress, ethers.constants.MaxUint256, {
        from: ownerAddress,
    });
}
const getApproval = async (provider, ownerAddress, preparedApproval, gasPrice) => {
    const approveTransaction = await getApproveTransaction$1(provider, ownerAddress, preparedApproval.amount, preparedApproval.spender);
    if (!approveTransaction) {
        return null;
    }
    const gasEstimate = await getApproveGasEstimate(provider, ownerAddress, preparedApproval.spender, preparedApproval.amount.token.address);
    const gasFeeEstimate = gasPrice ? calculateGasFee(gasPrice, gasEstimate) : null;
    return {
        transaction: approveTransaction,
        gasFeeEstimate: gasFeeEstimate ? toPublicAmount(gasFeeEstimate) : null,
    };
};

const canUnwrapToken = (token) => token.type === 'native';
class NativeTokenService {
    nativeToken;
    wrappedToken;
    constructor(nativeToken, wrappedToken) {
        this.nativeToken = nativeToken;
        this.wrappedToken = wrappedToken;
    }
    wrapAmount(amount) {
        return newAmount(amount.value, this.wrappedToken);
    }
    unwrapAmount(amount) {
        const isWrappedToken = amount.token.address.toLowerCase() !== this.wrappedToken.address.toLowerCase();
        if (isWrappedToken) {
            throw new Error(`cannot unwrap non-wrapped token ${amount.token.address}`);
        }
        return newAmount(amount.value, this.nativeToken);
    }
    maybeWrapToken(token) {
        if (canUnwrapToken(token)) {
            return this.wrappedToken;
        }
        return token;
    }
    maybeWrapAmount(amount) {
        return newAmount(amount.value, this.maybeWrapToken(amount.token));
    }
}

// slippageToPercent takes the slippage as a percentage (e.g. 0.1) and
// converts it to the Uniswap equivalent type
const slippageToFraction = (slippage) => {
    // If we receive a whole number, we can return slippage/100
    const noDecimals = slippage.toString().split('.').length === 1;
    if (noDecimals) {
        return new Percent(slippage, 100);
    }
    // Divide the slippage number by 100 to get the decimal
    const slippageDecimal = slippage / 100;
    // Split into two parts by the decimal place
    const parts = slippageDecimal.toString().split('.');
    // Get the numerator by adding the two parts together
    const numerator = parts[0] + parts[1];
    // Get the denominator by multiplying decimals^10
    const denominator = 10 ** parts[1].length;
    return new Percent(numerator, denominator);
};

function getQuoteAmountFromTradeType(routerQuote) {
    if (routerQuote.tradeType === TradeType.EXACT_INPUT) {
        return routerQuote.amountOut;
    }
    return routerQuote.amountIn;
}
function applySlippage(tradeType, amount, slippage) {
    const slippageTolerance = slippageToFraction(slippage);
    const slippagePlusOne = slippageTolerance.add(1);
    const maybeInverted = tradeType === TradeType.EXACT_INPUT ? slippagePlusOne.invert() : slippagePlusOne;
    const amountWithSlippage = maybeInverted.multiply(amount.toString()).quotient;
    return ethers.BigNumber.from(amountWithSlippage.toString());
}
const prepareUserQuote = (nativeTokenService, routerQuote, slippage, tokenOfQuotedAmount) => {
    const erc20QuoteAmount = getQuoteAmountFromTradeType(routerQuote);
    // If the quote amount is the native token, we need to unwrap it if the user originally specified the native token
    const quotedAmount = canUnwrapToken(tokenOfQuotedAmount)
        ? nativeTokenService.unwrapAmount(erc20QuoteAmount)
        : erc20QuoteAmount;
    const quotedAmountWithMaxSlippage = newAmount(applySlippage(routerQuote.tradeType, quotedAmount.value, slippage), tokenOfQuotedAmount);
    return {
        quotedAmount,
        quotedAmountWithMaxSlippage,
    };
};
function getOurQuoteReqAmount(amountSpecified, // the amount specified by the user, either exactIn or exactOut
fees, tradeType, nativeTokenService) {
    if (tradeType === TradeType.EXACT_OUTPUT) {
        // For an exact output swap, we do not need to subtract fees from the given amount
        return nativeTokenService.maybeWrapAmount(amountSpecified);
    }
    fees.addAmount(amountSpecified);
    return nativeTokenService.maybeWrapAmount(fees.amountLessFees());
}

class Fees {
    secondaryFees;
    amount;
    constructor(secondaryFees, token) {
        this.secondaryFees = secondaryFees;
        this.amount = newAmount(BigNumber$1.from(0), token);
    }
    get token() {
        return this.amount.token;
    }
    addAmount(amount) {
        this.amount = addAmount(this.amount, amount);
    }
    amountWithFeesApplied() {
        return addAmount(this.amount, this.total());
    }
    amountLessFees() {
        return subtractAmount(this.amount, this.total());
    }
    withAmounts() {
        return this.secondaryFees.map((fee) => {
            const feeAmount = this.amount.value
                .mul(fee.basisPoints)
                .div(BASIS_POINT_PRECISION);
            return {
                ...fee,
                amount: newAmount(feeAmount, this.amount.token),
            };
        });
    }
    total() {
        let totalFees = newAmount(BigNumber$1.from(0), this.amount.token);
        for (const fee of this.secondaryFees) {
            const feeAmount = this.amount.value
                .mul(fee.basisPoints)
                .div(BASIS_POINT_PRECISION);
            totalFees = addAmount(totalFees, newAmount(feeAmount, this.amount.token));
        }
        return totalFees;
    }
}

const IMMUTABLE_TESTNET_RPC_URL = 'https://rpc.testnet.immutable.com';
const IMMUTABLE_TESTNET_CHAIN_ID = 13473;

const NATIVE_IMX_IMMUTABLE_TESTNET = {
    chainId: IMMUTABLE_TESTNET_CHAIN_ID,
    decimals: 18,
    symbol: 'tIMX',
    name: 'Immutable Testnet Token',
    type: 'native',
};
const WIMX_IMMUTABLE_TESTNET = {
    chainId: IMMUTABLE_TESTNET_CHAIN_ID,
    address: '0x1CcCa691501174B4A623CeDA58cC8f1a76dc3439',
    decimals: 18,
    symbol: 'WIMX',
    name: 'Wrapped Immutable Testnet Token',
    type: 'erc20',
};
const IMMUTABLE_TESTNET_COMMON_ROUTING_TOKENS = [
    WIMX_IMMUTABLE_TESTNET,
];

const zeroNativeCurrencyValue = '0x00';
const multicallWithDeadlineFunctionSignature = 'multicall(uint256,bytes[])';
function buildSinglePoolSwap(tokenIn, tokenOut, recipient, trade, route, amountIn, amountOut, routerContract, paymentsContract) {
    const calldatas = [];
    if (trade.tradeType === Uniswap.TradeType.EXACT_INPUT) {
        calldatas.push(routerContract.encodeFunctionData('exactInputSingle', [
            {
                tokenIn: route.tokenPath[0].address,
                tokenOut: route.tokenPath[1].address,
                fee: route.pools[0].fee,
                recipient,
                amountIn,
                amountOutMinimum: amountOut,
                sqrtPriceLimitX96: 0,
            },
        ]));
    }
    if (trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT) {
        calldatas.push(routerContract.encodeFunctionData('exactOutputSingle', [
            {
                tokenIn: route.tokenPath[0].address,
                tokenOut: route.tokenPath[1].address,
                fee: route.pools[0].fee,
                recipient,
                amountInMaximum: amountIn,
                amountOut,
                sqrtPriceLimitX96: 0,
            },
        ]));
    }
    const shouldRefundNativeTokens = isNative(tokenIn);
    if (shouldRefundNativeTokens) {
        // Refund ETH if the input token is native.
        // In some cases, the user may have specified an input amount that is greater than what
        // the liqudiity of the pool can provide.
        // To account for this case, always call `refundETH` to refund any excess native tokens.
        calldatas.push(paymentsContract.encodeFunctionData('refundETH'));
    }
    const shouldUnwrapTokens = isNative(tokenOut);
    if (shouldUnwrapTokens) {
        // Unwrap the output token if the user specified a native token as the output
        calldatas.push(paymentsContract.encodeFunctionData('unwrapWETH9(uint256)', [amountOut]));
    }
    return calldatas;
}
function buildSinglePoolSwapWithFees(recipient, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract, tokenOut) {
    const secondaryFeeValues = secondaryFees.map((fee) => ({
        feeBasisPoints: fee.basisPoints,
        recipient: fee.recipient,
    }));
    const calldatas = [];
    if (trade.tradeType === Uniswap.TradeType.EXACT_INPUT) {
        calldatas.push(secondaryFeeContract.encodeFunctionData('exactInputSingleWithSecondaryFee', [
            secondaryFeeValues,
            {
                tokenIn: route.tokenPath[0].address,
                tokenOut: route.tokenPath[1].address,
                fee: route.pools[0].fee,
                recipient,
                amountIn,
                amountOutMinimum: amountOut,
                sqrtPriceLimitX96: 0,
            },
        ]));
    }
    if (trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT) {
        calldatas.push(secondaryFeeContract.encodeFunctionData('exactOutputSingleWithSecondaryFee', [
            secondaryFeeValues,
            {
                tokenIn: route.tokenPath[0].address,
                tokenOut: route.tokenPath[1].address,
                fee: route.pools[0].fee,
                recipient,
                amountInMaximum: amountIn,
                amountOut,
                sqrtPriceLimitX96: 0,
            },
        ]));
    }
    const shouldUnwrapTokens = isNative(tokenOut);
    if (shouldUnwrapTokens) {
        // Unwrap the output token if the user specified a native token as the output
        calldatas.push(secondaryFeeContract.encodeFunctionData('unwrapNativeToken', [amountOut]));
    }
    return calldatas;
}
function buildMultiPoolSwap(tokenIn, tokenOut, recipient, trade, route, amountIn, amountOut, routerContract, paymentsContract) {
    const path = encodeRouteToPath(route, trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT);
    const calldatas = [];
    if (trade.tradeType === Uniswap.TradeType.EXACT_INPUT) {
        calldatas.push(routerContract.encodeFunctionData('exactInput', [
            {
                path,
                recipient,
                amountIn,
                amountOutMinimum: amountOut,
            },
        ]));
    }
    if (trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT) {
        calldatas.push(routerContract.encodeFunctionData('exactOutput', [
            {
                path,
                recipient,
                amountInMaximum: amountIn,
                amountOut,
            },
        ]));
    }
    const shouldRefundNativeTokens = isNative(tokenIn);
    if (shouldRefundNativeTokens) {
        // Refund ETH if the input token is native.
        // In some cases, the user may have specified an input amount that is greater than what
        // the liqudiity of the pool can provide.
        // To account for this case, always call `refundETH` to refund any excess native tokens.
        calldatas.push(paymentsContract.encodeFunctionData('refundETH'));
    }
    const shouldUnwrapTokens = isNative(tokenOut);
    if (shouldUnwrapTokens) {
        // Unwrap the output token if the user specified a native token as the output
        calldatas.push(paymentsContract.encodeFunctionData('unwrapWETH9(uint256)', [amountOut]));
    }
    return calldatas;
}
function buildMultiPoolSwapWithFees(recipient, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract, tokenOut) {
    const path = encodeRouteToPath(route, trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT);
    const secondaryFeeValues = secondaryFees.map((fee) => ({
        feeBasisPoints: fee.basisPoints,
        recipient: fee.recipient,
    }));
    const calldatas = [];
    if (trade.tradeType === Uniswap.TradeType.EXACT_INPUT) {
        calldatas.push(secondaryFeeContract.encodeFunctionData('exactInputWithSecondaryFee', [
            secondaryFeeValues,
            {
                path,
                recipient,
                amountIn,
                amountOutMinimum: amountOut,
            },
        ]));
    }
    if (trade.tradeType === Uniswap.TradeType.EXACT_OUTPUT) {
        calldatas.push(secondaryFeeContract.encodeFunctionData('exactOutputWithSecondaryFee', [
            secondaryFeeValues,
            {
                path,
                recipient,
                amountInMaximum: amountIn,
                amountOut,
            },
        ]));
    }
    const shouldUnwrapTokens = isNative(tokenOut);
    if (shouldUnwrapTokens) {
        // Unwrap the output token if the user specified a native token as the output
        calldatas.push(secondaryFeeContract.encodeFunctionData('unwrapNativeToken', [amountOut]));
    }
    return calldatas;
}
/**
 * Builds and array of calldatas for the swap to be executed in the multicall method
 * @param tokenIn The token to be swapped
 * @param tokenOut The token to be received
 * @param fromAddress The address of the user
 * @param trade The trade to be executed
 * @param secondaryFees Secondary fees to be applied to the swap
 * @param secondaryFeeContract The SecondaryFee contract interface
 * @param routerContract The SwapRouter02 contract interface
 * @param paymentsContract The PaymentsExtended contract interface
 * @param maximumAmountIn The maximum amount of tokenIn to be swapped
 * @param minimumAmountOut The minimum amount of tokenOut to be received
 * @returns calldatas that make up the swap transaction
 */
function buildSwapParameters(tokenIn, tokenOut, recipient, trade, secondaryFees, secondaryFeeContract, routerContract, paymentsContract, maximumAmountIn, minimumAmountOut) {
    // @dev we don't support multiple swaps in a single transaction
    // there will always be only one swap in the trade regardless of the trade type
    const { route } = trade.swaps[0];
    const isSinglePoolSwap = route.pools.length === 1;
    const hasSecondaryFees = secondaryFees.length > 0;
    if (isSinglePoolSwap) {
        if (hasSecondaryFees) {
            return buildSinglePoolSwapWithFees(recipient, trade, route, maximumAmountIn, minimumAmountOut, secondaryFees, secondaryFeeContract, tokenOut);
        }
        return buildSinglePoolSwap(tokenIn, tokenOut, recipient, trade, route, maximumAmountIn, minimumAmountOut, routerContract, paymentsContract);
    }
    if (hasSecondaryFees) {
        return buildMultiPoolSwapWithFees(recipient, trade, route, maximumAmountIn, minimumAmountOut, secondaryFees, secondaryFeeContract, tokenOut);
    }
    return buildMultiPoolSwap(tokenIn, tokenOut, recipient, trade, route, maximumAmountIn, minimumAmountOut, routerContract, paymentsContract);
}
function createSwapCallParameters(tokenIn, tokenOut, trade, recipient, swapOptions, secondaryFees, maximumAmountIn, minimumAmountOut) {
    const secondaryFeeContract = SecondaryFee__factory.createInterface();
    const routerContract = SwapRouter.INTERFACE;
    const paymentsContract = PaymentsExtended.INTERFACE;
    const calldatas = buildSwapParameters(tokenIn, tokenOut, recipient, trade, secondaryFees, secondaryFeeContract, routerContract, paymentsContract, maximumAmountIn, minimumAmountOut);
    // Create the multicall transaction using the calldatas generated above
    return secondaryFeeContract.encodeFunctionData(multicallWithDeadlineFunctionSignature, [
        swapOptions.deadlineOrPreviousBlockhash,
        calldatas,
    ]);
}
function createSwapParameters(tokenIn, tokenOut, adjustedQuote, fromAddress, slippage, deadline, secondaryFees) {
    // Create an unchecked trade to be used in generating swap parameters.
    const uncheckedTrade = Trade.createUncheckedTrade({
        route: adjustedQuote.route,
        inputAmount: toCurrencyAmount(adjustedQuote.amountIn),
        outputAmount: toCurrencyAmount(adjustedQuote.amountOut),
        tradeType: adjustedQuote.tradeType,
    });
    const slippageTolerance = slippageToFraction(slippage);
    const options = {
        slippageTolerance,
        recipient: fromAddress,
        deadlineOrPreviousBlockhash: deadline,
    };
    // If the trade type is EXACT_INPUT, then the maximum amount-in is the user-specified amount (no slippage applied)
    // For EXACT_OUTPUT, the maximum amount-in is the amount-in with slippage applied
    // https://github.com/Uniswap/v3-sdk/blob/81d66099f07d1ec350767f497ef73222575fe032/src/entities/trade.ts#L456
    const maximumAmountIn = toHex$1(uncheckedTrade.maximumAmountIn(options.slippageTolerance).quotient);
    const minimumAmountOut = toHex$1(uncheckedTrade.minimumAmountOut(options.slippageTolerance).quotient);
    return {
        calldata: createSwapCallParameters(tokenIn, tokenOut, uncheckedTrade, fromAddress, options, secondaryFees, maximumAmountIn, minimumAmountOut),
        maximumAmountIn,
    };
}
const getTransactionValue = (tokenIn, maximumAmountIn) => tokenIn.type === 'native' ? maximumAmountIn : zeroNativeCurrencyValue;
const getSwapRecipient = (tokenOut, fromAddress, routerContractAddress, secondaryFeesContractAddress, secondaryFees) => {
    // Not native so send the tokens directly back to the caller.
    if (!isNative(tokenOut))
        return fromAddress;
    // Native but no fees, send to the Uniswap Router
    if (secondaryFees.length === 0)
        return routerContractAddress;
    // Native and fees, send to the secondary fee contract
    return secondaryFeesContractAddress;
};
function getSwap(tokenIn, tokenOut, adjustedQuote, fromAddress, slippage, deadline, routerContractAddress, secondaryFeesContractAddress, gasPrice, secondaryFees) {
    const swapRecipient = getSwapRecipient(tokenOut, fromAddress, routerContractAddress, secondaryFeesContractAddress, secondaryFees);
    const { calldata, maximumAmountIn } = createSwapParameters(tokenIn, tokenOut, adjustedQuote, swapRecipient, slippage, deadline, secondaryFees);
    // TODO: Add additional gas fee estimates for secondary fees
    const gasFeeEstimate = gasPrice ? calculateGasFee(gasPrice, adjustedQuote.gasEstimate) : null;
    const transactionValue = getTransactionValue(tokenIn, maximumAmountIn);
    return {
        transaction: {
            data: calldata,
            to: secondaryFees.length > 0 ? secondaryFeesContractAddress : routerContractAddress,
            value: transactionValue,
            from: fromAddress,
        },
        gasFeeEstimate: gasFeeEstimate ? toPublicAmount(gasFeeEstimate) : null,
    };
}
const adjustAmountIn = (ourQuote, amountSpecified, fees, nativeTokenService) => {
    if (ourQuote.tradeType === Uniswap.TradeType.EXACT_OUTPUT) {
        // when doing exact output, calculate the fees based on the amountIn
        const amountToAdd = canUnwrapToken(fees.token)
            ? nativeTokenService.unwrapAmount(ourQuote.amountIn)
            : ourQuote.amountIn;
        fees.addAmount(amountToAdd);
        return nativeTokenService.maybeWrapAmount(fees.amountWithFeesApplied());
    }
    return nativeTokenService.maybeWrapAmount(amountSpecified);
};
/**
 * adjustQuoteWithFees adjusts the amountIn of the quote to account for fees
 * EXACT_OUTPUT swaps will have the fees added to the amountIn if there are fees specified
 * EXACT_INPUT swaps will have amountIn set to the user-specified amount
 * @param ourQuote The quote from calling the Quoter contract
 * @param amountSpecified The user-specified amount for the swap (EXACT...)
 * @param fees The fees applied to the swap
 * @param tokenWrapper Helper class for the native token and associated ERC20
 * @returns {QuoteResult} The adjusted quote
 */
function adjustQuoteWithFees(ourQuote, amountSpecified, fees, nativeTokenService) {
    const adjustedAmountIn = adjustAmountIn(ourQuote, amountSpecified, fees, nativeTokenService);
    return {
        gasEstimate: ourQuote.gasEstimate,
        route: ourQuote.route,
        amountIn: adjustedAmountIn,
        amountOut: ourQuote.amountOut,
        tradeType: ourQuote.tradeType,
    };
}

const CONTRACTS_FOR_CHAIN_ID = {
    [IMMUTABLE_TESTNET_CHAIN_ID]: {
        multicall: '0x4DB567A44451b27C1fAd7f52e1cDf64b915d62f9',
        coreFactory: '0xb18c44b211065E69844FbA9AE146DA362104AfBf',
        quoterV2: '0x87854A7D4b9BaC3D37f4516A1Ac7F36fB5ad539f',
        peripheryRouter: '0x786ec643F231960D4C1A4E336990F8E7bF8f1277',
        secondaryFee: '0xCe11A21e7b6B4650C3B6363446fa1aa486A5146A',
    },
};
const SUPPORTED_SANDBOX_CHAINS = {
    [IMMUTABLE_TESTNET_CHAIN_ID]: {
        chainId: IMMUTABLE_TESTNET_CHAIN_ID,
        rpcUrl: IMMUTABLE_TESTNET_RPC_URL,
        contracts: CONTRACTS_FOR_CHAIN_ID[IMMUTABLE_TESTNET_CHAIN_ID],
        commonRoutingTokens: IMMUTABLE_TESTNET_COMMON_ROUTING_TOKENS,
        nativeToken: NATIVE_IMX_IMMUTABLE_TESTNET,
        wrappedNativeToken: WIMX_IMMUTABLE_TESTNET,
    },
};
const SUPPORTED_PRODUCTION_CHAINS = {};
const SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT = {
    [Environment$1.SANDBOX]: SUPPORTED_SANDBOX_CHAINS,
    [Environment$1.PRODUCTION]: SUPPORTED_PRODUCTION_CHAINS,
};
function validateOverrides(overrides) {
    const keysToCheck = ['rpcURL', 'exchangeContracts', 'commonRoutingTokens', 'nativeToken'];
    for (const key of keysToCheck) {
        if (!overrides[key]) {
            throw new InvalidConfigurationError(`Missing override: ${key}`);
        }
    }
    Object.entries(overrides.exchangeContracts).forEach(([key, contract]) => {
        if (!isValidNonZeroAddress(contract)) {
            throw new InvalidConfigurationError(`Invalid exchange contract address for ${key}`);
        }
    });
}
function validateSecondaryFees(secondaryFees) {
    let totalSecondaryFeeBasisPoints = 0;
    for (const secondaryFee of secondaryFees) {
        if (!isValidNonZeroAddress(secondaryFee.recipient)) {
            throw new InvalidConfigurationError(`Invalid secondary fee recipient address: ${secondaryFee.recipient}`);
        }
        if (secondaryFee.basisPoints <= 0 || secondaryFee.basisPoints > MAX_SECONDARY_FEE_BASIS_POINTS) {
            throw new InvalidConfigurationError(`Invalid secondary fee basis points: ${secondaryFee.basisPoints}`);
        }
        totalSecondaryFeeBasisPoints += secondaryFee.basisPoints;
    }
    if (totalSecondaryFeeBasisPoints > MAX_SECONDARY_FEE_BASIS_POINTS) {
        throw new InvalidConfigurationError(`Invalid total secondary fee basis points: ${totalSecondaryFeeBasisPoints}`);
    }
}
/**
 * {@link ExchangeConfiguration} is used to configure the {@link Exchange} class.
 * @param chainId the ID of the chain to configure. {@link SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT} contains the supported chains for each environment.
 * @param baseConfig the base {@link ImmutableConfiguration} for the {@link Exchange} class
 * @param secondaryFees an optional array of {@link SecondaryFee}s to apply to all transactions. Total secondary fees must be less than {@link MAX_SECONDARY_FEE_BASIS_POINTS}.
 */
class ExchangeConfiguration {
    baseConfig;
    chain;
    secondaryFees = [];
    constructor({ chainId, baseConfig, secondaryFees, overrides }) {
        this.baseConfig = baseConfig;
        this.secondaryFees = secondaryFees || [];
        validateSecondaryFees(this.secondaryFees);
        if (overrides) {
            validateOverrides(overrides);
            this.chain = {
                chainId,
                rpcUrl: overrides.rpcURL,
                contracts: overrides.exchangeContracts,
                commonRoutingTokens: overrides.commonRoutingTokens,
                nativeToken: overrides.nativeToken,
                wrappedNativeToken: overrides.wrappedNativeToken,
            };
            this.secondaryFees = secondaryFees || [];
            return;
        }
        const chain = SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT[baseConfig.environment][chainId];
        if (!chain) {
            throw new ChainNotSupportedError(chainId, baseConfig.environment);
        }
        this.chain = chain;
    }
}

const toPublicQuote = (amount, amountWithMaxSlippage, slippage, fees) => ({
    amount: toPublicAmount(amount),
    amountWithMaxSlippage: toPublicAmount(amountWithMaxSlippage),
    slippage,
    fees: fees.withAmounts().map((fee) => ({
        ...fee,
        amount: toPublicAmount(fee.amount),
    })),
});
class Exchange {
    provider;
    batchProvider;
    router;
    chainId;
    nativeToken;
    wrappedNativeToken;
    secondaryFees;
    nativeTokenService;
    secondaryFeeContractAddress;
    routerContractAddress;
    constructor(configuration) {
        const config = new ExchangeConfiguration(configuration);
        this.chainId = config.chain.chainId;
        this.nativeToken = config.chain.nativeToken;
        this.wrappedNativeToken = config.chain.wrappedNativeToken;
        this.nativeTokenService = new NativeTokenService(this.nativeToken, this.wrappedNativeToken);
        this.secondaryFees = config.secondaryFees;
        this.routerContractAddress = config.chain.contracts.peripheryRouter;
        this.secondaryFeeContractAddress = config.chain.contracts.secondaryFee;
        this.provider = new ethers.providers.StaticJsonRpcProvider({
            url: config.chain.rpcUrl,
            skipFetchSetup: true,
        }, config.chain.chainId);
        this.batchProvider = new ethers.providers.JsonRpcBatchProvider({
            url: config.chain.rpcUrl,
            skipFetchSetup: true,
        }, config.chain.chainId);
        const multicallContract = Multicall__factory.connect(config.chain.contracts.multicall, this.provider);
        this.router = new Router(this.batchProvider, multicallContract, config.chain.commonRoutingTokens, config.chain.contracts);
    }
    static validate(tokenInAddress, tokenOutAddress, maxHops, slippagePercent, fromAddress) {
        assert(isValidNonZeroAddress(fromAddress), new InvalidAddressError('invalid from address'));
        assert(isValidTokenLiteral(tokenInAddress), new InvalidAddressError('invalid token in address'));
        assert(isValidTokenLiteral(tokenOutAddress), new InvalidAddressError('invalid token out address'));
        assert(tokenInAddress.toLocaleLowerCase() !== tokenOutAddress.toLocaleLowerCase(), new DuplicateAddressesError());
        assert(maxHops <= MAX_MAX_HOPS, new InvalidMaxHopsError('max hops must be less than or equal to 10'));
        assert(maxHops >= MIN_MAX_HOPS, new InvalidMaxHopsError('max hops must be greater than or equal to 1'));
        assert(slippagePercent <= 50, new InvalidSlippageError('slippage percent must be less than or equal to 50'));
        assert(slippagePercent >= 0, new InvalidSlippageError('slippage percent must be greater than or equal to 0'));
    }
    async getSecondaryFees(provider) {
        if (this.secondaryFees.length === 0) {
            return [];
        }
        const secondaryFeeContract = SecondaryFee__factory.connect(this.secondaryFeeContractAddress, provider);
        if (await secondaryFeeContract.paused()) {
            // Do not use secondary fees if the contract is paused
            return [];
        }
        return this.secondaryFees;
    }
    parseTokenLiteral(tokenLiteral, decimals) {
        if (tokenLiteral === 'native') {
            return this.nativeToken;
        }
        return {
            type: 'erc20',
            address: tokenLiteral,
            chainId: this.chainId,
            decimals,
        };
    }
    async getUnsignedSwapTx(fromAddress, tokenInLiteral, tokenOutLiteral, amount, slippagePercent, maxHops, deadline, tradeType) {
        Exchange.validate(tokenInLiteral, tokenOutLiteral, maxHops, slippagePercent, fromAddress);
        // get the decimals of the tokens that will be swapped
        const promises = [
            getTokenDecimals(tokenInLiteral, this.batchProvider, this.nativeToken),
            getTokenDecimals(tokenOutLiteral, this.batchProvider, this.nativeToken),
            this.getSecondaryFees(this.batchProvider),
            fetchGasPrice(this.batchProvider, this.nativeToken),
        ];
        const [tokenInDecimals, tokenOutDecimals, secondaryFees, gasPrice] = await Promise.all(promises);
        const tokenIn = this.parseTokenLiteral(tokenInLiteral, tokenInDecimals);
        const tokenOut = this.parseTokenLiteral(tokenOutLiteral, tokenOutDecimals);
        // determine which amount was specified for the swap from the TradeType
        const [tokenSpecified, otherToken] = tradeType === TradeType.EXACT_INPUT ? [tokenIn, tokenOut] : [tokenOut, tokenIn];
        const amountSpecified = newAmount(amount, tokenSpecified);
        const fees = new Fees(secondaryFees, tokenIn);
        const ourQuoteReqAmount = getOurQuoteReqAmount(amountSpecified, fees, tradeType, this.nativeTokenService);
        // Quotes will always use ERC20s. If the user-specified token is Native, we use the Wrapped Native Token pool
        const ourQuote = await this.router.findOptimalRoute(ourQuoteReqAmount, this.nativeTokenService.maybeWrapToken(otherToken), tradeType, maxHops);
        const adjustedQuote = adjustQuoteWithFees(ourQuote, amountSpecified, fees, this.nativeTokenService);
        const swap = getSwap(tokenIn, tokenOut, adjustedQuote, fromAddress, slippagePercent, deadline, this.routerContractAddress, this.secondaryFeeContractAddress, gasPrice, secondaryFees);
        const { quotedAmount, quotedAmountWithMaxSlippage } = prepareUserQuote(this.nativeTokenService, adjustedQuote, slippagePercent, otherToken);
        const preparedApproval = prepareApproval(tradeType, amountSpecified, quotedAmountWithMaxSlippage, {
            routerAddress: this.routerContractAddress,
            secondaryFeeAddress: this.secondaryFeeContractAddress,
        }, secondaryFees);
        // preparedApproval always uses the tokenIn address because we are always selling the tokenIn
        const approval = preparedApproval
            ? await getApproval(this.provider, fromAddress, preparedApproval, gasPrice)
            : null;
        const quote = toPublicQuote(quotedAmount, quotedAmountWithMaxSlippage, slippagePercent, fees);
        return { quote, approval, swap };
    }
    /**
     * Get the unsigned swap transaction given the amount to sell.
     * Includes quote details for the swap.
     *
     * @param {string} fromAddress The public address that will sign and submit the transaction
     * @param {string} tokenInAddress Token address or 'native' to sell
     * @param {string} tokenOutAddress Token address or 'native' to buy
     * @param {ethers.BigNumberish} amountIn Amount to sell in the smallest unit of the token-in
     * @param {number} slippagePercent (optional) The percentage of slippage tolerance. Default = 0.1. Max = 50. Min = 0
     * @param {number} maxHops (optional) Maximum hops allowed in optimal route. Default is 2
     * @param {number} deadline (optional) Latest time swap can execute. Default is 15 minutes
     * @return {TransactionResponse} The result containing the unsigned transaction and details of the swap
     */
    async getUnsignedSwapTxFromAmountIn(fromAddress, tokenInAddress, tokenOutAddress, amountIn, slippagePercent = DEFAULT_SLIPPAGE, maxHops = DEFAULT_MAX_HOPS, deadline = getDefaultDeadlineSeconds()) {
        return await this.getUnsignedSwapTx(fromAddress, tokenInAddress, tokenOutAddress, ethers.BigNumber.from(amountIn), slippagePercent, maxHops, deadline, TradeType.EXACT_INPUT);
    }
    /**
     * Get the unsigned swap transaction given the amount to buy.
     * Includes quote details for the swap.
     *
     * @param {string} fromAddress The public address that will sign and submit the transaction
     * @param {string} tokenInAddress ERC20 contract address or 'native' to sell
     * @param {string} tokenOutAddress ERC20 contract address or 'native' to buy
     * @param {ethers.BigNumberish} amountOut Amount to buy in the smallest unit of the token-out
     * @param {number} slippagePercent (optional) The percentage of slippage tolerance. Default = 0.1. Max = 50. Min = 0
     * @param {number} maxHops (optional) Maximum hops allowed in optimal route. Default is 2
     * @param {number} deadline (optional) Latest time swap can execute. Default is 15 minutes
     * @return {TransactionResponse} The result containing the unsigned transaction and details of the swap
     */
    async getUnsignedSwapTxFromAmountOut(fromAddress, tokenInAddress, tokenOutAddress, amountOut, slippagePercent = DEFAULT_SLIPPAGE, maxHops = DEFAULT_MAX_HOPS, deadline = getDefaultDeadlineSeconds()) {
        return await this.getUnsignedSwapTx(fromAddress, tokenInAddress, tokenOutAddress, ethers.BigNumber.from(amountOut), slippagePercent, maxHops, deadline, TradeType.EXACT_OUTPUT);
    }
}

/**
 * Enum representing the events emitted by the widgets.
 */
var IMTBLWidgetEvents;
(function (IMTBLWidgetEvents) {
    IMTBLWidgetEvents["IMTBL_WIDGETS_PROVIDER"] = "imtbl-widgets-provider";
    IMTBLWidgetEvents["IMTBL_CONNECT_WIDGET_EVENT"] = "imtbl-connect-widget";
    IMTBLWidgetEvents["IMTBL_WALLET_WIDGET_EVENT"] = "imtbl-wallet-widget";
    IMTBLWidgetEvents["IMTBL_SWAP_WIDGET_EVENT"] = "imtbl-swap-widget";
    IMTBLWidgetEvents["IMTBL_BRIDGE_WIDGET_EVENT"] = "imtbl-bridge-widget";
    IMTBLWidgetEvents["IMTBL_ONRAMP_WIDGET_EVENT"] = "imtbl-onramp-widget";
    IMTBLWidgetEvents["IMTBL_SALE_WIDGET_EVENT"] = "imtbl-sale-widget";
})(IMTBLWidgetEvents || (IMTBLWidgetEvents = {}));
/**
 * Enum for events raised for about provider objects
 */
var ProviderEventType;
(function (ProviderEventType) {
    ProviderEventType["PROVIDER_UPDATED"] = "PROVIDER_UPDATED";
})(ProviderEventType || (ProviderEventType = {}));

/**
 * Enum representing possible Connect Widget event types.
 */
var ConnectEventType;
(function (ConnectEventType) {
    ConnectEventType["CLOSE_WIDGET"] = "close-widget";
    ConnectEventType["SUCCESS"] = "success";
    ConnectEventType["FAILURE"] = "failure";
})(ConnectEventType || (ConnectEventType = {}));

/**
 * Enum representing possible Wallet Widget event types.
 */
var WalletEventType;
(function (WalletEventType) {
    WalletEventType["CLOSE_WIDGET"] = "close-widget";
    WalletEventType["NETWORK_SWITCH"] = "network-switch";
    WalletEventType["DISCONNECT_WALLET"] = "disconnect-wallet";
})(WalletEventType || (WalletEventType = {}));

/**
 * Enum representing possible Swap Widget event types.
 */
var SwapEventType;
(function (SwapEventType) {
    SwapEventType["CLOSE_WIDGET"] = "close-widget";
    SwapEventType["SUCCESS"] = "success";
    SwapEventType["FAILURE"] = "failure";
    SwapEventType["REJECTED"] = "rejected";
})(SwapEventType || (SwapEventType = {}));

/**
 * Enum representing possible Sale Widget event types.
 */
var SaleEventType;
(function (SaleEventType) {
    SaleEventType["CLOSE_WIDGET"] = "close-widget";
    SaleEventType["SUCCESS"] = "success";
    SaleEventType["FAILURE"] = "failure";
    SaleEventType["REJECTED"] = "rejected";
    SaleEventType["TRANSACTION_SUCCESS"] = "transaction-success";
})(SaleEventType || (SaleEventType = {}));

/**
 * Enum of possible Bridge Widget event types.
 */
var BridgeEventType;
(function (BridgeEventType) {
    BridgeEventType["CLOSE_WIDGET"] = "close-widget";
    BridgeEventType["SUCCESS"] = "success";
    BridgeEventType["FAILURE"] = "failure";
})(BridgeEventType || (BridgeEventType = {}));

/**
 * Enum representing different types of orchestration events.
 */
var OrchestrationEventType;
(function (OrchestrationEventType) {
    OrchestrationEventType["REQUEST_CONNECT"] = "request-connect";
    OrchestrationEventType["REQUEST_WALLET"] = "request-wallet";
    OrchestrationEventType["REQUEST_SWAP"] = "request-swap";
    OrchestrationEventType["REQUEST_BRIDGE"] = "request-bridge";
    OrchestrationEventType["REQUEST_ONRAMP"] = "request-onramp";
})(OrchestrationEventType || (OrchestrationEventType = {}));

/**
 * Enum of possible OnRamp Widget event types.
 */
var OnRampEventType;
(function (OnRampEventType) {
    OnRampEventType["CLOSE_WIDGET"] = "close-widget";
    OnRampEventType["SUCCESS"] = "success";
    OnRampEventType["FAILURE"] = "failure";
})(OnRampEventType || (OnRampEventType = {}));

/**
 * Enum representing the list of widget types.
 */
var WidgetType;
(function (WidgetType) {
    WidgetType["CONNECT"] = "connect";
    WidgetType["WALLET"] = "wallet";
    WidgetType["SWAP"] = "swap";
    WidgetType["BRIDGE"] = "bridge";
    WidgetType["ONRAMP"] = "onramp";
    WidgetType["SALE"] = "sale";
})(WidgetType || (WidgetType = {}));

var ConnectTargetLayer;
(function (ConnectTargetLayer) {
    ConnectTargetLayer["LAYER1"] = "LAYER1";
    ConnectTargetLayer["LAYER2"] = "LAYER2";
})(ConnectTargetLayer || (ConnectTargetLayer = {}));

/**
 * Enum representing the themes for the widgets.
 */
var WidgetTheme;
(function (WidgetTheme) {
    WidgetTheme["LIGHT"] = "light";
    WidgetTheme["DARK"] = "dark";
})(WidgetTheme || (WidgetTheme = {}));

/**
 * Enum representing different chain IDs.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain ID for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain ID for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain ID for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain ID for Ethereum.
 * @property {number} SEPOLIA - The chain ID for Sepolia.
 */
var ChainId;
(function (ChainId) {
    ChainId[ChainId["IMTBL_ZKEVM_MAINNET"] = 13371] = "IMTBL_ZKEVM_MAINNET";
    ChainId[ChainId["IMTBL_ZKEVM_TESTNET"] = 13473] = "IMTBL_ZKEVM_TESTNET";
    ChainId[ChainId["IMTBL_ZKEVM_DEVNET"] = 13433] = "IMTBL_ZKEVM_DEVNET";
    ChainId[ChainId["ETHEREUM"] = 1] = "ETHEREUM";
    ChainId[ChainId["SEPOLIA"] = 11155111] = "SEPOLIA";
})(ChainId || (ChainId = {}));
/**
 * Enum representing different chain names.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain name for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain name for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain name for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain name for Ethereum.
 * @property {number} SEPOLIA - The chain name for Sepolia.
 */
var ChainName;
(function (ChainName) {
    ChainName["ETHEREUM"] = "Ethereum";
    ChainName["SEPOLIA"] = "Sepolia";
    ChainName["IMTBL_ZKEVM_TESTNET"] = "Immutable zkEVM Test";
    ChainName["IMTBL_ZKEVM_DEVNET"] = "Immutable zkEVM Dev";
    ChainName["IMTBL_ZKEVM_MAINNET"] = "Immutable zkEVM";
})(ChainName || (ChainName = {}));

var OnRampProvider;
(function (OnRampProvider) {
    OnRampProvider["TRANSAK"] = "201811419111";
})(OnRampProvider || (OnRampProvider = {}));

/**
 * An enum representing the type of gas estimate.
 * @enum {string}
 * @property {string} BRIDGE_TO_L2 - The gas estimate type for a bridge to L2 transaction.
 * @property {string} SWAP - The gas estimate type for a swap transaction.
 */
var GasEstimateType;
(function (GasEstimateType) {
    GasEstimateType["BRIDGE_TO_L2"] = "BRIDGE_TO_L2";
    GasEstimateType["SWAP"] = "SWAP";
})(GasEstimateType || (GasEstimateType = {}));

/**
 * Enum representing the types of filters that can be applied to get the allow list of networks.
 */
var NetworkFilterTypes;
(function (NetworkFilterTypes) {
    NetworkFilterTypes["ALL"] = "all";
})(NetworkFilterTypes || (NetworkFilterTypes = {}));

/**
 * Enum representing the types of token filters available.
 */
var TokenFilterTypes;
(function (TokenFilterTypes) {
    TokenFilterTypes["ALL"] = "all";
    TokenFilterTypes["SWAP"] = "swap";
    TokenFilterTypes["BRIDGE"] = "bridge";
    TokenFilterTypes["ONRAMP"] = "onramp";
})(TokenFilterTypes || (TokenFilterTypes = {}));

var WalletAction;
(function (WalletAction) {
    WalletAction["CHECK_CONNECTION"] = "eth_accounts";
    WalletAction["CONNECT"] = "eth_requestAccounts";
    WalletAction["ADD_NETWORK"] = "wallet_addEthereumChain";
    WalletAction["SWITCH_NETWORK"] = "wallet_switchEthereumChain";
    WalletAction["GET_CHAINID"] = "eth_chainId";
})(WalletAction || (WalletAction = {}));
/**
 * Enum representing the platform filters used in {@link GetWalletAllowListParams}.
 */
var WalletFilterTypes;
(function (WalletFilterTypes) {
    WalletFilterTypes["ALL"] = "all";
})(WalletFilterTypes || (WalletFilterTypes = {}));

/**
 * Enum representing the names of different wallet providers.
 */
var WalletProviderName;
(function (WalletProviderName) {
    WalletProviderName["PASSPORT"] = "passport";
    WalletProviderName["METAMASK"] = "metamask";
})(WalletProviderName || (WalletProviderName = {}));
const validateProviderDefaults = {
    allowMistmatchedChainId: false,
    allowUnsupportedProvider: false,
};

/**
 * An enum representing the checkout status types
 * @enum {string}
 * @property {string} SUCCESS - If checkout succeeded as the transactions were able to be processed
 * @property {string} FAILED - If checkout failed due to transactions not settling on chain
 * @property {string} INSUFFICIENT_FUNDS - If checkout failed due to insufficient funds
 */
var CheckoutStatus;
(function (CheckoutStatus) {
    CheckoutStatus["SUCCESS"] = "SUCCESS";
    CheckoutStatus["FAILED"] = "FAILED";
    CheckoutStatus["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
})(CheckoutStatus || (CheckoutStatus = {}));
/**
 * An enum representing the item types
 * @enum {string}
 * @property {string} NATIVE - If the item is a native token.
 * @property {string} ERC20 - If the item is an ERC20 token.
 * @property {string} ERC721 - If the item is an ERC721 token.
 */
var ItemType;
(function (ItemType) {
    ItemType["NATIVE"] = "NATIVE";
    ItemType["ERC20"] = "ERC20";
    ItemType["ERC721"] = "ERC721";
})(ItemType || (ItemType = {}));
/**
 * An enum representing transaction or gas types
 * @enum {string}
 * @property {string} TRANSACTION - If the type is a transaction
 * @property {string} GAS - If the type is the gas amount
 */
var TransactionOrGasType;
(function (TransactionOrGasType) {
    TransactionOrGasType["TRANSACTION"] = "TRANSACTION";
    TransactionOrGasType["GAS"] = "GAS";
})(TransactionOrGasType || (TransactionOrGasType = {}));
/**
 * An enum representing the gas token types
 * @enum {string}
 * @property {string} NATIVE - If the gas token is a native token.
 * @property {string} ERC20 - If the gas token is an ERC20 token.
 */
var GasTokenType;
(function (GasTokenType) {
    GasTokenType["NATIVE"] = "NATIVE";
    GasTokenType["ERC20"] = "ERC20";
})(GasTokenType || (GasTokenType = {}));
/**
 * An enum representing the routing outcome types
 * @enum {string}
 * @property {string} ROUTES_FOUND - If funding routes were found for the transaction.
 * @property {string} NO_ROUTES_FOUND - If no funding routes were found for the transaction.
 * @property {string} NO_ROUTE_OPTIONS - If no routing options were available for the transaction.
 */
var RoutingOutcomeType;
(function (RoutingOutcomeType) {
    RoutingOutcomeType["ROUTES_FOUND"] = "ROUTES_FOUND";
    RoutingOutcomeType["NO_ROUTES_FOUND"] = "NO_ROUTES_FOUND";
    RoutingOutcomeType["NO_ROUTE_OPTIONS"] = "NO_ROUTE_OPTIONS";
})(RoutingOutcomeType || (RoutingOutcomeType = {}));
/**
 * An enum representing the funding step types
 * @enum {string}
 * @property {string} BRIDGE - If the funding step is a bridge.
 * @property {string} SWAP - If the funding step is a swap.
 * @property {string} ONRAMP - If the funding step is an onramp.
 */
var FundingStepType;
(function (FundingStepType) {
    FundingStepType["BRIDGE"] = "BRIDGE";
    FundingStepType["SWAP"] = "SWAP";
    FundingStepType["ONRAMP"] = "ONRAMP";
})(FundingStepType || (FundingStepType = {}));

// import { Passport } from '@imtbl/passport';
/**
 * An enum representing the type of exchange.
 * @enum {string}
 * @property {string} ONRAMP - The exchange type for transacting.
 */
var ExchangeType;
(function (ExchangeType) {
    ExchangeType["ONRAMP"] = "onramp";
})(ExchangeType || (ExchangeType = {}));

/**
 * Enum representing different types of errors that can occur during the checkout process.
 */
var CheckoutErrorType;
(function (CheckoutErrorType) {
    CheckoutErrorType["WEB3_PROVIDER_ERROR"] = "WEB3_PROVIDER_ERROR";
    CheckoutErrorType["PROVIDER_ERROR"] = "PROVIDER_ERROR";
    CheckoutErrorType["DEFAULT_PROVIDER_ERROR"] = "DEFAULT_PROVIDER_ERROR";
    CheckoutErrorType["CONNECT_PROVIDER_ERROR"] = "CONNECT_PROVIDER_ERROR";
    CheckoutErrorType["GET_BALANCE_ERROR"] = "GET_BALANCE_ERROR";
    CheckoutErrorType["GET_INDEXER_BALANCE_ERROR"] = "GET_INDEXER_BALANCE_ERROR";
    CheckoutErrorType["GET_ERC20_BALANCE_ERROR"] = "GET_ERC20_BALANCE_ERROR";
    CheckoutErrorType["GET_ERC721_BALANCE_ERROR"] = "GET_ERC721_BALANCE_ERROR";
    CheckoutErrorType["GET_NETWORK_INFO_ERROR"] = "GET_NETWORK_INFO_ERROR";
    CheckoutErrorType["METAMASK_PROVIDER_ERROR"] = "METAMASK_PROVIDER_ERROR";
    CheckoutErrorType["CHAIN_NOT_SUPPORTED_ERROR"] = "CHAIN_NOT_SUPPORTED_ERROR";
    CheckoutErrorType["PROVIDER_REQUEST_MISSING_ERROR"] = "PROVIDER_REQUEST_MISSING_ERROR";
    CheckoutErrorType["PROVIDER_REQUEST_FAILED_ERROR"] = "PROVIDER_REQUEST_FAILED_ERROR";
    CheckoutErrorType["USER_REJECTED_REQUEST_ERROR"] = "USER_REJECTED_REQUEST_ERROR";
    CheckoutErrorType["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
    CheckoutErrorType["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    CheckoutErrorType["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    CheckoutErrorType["INVALID_GAS_ESTIMATE_TYPE"] = "INVALID_GAS_ESTIMATE_TYPE";
    CheckoutErrorType["UNSUPPORTED_TOKEN_TYPE_ERROR"] = "UNSUPPORTED_TOKEN_TYPE_ERROR";
    CheckoutErrorType["UNSUPPORTED_BALANCE_REQUIREMENT_ERROR"] = "UNSUPPORTED_BALANCE_REQUIREMENT_ERROR";
    CheckoutErrorType["GET_ORDER_LISTING_ERROR"] = "GET_ORDER_LISTING_ERROR";
    CheckoutErrorType["CANCEL_ORDER_LISTING_ERROR"] = "CANCEL_ORDER_LISTING_ERROR";
    CheckoutErrorType["PREPARE_ORDER_LISTING_ERROR"] = "PREPARE_ORDER_LISTING_ERROR";
    CheckoutErrorType["CREATE_ORDER_LISTING_ERROR"] = "CREATE_ORDER_LISTING_ERROR";
    CheckoutErrorType["FULFILL_ORDER_LISTING_ERROR"] = "FULFILL_ORDER_LISTING_ERROR";
    CheckoutErrorType["SWITCH_NETWORK_UNSUPPORTED"] = "SWITCH_NETWORK_UNSUPPORTED";
    CheckoutErrorType["GET_ERC20_ALLOWANCE_ERROR"] = "GET_ERC20_ALLOWANCE_ERROR";
    CheckoutErrorType["GET_ERC721_ALLOWANCE_ERROR"] = "GET_ERC721_ALLOWANCE_ERROR";
    CheckoutErrorType["EXECUTE_APPROVAL_TRANSACTION_ERROR"] = "EXECUTE_APPROVAL_TRANSACTION_ERROR";
    CheckoutErrorType["EXECUTE_FULFILLMENT_TRANSACTION_ERROR"] = "EXECUTE_FULFILLMENT_TRANSACTION_ERROR";
    CheckoutErrorType["SIGN_MESSAGE_ERROR"] = "SIGN_MESSAGE_ERROR";
    CheckoutErrorType["BRIDGE_GAS_ESTIMATE_ERROR"] = "BRIDGE_GAS_ESTIMATE_ERROR";
    CheckoutErrorType["ORDER_FEE_ERROR"] = "ORDER_FEE_ERROR";
    CheckoutErrorType["ITEM_REQUIREMENTS_ERROR"] = "ITEM_REQUIREMENTS_ERROR";
    CheckoutErrorType["API_ERROR"] = "API_ERROR";
    CheckoutErrorType["ORDER_EXPIRED_ERROR"] = "ORDER_EXPIRED_ERROR";
    CheckoutErrorType["WIDGETS_SCRIPT_LOAD_ERROR"] = "WIDGETS_SCRIPT_LOAD_ERROR";
})(CheckoutErrorType || (CheckoutErrorType = {}));
/* The CheckoutError class is a custom error class in TypeScript that includes a message, type, and
optional data object. */
class CheckoutError extends Error {
    message;
    type;
    data;
    constructor(message, type, data) {
        super(message);
        this.message = message;
        this.type = type;
        this.data = data;
    }
}
var CheckoutInternalErrorType;
(function (CheckoutInternalErrorType) {
    CheckoutInternalErrorType["REJECTED_SWITCH_AFTER_ADDING_NETWORK"] = "REJECTED_SWITCH_AFTER_ADDING_NETWORK";
})(CheckoutInternalErrorType || (CheckoutInternalErrorType = {}));
const withCheckoutError = async (
/**
 * Wraps a function that returns a Promise and catches any errors that occur. If an error is caught,
 * it is wrapped in a CheckoutError and rethrown.
 */
fn, customError) => {
    try {
        return await fn();
    }
    catch (error) {
        const cause = `${error.message}` || 'UnknownError';
        const errorMessage = customError.message
            ? `[${customError.type}]:${customError.message}. Cause:${cause}`
            : `[${customError.type}] Cause:${cause}`;
        if (error instanceof CheckoutError) {
            throw new CheckoutError(errorMessage, customError.type, {
                ...customError.data,
                innerErrorType: error.type,
                ...error.data,
            });
        }
        throw new CheckoutError(errorMessage, customError.type, {
            ...customError.data,
        });
    }
};

// this function needs to be in a separate file to prevent circular dependencies with ./network
// this gives us access to the properties of the underlying provider object
async function getUnderlyingChainId(web3Provider) {
    if (!web3Provider.provider?.request) {
        throw new CheckoutError('Parsed provider is not a valid Web3Provider', CheckoutErrorType.WEB3_PROVIDER_ERROR);
    }
    const chainId = await web3Provider.provider.request({
        method: WalletAction.GET_CHAINID,
        params: [],
    });
    return parseInt(chainId, 16);
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const UNRECOGNISED_CHAIN_ERROR_CODE = 4902; // error code (MetaMask)
// these functions should not be exported. These functions should be used as part of an exported function e.g switchWalletNetwork() above.
// make sure to check if(provider.provider?.request) in the exported function and throw an error
// eslint-disable-next-line consistent-return
async function switchNetworkInWallet(networkMap, web3Provider, chainId) {
    if (web3Provider.provider?.request) {
        return await web3Provider.provider.request({
            method: WalletAction.SWITCH_NETWORK,
            params: [
                {
                    chainId: networkMap.get(chainId)?.chainIdHex,
                },
            ],
        });
    }
}
// TODO: Should these functions always return something?
// eslint-disable-next-line consistent-return
async function addNetworkToWallet(networkMap, web3Provider, chainId) {
    if (web3Provider.provider?.request) {
        const networkDetails = networkMap.get(chainId);
        const addNetwork = {
            chainId: networkDetails?.chainIdHex,
            chainName: networkDetails?.chainName,
            rpcUrls: networkDetails?.rpcUrls,
            nativeCurrency: networkDetails?.nativeCurrency,
            blockExplorerUrls: networkDetails?.blockExplorerUrls,
        };
        return await web3Provider.provider.request({
            method: WalletAction.ADD_NETWORK,
            params: [addNetwork],
        });
    }
}
async function getNetworkAllowList(config, { type = NetworkFilterTypes.ALL, exclude }) {
    const { networkMap } = config;
    const allowedNetworkConfig = (await config.remote.getConfig('allowedNetworks'));
    const list = allowedNetworkConfig.filter((network) => {
        const allowAllTokens = type === NetworkFilterTypes.ALL;
        const networkNotExcluded = !(exclude || [])
            .map((exc) => exc.chainId)
            .includes(network.chainId);
        return allowAllTokens && networkNotExcluded;
    });
    const allowedNetworks = [];
    list.forEach((element) => {
        const newNetwork = networkMap.get(element.chainId);
        if (newNetwork) {
            allowedNetworks.push({
                name: newNetwork.chainName,
                chainId: parseInt(newNetwork.chainIdHex, 16),
                nativeCurrency: newNetwork.nativeCurrency,
                isSupported: true,
            });
        }
    });
    return {
        networks: allowedNetworks,
    };
}
async function getNetworkInfo(config, web3Provider) {
    const { networkMap } = config;
    return withCheckoutError(async () => {
        try {
            const network = await web3Provider.getNetwork();
            if (Array.from(networkMap.keys()).includes(network.chainId)) {
                const chainIdNetworkInfo = networkMap.get(network.chainId);
                return {
                    name: chainIdNetworkInfo.chainName,
                    chainId: parseInt(chainIdNetworkInfo.chainIdHex, 16),
                    nativeCurrency: chainIdNetworkInfo.nativeCurrency,
                    isSupported: true,
                };
            }
            return {
                chainId: network.chainId,
                name: network.name,
                isSupported: false,
            };
        }
        catch (err) {
            const chainId = await getUnderlyingChainId(web3Provider);
            const isSupported = Array.from(networkMap.keys()).includes(chainId);
            return {
                chainId,
                isSupported,
            };
        }
    }, {
        type: CheckoutErrorType.GET_NETWORK_INFO_ERROR,
    });
}
async function switchWalletNetwork(config, web3Provider, chainId) {
    const { networkMap } = config;
    const allowedNetworks = await getNetworkAllowList(config, {
        type: NetworkFilterTypes.ALL,
    });
    if (!allowedNetworks.networks.some((network) => network.chainId === chainId)) {
        throw new CheckoutError(`Chain:${chainId} is not a supported chain`, CheckoutErrorType.CHAIN_NOT_SUPPORTED_ERROR);
    }
    if (web3Provider.provider?.isPassport) {
        throw new CheckoutError('Switching networks with Passport provider is not supported', CheckoutErrorType.SWITCH_NETWORK_UNSUPPORTED);
    }
    // WT-1146 - Refer to the README in this folder for explanation on the switch network flow
    try {
        await switchNetworkInWallet(networkMap, web3Provider, chainId);
    }
    catch (err) {
        if (err.code === UNRECOGNISED_CHAIN_ERROR_CODE) {
            try {
                await addNetworkToWallet(networkMap, web3Provider, chainId);
                // eslint-disable-next-line @typescript-eslint/no-shadow
            }
            catch (err) {
                throw new CheckoutError('User cancelled add network request', CheckoutErrorType.USER_REJECTED_REQUEST_ERROR);
            }
        }
        else {
            throw new CheckoutError('User cancelled switch network request', CheckoutErrorType.USER_REJECTED_REQUEST_ERROR);
        }
    }
    const newProvider = new Web3Provider(web3Provider.provider);
    const newProviderNetwork = await newProvider.getNetwork();
    if (newProviderNetwork.chainId !== chainId) {
        throw new CheckoutError('User cancelled switch network request', CheckoutErrorType.USER_REJECTED_REQUEST_ERROR);
    }
    const networkInfo = await getNetworkInfo(config, newProvider);
    return {
        network: networkInfo,
        provider: newProvider,
    };
}

const ENV_DEVELOPMENT = 'development';
const DEFAULT_TOKEN_DECIMALS$1 = 18;
const NATIVE = 'native';
const ZKEVM_NATIVE_TOKEN = {
    name: 'IMX',
    symbol: 'IMX',
    decimals: DEFAULT_TOKEN_DECIMALS$1,
};
/**
 * Base URL for the Immutable API based on the environment.
 * @property {string} DEVELOPMENT - The base URL for the development environment.
 * @property {string} SANDBOX - The base URL for the sandbox environment.
 * @property {string} PRODUCTION - The base URL for the production environment.
 */
const IMMUTABLE_API_BASE_URL = {
    [ENV_DEVELOPMENT]: 'https://api.dev.immutable.com',
    [Environment$1.SANDBOX]: 'https://api.sandbox.immutable.com',
    [Environment$1.PRODUCTION]: 'https://api.immutable.com',
};
/**
 * Base URL for the checkout API based on the environment.
 * @property {string} DEVELOPMENT - The base URL for the development environment.
 * @property {string} SANDBOX - The base URL for the sandbox environment.
 * @property {string} PRODUCTION - The base URL for the production environment.
 */
const CHECKOUT_API_BASE_URL = {
    [ENV_DEVELOPMENT]: 'https://checkout-api.dev.immutable.com',
    [Environment$1.SANDBOX]: 'https://checkout-api.sandbox.immutable.com',
    [Environment$1.PRODUCTION]: 'https://checkout-api.immutable.com',
};
/**
 * Smart Checkout routing default onramp enabled flag
 */
const DEFAULT_ON_RAMP_ENABLED = true;
/**
 * Smart Checkout routing default swap enabled flag
 */
const DEFAULT_SWAP_ENABLED = true;
/**
 * Smart Checkout routing default bridge enabled flag
 */
const DEFAULT_BRIDGE_ENABLED = true;
const TRANSAK_API_BASE_URL = {
    [Environment$1.SANDBOX]: 'https://global-stg.transak.com',
    [Environment$1.PRODUCTION]: 'https://global.transak.com/',
};
const PRODUCTION_CHAIN_ID_NETWORK_MAP = new Map([
    [
        ChainId.ETHEREUM,
        {
            chainIdHex: `0x${ChainId.ETHEREUM.toString(16)}`,
            chainName: ChainName.ETHEREUM,
            rpcUrls: ['https://checkout-api.immutable.com/v1/rpc/eth-mainnet'],
            nativeCurrency: {
                name: ChainName.ETHEREUM,
                symbol: 'ETH',
                decimals: 18,
            },
            blockExplorerUrls: ['https://etherscan.io/'],
        },
    ],
    [
        ChainId.IMTBL_ZKEVM_MAINNET,
        {
            chainIdHex: `0x${ChainId.IMTBL_ZKEVM_MAINNET.toString(16)}`,
            chainName: ChainName.IMTBL_ZKEVM_MAINNET,
            rpcUrls: ['https://rpc.immutable.com'],
            nativeCurrency: ZKEVM_NATIVE_TOKEN,
        },
    ],
]);
const SANDBOX_CHAIN_ID_NETWORK_MAP = new Map([
    [
        ChainId.SEPOLIA,
        {
            chainIdHex: `0x${ChainId.SEPOLIA.toString(16)}`,
            chainName: ChainName.SEPOLIA,
            rpcUrls: [
                'https://checkout-api.sandbox.immutable.com/v1/rpc/eth-sepolia',
            ],
            nativeCurrency: {
                name: 'Sep Eth',
                symbol: 'ETH',
                decimals: 18,
            },
            blockExplorerUrls: ['https://sepolia.etherscan.io/'],
        },
    ],
    [
        ChainId.IMTBL_ZKEVM_TESTNET,
        {
            chainIdHex: `0x${ChainId.IMTBL_ZKEVM_TESTNET.toString(16)}`,
            chainName: ChainName.IMTBL_ZKEVM_TESTNET,
            rpcUrls: ['https://rpc.testnet.immutable.com'],
            nativeCurrency: ZKEVM_NATIVE_TOKEN,
        },
    ],
]);
const DEV_CHAIN_ID_NETWORK_MAP = new Map([
    [
        ChainId.SEPOLIA,
        {
            chainIdHex: `0x${ChainId.SEPOLIA.toString(16)}`,
            chainName: ChainName.SEPOLIA,
            rpcUrls: ['https://checkout-api.dev.immutable.com/v1/rpc/eth-sepolia'],
            nativeCurrency: {
                name: 'Sep Eth',
                symbol: 'ETH',
                decimals: 18,
            },
            blockExplorerUrls: ['https://sepolia.etherscan.io/'],
        },
    ],
    [
        ChainId.IMTBL_ZKEVM_DEVNET,
        {
            chainIdHex: `0x${ChainId.IMTBL_ZKEVM_DEVNET.toString(16)}`,
            chainName: ChainName.IMTBL_ZKEVM_DEVNET,
            rpcUrls: ['https://rpc.dev.immutable.com'],
            nativeCurrency: ZKEVM_NATIVE_TOKEN,
        },
    ],
]);
/**
 * Blockscout API configuration per chain
 */
const BLOCKSCOUT_CHAIN_URL_MAP = {
    [ChainId.IMTBL_ZKEVM_TESTNET]: {
        url: 'https://explorer.testnet.immutable.com',
        nativeToken: SANDBOX_CHAIN_ID_NETWORK_MAP.get(ChainId.IMTBL_ZKEVM_TESTNET).nativeCurrency,
    },
    [ChainId.IMTBL_ZKEVM_MAINNET]: {
        url: 'https://explorer.mainnet.immutable.com',
        nativeToken: PRODUCTION_CHAIN_ID_NETWORK_MAP.get(ChainId.IMTBL_ZKEVM_MAINNET).nativeCurrency,
    },
    [ChainId.SEPOLIA]: {
        url: 'https://eth-sepolia.blockscout.com',
        nativeToken: SANDBOX_CHAIN_ID_NETWORK_MAP.get(ChainId.SEPOLIA).nativeCurrency,
    },
    [ChainId.ETHEREUM]: {
        url: 'https://eth.blockscout.com/',
        nativeToken: PRODUCTION_CHAIN_ID_NETWORK_MAP.get(ChainId.ETHEREUM).nativeCurrency,
    },
};
const ERC20ABI = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8',
            },
        ],
        payable: false,
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256',
            },
        ],
        payable: false,
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
            {
                name: '_spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
];
const ERC721ABI = [
    {
        constant: false,
        inputs: [
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
        ],
        name: 'isApprovedForAll',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getApproved',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'ownerOf',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
// Gas overrides -- Anti-spam mechanism for when the baseFee drops low
// https://github.com/immutable/imx-docs/blob/main/docs/main/zkEVM/overview/gas-configuration.md
const GAS_OVERRIDES = {
    maxFeePerGas: BigNumber$1.from(102e9),
    maxPriorityFeePerGas: BigNumber$1.from(101e9),
};

const SDK_VERSION_MARKER = '0.35.8';
// This SDK version is replaced by the `yarn build` command ran on the root level
const globalPackageVersion = () => SDK_VERSION_MARKER;

class RemoteConfigFetcher {
    isDevelopment;
    isProduction;
    configCache;
    tokensCache;
    version = 'v1';
    constructor(params) {
        this.isDevelopment = params.isDevelopment;
        this.isProduction = params.isProduction;
    }
    static async makeHttpRequest(url) {
        let response;
        try {
            response = await globalAxios$1.get(url);
        }
        catch (error) {
            throw new CheckoutError(`Error fetching from api: ${error.message}`, CheckoutErrorType.API_ERROR);
        }
        if (response.status !== 200) {
            throw new CheckoutError(`Error fetching from api: ${response.status} ${response.statusText}`, CheckoutErrorType.API_ERROR);
        }
        return response;
    }
    getEndpoint = () => {
        if (this.isDevelopment)
            return CHECKOUT_API_BASE_URL[ENV_DEVELOPMENT];
        if (this.isProduction)
            return CHECKOUT_API_BASE_URL[Environment$1.PRODUCTION];
        return CHECKOUT_API_BASE_URL[Environment$1.SANDBOX];
    };
    async loadConfig() {
        if (this.configCache)
            return this.configCache;
        const response = await RemoteConfigFetcher.makeHttpRequest(`${this.getEndpoint()}/${this.version}/config`);
        this.configCache = response.data;
        return this.configCache;
    }
    async loadConfigTokens() {
        if (this.tokensCache)
            return this.tokensCache;
        const response = await RemoteConfigFetcher.makeHttpRequest(`${this.getEndpoint()}/${this.version}/config/tokens`);
        this.tokensCache = response.data;
        return this.tokensCache;
    }
    async getConfig(key) {
        const config = await this.loadConfig();
        if (!config)
            return undefined;
        if (!key)
            return config;
        return config[key];
    }
    async getTokensConfig(chainId) {
        const config = await this.loadConfigTokens();
        if (!config || !config[chainId])
            return {};
        return config[chainId] ?? [];
    }
}

class CheckoutConfigurationError extends Error {
    message;
    constructor(message) {
        super(message);
        this.message = message;
    }
}
const networkMap = (prod, dev) => {
    if (dev)
        return DEV_CHAIN_ID_NETWORK_MAP;
    if (prod)
        return PRODUCTION_CHAIN_ID_NETWORK_MAP;
    return SANDBOX_CHAIN_ID_NETWORK_MAP;
};
// **************************************************** //
// This is duplicated in the widget-lib project.        //
// We are not exposing these functions given that this  //
// to keep the Checkout SDK interface as minimal as     //
// possible.                                            //
// **************************************************** //
const getL1ChainId = (config) => {
    // DevMode and Sandbox will both use Sepolia.
    if (!config.isProduction)
        return ChainId.SEPOLIA;
    return ChainId.ETHEREUM;
};
const getL2ChainId = (config) => {
    if (config.isDevelopment)
        return ChainId.IMTBL_ZKEVM_DEVNET;
    if (config.isProduction)
        return ChainId.IMTBL_ZKEVM_MAINNET;
    return ChainId.IMTBL_ZKEVM_TESTNET;
};
// **************************************************** //
// **************************************************** //
class CheckoutConfiguration {
    // This is a hidden feature that is only available
    // when building the project from source code.
    // This will be used to get around the lack of
    // Environment.DEVELOPMENT
    isDevelopment = "false" === 'true';
    isProduction;
    isOnRampEnabled;
    isSwapEnabled;
    isBridgeEnabled;
    remote;
    environment;
    networkMap;
    constructor(config) {
        if (!Object.values(Environment$1).includes(config.baseConfig.environment)) {
            throw new CheckoutConfigurationError('Invalid checkout configuration of environment');
        }
        this.environment = config.baseConfig.environment;
        // Developer mode will super set any environment configuration
        this.isProduction = !this.isDevelopment && this.environment === Environment$1.PRODUCTION;
        this.isOnRampEnabled = config.onRamp?.enable ?? DEFAULT_ON_RAMP_ENABLED;
        this.isSwapEnabled = config.swap?.enable ?? DEFAULT_SWAP_ENABLED;
        this.isBridgeEnabled = config.bridge?.enable ?? DEFAULT_BRIDGE_ENABLED;
        this.networkMap = networkMap(this.isProduction, this.isDevelopment);
        this.remote = new RemoteConfigFetcher({
            isDevelopment: this.isDevelopment,
            isProduction: this.isProduction,
        });
    }
}

const getTokenAllowList = async (config, { type = TokenFilterTypes.ALL, chainId, exclude, }) => {
    let tokens = [];
    let onRampConfig;
    switch (type) {
        case TokenFilterTypes.SWAP:
            // Fetch tokens from dex-tokens config because
            // Dex needs to have a whitelisted list of tokens due to
            // legal reasons.
            tokens = (await config.remote.getConfig('dex'))
                .tokens || [];
            break;
        case TokenFilterTypes.ONRAMP:
            onRampConfig = (await config.remote.getConfig('onramp'));
            // Only using Transak as it's the only on-ramp provider at the moment
            if (!onRampConfig) {
                tokens = [];
            }
            tokens = onRampConfig[OnRampProvider.TRANSAK]?.tokens || [];
            break;
        case TokenFilterTypes.BRIDGE:
        case TokenFilterTypes.ALL:
        default:
            tokens = (await config.remote.getTokensConfig(chainId || getL1ChainId(config))).allowed;
    }
    if (!exclude || exclude?.length === 0)
        return { tokens };
    return {
        tokens: tokens.filter((token) => !exclude.map((e) => e.address).includes(token.address || '')),
    };
};
const isNativeToken = (address) => !address || address.toLocaleLowerCase() === NATIVE;

const CACHE_DATA_TTL = 60; // seconds
/**
 * Blockscout class provides a client abstraction for the Immutable 3rd party indexer.
 */
class Blockscout {
    url;
    nativeToken;
    ttl;
    chainId;
    cacheMap;
    static async makeHttpRequest(url) {
        return globalAxios$1.get(url);
    }
    setCache(key, data) {
        this.cacheMap[key] = { data, ttl: new Date().getTime() + this.ttl * 1000 };
    }
    getCache(key) {
        const d = this.cacheMap[key];
        if (!d || d.ttl <= new Date().getTime())
            return null;
        return d.data;
    }
    /**
     * Blockscout constructor
     * @param chainId target chain
     * @param ttl cache TTL
     */
    constructor(params) {
        this.chainId = params.chainId;
        this.url = BLOCKSCOUT_CHAIN_URL_MAP[this.chainId].url;
        const native = BLOCKSCOUT_CHAIN_URL_MAP[this.chainId].nativeToken;
        this.nativeToken = {
            address: native.address ?? '',
            decimals: native.decimals.toString(),
            name: native.name,
            symbol: native.symbol,
        };
        this.cacheMap = {};
        this.ttl = params.ttl !== undefined ? params.ttl : CACHE_DATA_TTL;
    }
    /**
     * isChainSupported verifies if the chain is supported by Blockscout
     * @param chainId
     */
    static isChainSupported = (chainId) => Boolean(BLOCKSCOUT_CHAIN_URL_MAP[chainId]);
    /**
     * isBlockscoutError verifies if the error is a Blockscout client error
     * @param err error to evaluate
     */
    static isBlockscoutError = (err) => 'code' in err;
    /**
     * getTokensByWalletAddress fetches the list of tokens (by type) owned by the wallet address.
     * @param walletAddress wallet address
     * @param tokenType token type
     * @param nextPage parameters for the next page, to be provided alongside walletAddress and tokenType
     * @returns list of tokens given the wallet address and the token types
     */
    async getTokensByWalletAddress(params) {
        try {
            let url = `${this.url}/api/v2/addresses/${params.walletAddress}/tokens?type=${params.tokenType}`;
            if (params.nextPage)
                url += `&${new URLSearchParams(params.nextPage)}`;
            // Cache response data to prevent unnecessary requests
            const cached = this.getCache(url);
            if (cached)
                return Promise.resolve(cached);
            const response = await Blockscout.makeHttpRequest(url);
            if (response.status >= 400) {
                return Promise.reject({
                    code: response.status,
                    message: response.statusText,
                });
            }
            // To get around an issue with native tokens being an ERC-20, there is the need
            // to remove IMX from `resp` and add it back in using getNativeTokenByWalletAddress.
            // This has affected some of the early wallets, and it might not be an issue in mainnet
            // however, let's enforce it.
            const data = {
                items: response.data?.items?.filter((token) => token.token.address && token.token.address !== this.nativeToken.address),
                // eslint-disable-next-line @typescript-eslint/naming-convention
                next_page_params: response.data?.next_page_params,
            };
            this.setCache(url, data);
            return Promise.resolve(data);
        }
        catch (err) {
            let code = HttpStatusCode$2.InternalServerError;
            let message = 'InternalServerError';
            if (globalAxios$1.isAxiosError(err)) {
                code = err.response?.status || code;
                message = err.message;
            }
            return Promise.reject({ code, message });
        }
    }
    /**
     * getNativeTokenByWalletAddress fetches the native token owned by the wallet address.
     * @param walletAddress wallet address
     * @returns list of tokens given the wallet address and the token types
     */
    async getNativeTokenByWalletAddress(params) {
        try {
            const url = `${this.url}/api/v2/addresses/${params.walletAddress}`;
            // Cache response data to prevent unnecessary requests
            const cached = this.getCache(url);
            if (cached)
                return Promise.resolve(cached);
            const response = await Blockscout.makeHttpRequest(url);
            if (response.status >= 400) {
                return Promise.reject({
                    code: response.status,
                    message: response.statusText,
                });
            }
            const data = {
                token: this.nativeToken,
                value: response.data.coin_balance,
            };
            this.setCache(url, data);
            return Promise.resolve(data);
        }
        catch (err) {
            let code = HttpStatusCode$2.InternalServerError;
            let message = 'InternalServerError';
            if (globalAxios$1.isAxiosError(err)) {
                code = err.response?.status || code;
                message = err.message;
            }
            return Promise.reject({ code, message });
        }
    }
}

/* eslint @typescript-eslint/naming-convention: off */
var BlockscoutTokenType;
(function (BlockscoutTokenType) {
    BlockscoutTokenType["ERC20"] = "ERC-20";
})(BlockscoutTokenType || (BlockscoutTokenType = {}));

const debugLogger = (config, debugString, seconds) => {
    // eslint-disable-next-line no-console
    if (!config.isProduction)
        console.info(debugString, seconds);
};
const measureAsyncExecution = async (config, debugString, promise) => {
    const startTime = performance.now();
    const result = await promise;
    const endTime = performance.now();
    const elapsedTimeInSeconds = (endTime - startTime) / 1000;
    debugLogger(config, debugString, elapsedTimeInSeconds);
    return result;
};

const getBalance = async (config, web3Provider, walletAddress) => await withCheckoutError(async () => {
    const networkInfo = await getNetworkInfo(config, web3Provider);
    if (!networkInfo.isSupported) {
        throw new CheckoutError(`Chain:${networkInfo.chainId} is not a supported chain`, CheckoutErrorType.CHAIN_NOT_SUPPORTED_ERROR, { chainName: networkInfo.name });
    }
    const balance = await web3Provider.getBalance(walletAddress);
    return {
        balance,
        formattedBalance: utils$1.formatUnits(balance, networkInfo.nativeCurrency.decimals),
        token: networkInfo.nativeCurrency,
    };
}, { type: CheckoutErrorType.GET_BALANCE_ERROR });
async function getERC20Balance(web3Provider, walletAddress, contractAddress) {
    return await withCheckoutError(async () => {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC20ABI), web3Provider);
        return Promise.all([
            contract.name(),
            contract.symbol(),
            contract.balanceOf(walletAddress),
            contract.decimals(),
        ])
            .then(([name, symbol, balance, decimals]) => {
            const formattedBalance = utils$1.formatUnits(balance, decimals);
            return {
                balance,
                formattedBalance,
                token: {
                    name,
                    symbol,
                    decimals,
                    address: contractAddress,
                },
            };
        });
    }, { type: CheckoutErrorType.GET_ERC20_BALANCE_ERROR });
}
// Blockscout client singleton per chain id
const blockscoutClientMap = new Map();
// This function is a utility function that can be used to reset the
// blockscout map and therefore clear all the cache.
const resetBlockscoutClientMap = () => blockscoutClientMap.clear();
const getIndexerBalance = async (walletAddress, chainId, filterTokens) => {
    // Shuffle the mapping of the tokens configuration so it is a hashmap
    // for faster access to tokens config objects.
    const shouldFilter = filterTokens !== undefined;
    const mapFilterTokens = Object.assign({}, ...((filterTokens ?? []).map((t) => ({ [t.address || NATIVE]: t }))));
    // Get blockscout client for the given chain
    let blockscoutClient = blockscoutClientMap.get(chainId);
    if (!blockscoutClient) {
        blockscoutClient = new Blockscout({ chainId });
        blockscoutClientMap.set(chainId, blockscoutClient);
    }
    // Hold the items in an array for post-fetching processing
    const items = [];
    const tokenType = BlockscoutTokenType.ERC20;
    const erc20Balances = async (client) => {
        // Given that the widgets aren't yet designed to support pagination,
        // fetch all the possible tokens associated to a given wallet address.
        let resp;
        try {
            do {
                // eslint-disable-next-line no-await-in-loop
                resp = await client.getTokensByWalletAddress({
                    walletAddress,
                    tokenType,
                    nextPage: resp?.next_page_params,
                });
                items.push(...resp.items);
            } while (resp.next_page_params);
        }
        catch (err) {
            // In case of a 404, the wallet is a new wallet that hasn't been indexed by
            // the Blockscout just yet. This happens when a wallet hasn't had any
            // activity on the chain. In this case, simply ignore the error and return
            // no currencies.
            // In case of a malformed wallet address, Blockscout returns a 422, which
            // means we are safe to assume that a 404 is a missing wallet due to inactivity
            // or simply an incorrect wallet address was provided.
            if (err?.code !== HttpStatusCode$2.NotFound) {
                throw new CheckoutError(err.message || 'InternalServerError | getTokensByWalletAddress', CheckoutErrorType.GET_INDEXER_BALANCE_ERROR, err);
            }
        }
    };
    const nativeBalances = async (client) => {
        try {
            const respNative = await client.getNativeTokenByWalletAddress({ walletAddress });
            respNative.token.address ||= NATIVE;
            items.push(respNative);
        }
        catch (err) {
            // In case of a 404, the wallet is a new wallet that hasn't been indexed by
            // the Blockscout just yet. This happens when a wallet hasn't had any
            // activity on the chain. In this case, simply ignore the error and return
            // no currencies.
            // In case of a malformed wallet address, Blockscout returns a 422, which
            // means we are safe to assume that a 404 is a missing wallet due to inactivity
            // or simply an incorrect wallet address was provided.
            if (err?.code !== HttpStatusCode$2.NotFound) {
                throw new CheckoutError(err.message || 'InternalServerError | getNativeTokenByWalletAddress', CheckoutErrorType.GET_INDEXER_BALANCE_ERROR, err);
            }
        }
    };
    // Promise all() rather than allSettled() so that the function can fail fast.
    await Promise.all([
        erc20Balances(blockscoutClient),
        nativeBalances(blockscoutClient),
    ]);
    const balances = [];
    items.forEach((item) => {
        if (shouldFilter && !mapFilterTokens[item.token.address])
            return;
        const tokenData = item.token || {};
        const balance = BigNumber$1.from(item.value);
        let decimals = parseInt(tokenData.decimals, 10);
        if (Number.isNaN(decimals))
            decimals = DEFAULT_TOKEN_DECIMALS$1;
        const token = {
            ...tokenData,
            decimals,
        };
        const formattedBalance = utils$1.formatUnits(item.value, token.decimals);
        balances.push({ balance, formattedBalance, token });
    });
    return { balances };
};
const getBalances = async (config, web3Provider, walletAddress, tokens) => {
    const allBalancePromises = [];
    tokens
        .forEach((token) => {
        if (!token.address || token.address.toLocaleLowerCase() === NATIVE) {
            allBalancePromises.push(getBalance(config, web3Provider, walletAddress));
        }
        else {
            allBalancePromises.push(getERC20Balance(web3Provider, walletAddress, token.address));
        }
    });
    const balanceResults = await Promise.allSettled(allBalancePromises);
    const balances = balanceResults.filter((result) => result.status === 'fulfilled').map((result) => result.value);
    return { balances };
};
const getAllBalances = async (config, web3Provider, walletAddress, chainId) => {
    // eslint-disable-next-line no-param-reassign
    chainId ||= await web3Provider.getSigner().getChainId();
    const { tokens } = await getTokenAllowList(config, {
        type: TokenFilterTypes.ALL,
        chainId,
    });
    // In order to prevent unnecessary RPC calls
    // let's use the Indexer if available for the
    // given chain.
    let flag = false;
    try {
        flag = (await config.remote.getTokensConfig(chainId)).blockscout || flag;
    }
    catch (err) {
        // eslint-disable-next-line no-console
        console.error(err);
    }
    if (flag && Blockscout.isChainSupported(chainId)) {
        // This is a hack because the widgets are still using the tokens symbol
        // to drive the conversions. If we remove all the token symbols from e.g. zkevm
        // then we would not have fiat conversions.
        // Please remove this hack once https://immutable.atlassian.net/browse/WT-1710
        // is done.
        const isL1Chain = getL1ChainId(config) === chainId;
        return await measureAsyncExecution(config, `Time to fetch balances using blockscout for ${chainId}`, getIndexerBalance(walletAddress, chainId, isL1Chain ? tokens : undefined));
    }
    // This fallback to use ERC20s calls which is a best effort solution
    // Fails in fetching data from the RCP calls might result in some
    // missing data.
    return await measureAsyncExecution(config, `Time to fetch balances using RPC for ${chainId}`, getBalances(config, web3Provider, walletAddress, tokens));
};

async function checkIsWalletConnected(web3Provider) {
    if (!web3Provider?.provider?.request) {
        throw new CheckoutError('Check wallet connection request failed', CheckoutErrorType.PROVIDER_REQUEST_FAILED_ERROR, {
            rpcMethod: WalletAction.CHECK_CONNECTION,
        });
    }
    let accounts = [];
    try {
        accounts = await web3Provider.provider.request({
            method: WalletAction.CHECK_CONNECTION,
            params: [],
        });
    }
    catch (err) {
        throw new CheckoutError('Check wallet connection request failed', CheckoutErrorType.PROVIDER_REQUEST_FAILED_ERROR, {
            rpcMethod: WalletAction.CHECK_CONNECTION,
        });
    }
    // accounts[0] will have the active account if connected.
    return {
        isConnected: accounts && accounts.length > 0,
        walletAddress: accounts[0] ?? '',
    };
}
async function connectSite(web3Provider) {
    if (!web3Provider || !web3Provider.provider?.request) {
        throw new CheckoutError('Incompatible provider', CheckoutErrorType.PROVIDER_REQUEST_MISSING_ERROR, { details: 'Attempting to connect with an incompatible provider' });
    }
    await withCheckoutError(async () => {
        if (!web3Provider.provider.request)
            return;
        // this makes the request to the wallet to connect i.e request eth accounts ('eth_requestAccounts')
        await web3Provider.provider.request({
            method: WalletAction.CONNECT,
            params: [],
        });
    }, { type: CheckoutErrorType.USER_REJECTED_REQUEST_ERROR });
    return web3Provider;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
async function getMetaMaskProvider() {
    const provider = await withCheckoutError(async () => await detectEthereumProvider(), { type: CheckoutErrorType.METAMASK_PROVIDER_ERROR });
    if (!provider || !provider.request) {
        throw new CheckoutError('No MetaMask provider installed.', CheckoutErrorType.METAMASK_PROVIDER_ERROR);
    }
    return new Web3Provider(provider);
}
async function createProvider(walletProviderName, passport) {
    let provider = null;
    switch (walletProviderName) {
        case WalletProviderName.PASSPORT: {
            if (passport) {
                provider = new Web3Provider(passport.connectEvm());
            }
            else {
                // eslint-disable-next-line no-console
                console.error('WalletProviderName was PASSPORT but the passport instance was not provided to the Checkout constructor');
                throw new CheckoutError('Passport not provided', CheckoutErrorType.DEFAULT_PROVIDER_ERROR);
            }
            break;
        }
        case WalletProviderName.METAMASK: {
            provider = await getMetaMaskProvider();
            break;
        }
        default:
            // eslint-disable-next-line no-console
            console.error('The WalletProviderName that was provided is not supported');
            throw new CheckoutError('Provider not supported', CheckoutErrorType.DEFAULT_PROVIDER_ERROR);
    }
    return {
        provider,
        walletProviderName,
    };
}

// this function needs to be in a separate file to prevent circular dependencies with ./network
function isWeb3Provider(web3Provider) {
    if (web3Provider && web3Provider.provider?.request && typeof web3Provider.provider.request === 'function') {
        return true;
    }
    return false;
}
async function validateProvider(config, web3Provider, validateProviderOptions) {
    return withCheckoutError(async () => {
        if (web3Provider.provider?.isPassport) {
            // if Passport skip the validation checks
            return web3Provider;
        }
        if (!isWeb3Provider(web3Provider)) {
            throw new CheckoutError('Parsed provider is not a valid Web3Provider', CheckoutErrorType.WEB3_PROVIDER_ERROR);
        }
        // this sets the default options and overrides them with any parsed options
        const options = {
            ...validateProviderDefaults,
            ...validateProviderOptions,
        };
        const underlyingChainId = await getUnderlyingChainId(web3Provider);
        let web3ChainId = web3Provider.network?.chainId;
        try {
            web3ChainId = web3Provider.network?.chainId;
            if (!web3ChainId) {
                web3ChainId = (await web3Provider.getNetwork()).chainId;
            }
        }
        catch (err) {
            throw new CheckoutError('Unable to detect the web3Provider network', CheckoutErrorType.WEB3_PROVIDER_ERROR);
        }
        if (web3ChainId !== underlyingChainId && !options.allowMistmatchedChainId) {
            throw new CheckoutError('Your wallet has changed network, please switch to a supported network', CheckoutErrorType.WEB3_PROVIDER_ERROR);
        }
        const allowedNetworks = await getNetworkAllowList(config, {
            type: NetworkFilterTypes.ALL,
        });
        const isAllowed = allowedNetworks.networks.some((network) => network.chainId === underlyingChainId);
        if (!isAllowed && !options.allowUnsupportedProvider) {
            throw new CheckoutError('Your wallet is connected to an unsupported network, please switch to a supported network', CheckoutErrorType.WEB3_PROVIDER_ERROR);
        }
        return web3Provider;
    }, {
        type: CheckoutErrorType.WEB3_PROVIDER_ERROR,
    });
}

async function getWalletAllowList(params) {
    const walletList = [];
    const excludedWalletProvider = params.exclude?.map((wp) => wp.walletProviderName) ?? [];
    let walletProviderNames = Object.values(WalletProviderName);
    if (excludedWalletProvider.length !== 0) {
        walletProviderNames = walletProviderNames.filter((wp) => !excludedWalletProvider.includes(wp));
    }
    for (const value of walletProviderNames) {
        walletList.push({
            walletProviderName: value,
        });
    }
    return {
        wallets: walletList,
    };
}

const setTransactionGasLimits = (transaction) => {
    const rawTx = transaction;
    rawTx.maxFeePerGas = GAS_OVERRIDES.maxFeePerGas;
    rawTx.maxPriorityFeePerGas = GAS_OVERRIDES.maxPriorityFeePerGas;
    return rawTx;
};
const sendTransaction = async (web3Provider, transaction) => {
    try {
        const signer = web3Provider.getSigner();
        const rawTx = setTransactionGasLimits(transaction);
        const transactionResponse = await signer.sendTransaction(rawTx);
        return {
            transactionResponse,
        };
    }
    catch (err) {
        if (err.code === ethers.errors.INSUFFICIENT_FUNDS) {
            throw new CheckoutError(err.message, CheckoutErrorType.INSUFFICIENT_FUNDS);
        }
        if (err.code === ethers.errors.ACTION_REJECTED) {
            throw new CheckoutError(err.message, CheckoutErrorType.USER_REJECTED_REQUEST_ERROR);
        }
        if (err.code === ethers.errors.UNPREDICTABLE_GAS_LIMIT) {
            throw new CheckoutError(err.message, CheckoutErrorType.UNPREDICTABLE_GAS_LIMIT);
        }
        throw new CheckoutError(err.message, CheckoutErrorType.TRANSACTION_FAILED);
    }
};

const doesChainSupportEIP1559 = (feeData) => !!feeData.maxFeePerGas && !!feeData.maxPriorityFeePerGas;
const getGasPriceInWei = (feeData) => {
    if (doesChainSupportEIP1559(feeData)) {
        return BigNumber$1.from(feeData.maxFeePerGas).add(BigNumber$1.from(feeData.maxPriorityFeePerGas));
    }
    if (feeData.gasPrice)
        return BigNumber$1.from(feeData.gasPrice);
    return null;
};

const GAS_LIMIT = 140000;
const getGasEstimates = async (provider) => {
    const txnGasLimitInWei = GAS_LIMIT; // todo: fetch gasLimit from bridgeSDK when they add new fn
    const feeData = await provider.getFeeData();
    const gasPriceInWei = getGasPriceInWei(feeData);
    if (!gasPriceInWei)
        return undefined;
    return gasPriceInWei.mul(txnGasLimitInWei);
};
async function getBridgeEstimatedGas(provider, withApproval) {
    const estimatedAmount = await getGasEstimates(provider);
    // Return an undefined value for estimatedAmount
    if (!estimatedAmount)
        return { estimatedAmount };
    if (!withApproval)
        return { estimatedAmount };
    return { estimatedAmount: estimatedAmount.add(estimatedAmount) };
}
async function getBridgeFeeEstimate$1(tokenBridge, tokenAddress) {
    const bridgeFeeResponse = await tokenBridge.getFee({ token: tokenAddress });
    return {
        bridgeFee: { estimatedAmount: bridgeFeeResponse.feeAmount },
        bridgeable: bridgeFeeResponse.bridgeable,
    };
}

async function createBridgeInstance(fromChainId, toChainId, readOnlyProviders, config) {
    const rootChainProvider = readOnlyProviders.get(fromChainId);
    const childChainProvider = readOnlyProviders.get(toChainId);
    if (!rootChainProvider) {
        throw new CheckoutError(`Chain:${fromChainId} is not a supported chain`, CheckoutErrorType.CHAIN_NOT_SUPPORTED_ERROR);
    }
    if (!childChainProvider) {
        throw new CheckoutError(`Chain:${toChainId} is not a supported chain`, CheckoutErrorType.CHAIN_NOT_SUPPORTED_ERROR);
    }
    let bridgeInstance = ETH_SEPOLIA_TO_ZKEVM_TESTNET;
    if (config.isDevelopment)
        bridgeInstance = ETH_SEPOLIA_TO_ZKEVM_DEVNET;
    if (config.isProduction)
        bridgeInstance = ETH_MAINNET_TO_ZKEVM_MAINNET;
    const bridgeConfig = new BridgeConfiguration({
        baseConfig: new ImmutableConfiguration({ environment: config.environment }),
        bridgeInstance,
        rootProvider: rootChainProvider,
        childProvider: childChainProvider,
    });
    return new TokenBridge(bridgeConfig);
}
async function createExchangeInstance(chainId, config) {
    const dexConfig = (await config.remote.getConfig('dex'));
    return new Exchange({
        chainId,
        baseConfig: new ImmutableConfiguration({
            environment: config.environment,
        }),
        overrides: dexConfig?.overrides,
    });
}
function createOrderbookInstance(config) {
    return new Orderbook({
        baseConfig: {
            environment: config.environment,
        },
    });
}
function createBlockchainDataInstance(config) {
    return new BlockchainData({
        baseConfig: {
            environment: config.environment,
        },
    });
}

function getTokenContract(address, contractInterface, signerOrProvider) {
    return new Contract$1(address, contractInterface, signerOrProvider);
}

const DUMMY_WALLET_ADDRESS = '0x0000000000000000000000000000000000000001';
const DEFAULT_TOKEN_DECIMALS = 18;
async function bridgeToL2GasEstimator(readOnlyProviders, config, isSpendingCapApprovalRequired) {
    const fromChainId = getL1ChainId(config);
    const toChainId = getL2ChainId(config);
    const gasEstimateTokensConfig = (await config.remote.getConfig('gasEstimateTokens'));
    const { fromAddress } = gasEstimateTokensConfig[fromChainId].bridgeToL2Addresses;
    const provider = readOnlyProviders.get(fromChainId);
    if (!provider)
        throw new Error(`Missing JsonRpcProvider for chain id: ${fromChainId}`);
    try {
        let gasFees = {};
        const getGasFees = async () => {
            gasFees = await getBridgeEstimatedGas(provider, isSpendingCapApprovalRequired);
            gasFees.token = config.networkMap.get(fromChainId)?.nativeCurrency;
        };
        let bridgeFees = {
            bridgeFee: {},
            bridgeable: false,
        };
        const getBridgeFees = async () => {
            const tokenBridge = await createBridgeInstance(fromChainId, toChainId, readOnlyProviders, config);
            bridgeFees = await getBridgeFeeEstimate$1(tokenBridge, fromAddress);
        };
        await Promise.all([
            getGasFees(),
            getBridgeFees(),
        ]);
        return {
            gasEstimateType: GasEstimateType.BRIDGE_TO_L2,
            gasFee: gasFees,
            bridgeFee: {
                estimatedAmount: bridgeFees.bridgeFee?.estimatedAmount,
                token: bridgeFees.bridgeFee?.token,
            },
            bridgeable: bridgeFees.bridgeable,
        };
    }
    catch {
        // In the case of an error, just return an empty gas & bridge fee estimate
        return {
            gasEstimateType: GasEstimateType.BRIDGE_TO_L2,
            gasFee: {},
            bridgeFee: {},
            bridgeable: false,
        };
    }
}
async function swapGasEstimator(config) {
    const chainId = getL2ChainId(config);
    const gasEstimateTokensConfig = (await config.remote.getConfig('gasEstimateTokens'));
    const { inAddress, outAddress } = gasEstimateTokensConfig[chainId]
        .swapAddresses;
    try {
        const exchange = await createExchangeInstance(chainId, config);
        // Create a fake transaction to get the gas from the quote
        const { swap } = await exchange.getUnsignedSwapTxFromAmountIn(DUMMY_WALLET_ADDRESS, inAddress, outAddress, BigNumber$1.from(utils$1.parseUnits('1', DEFAULT_TOKEN_DECIMALS)));
        if (!swap.gasFeeEstimate) {
            return {
                gasEstimateType: GasEstimateType.SWAP,
                gasFee: {},
            };
        }
        return {
            gasEstimateType: GasEstimateType.SWAP,
            gasFee: {
                estimatedAmount: swap.gasFeeEstimate.value ? BigNumber$1.from(swap.gasFeeEstimate.value) : undefined,
                token: {
                    address: swap.gasFeeEstimate.token.address,
                    symbol: swap.gasFeeEstimate.token.symbol ?? '',
                    name: swap.gasFeeEstimate.token.name ?? '',
                    decimals: swap.gasFeeEstimate.token.decimals ?? DEFAULT_TOKEN_DECIMALS,
                },
            },
        };
    }
    catch {
        // In the case of an error, just return an empty gas fee estimate
        return {
            gasEstimateType: GasEstimateType.SWAP,
            gasFee: {},
        };
    }
}
async function gasEstimator(params, readOnlyProviders, config) {
    switch (params.gasEstimateType) {
        case GasEstimateType.BRIDGE_TO_L2:
            return await bridgeToL2GasEstimator(readOnlyProviders, config, params.isSpendingCapApprovalRequired);
        case GasEstimateType.SWAP:
            return await swapGasEstimator(config);
        default:
            throw new CheckoutError('Invalid type provided for gasEstimateType', CheckoutErrorType.INVALID_GAS_ESTIMATE_TYPE);
    }
}

const allowanceAggregator = (erc20allowances, erc721allowances) => {
    const aggregatedAllowances = [];
    if (!erc20allowances.sufficient) {
        for (const allowance of erc20allowances.allowances) {
            if (!allowance.sufficient)
                aggregatedAllowances.push(allowance);
        }
    }
    if (!erc721allowances.sufficient) {
        for (const allowance of erc721allowances.allowances) {
            if (!allowance.sufficient)
                aggregatedAllowances.push(allowance);
        }
    }
    return aggregatedAllowances;
};

const nativeAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.NATIVE) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { amount } = itemRequirement;
        const aggregateItem = aggregatedMap.get(type);
        if (aggregateItem && aggregateItem.type === ItemType.NATIVE) {
            aggregateItem.amount = BigNumber$1.from(aggregateItem.amount).add(amount);
        }
        else {
            aggregatedMap.set(type, { ...itemRequirement });
        }
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const erc20ItemAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.ERC20) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress, spenderAddress, amount } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        const aggregateItem = aggregatedMap.get(key);
        if (aggregateItem && aggregateItem.type === ItemType.ERC20) {
            aggregateItem.amount = BigNumber$1.from(aggregateItem.amount).add(amount);
        }
        else {
            aggregatedMap.set(key, { ...itemRequirement });
        }
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const erc721ItemAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.ERC721) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress, spenderAddress, id } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}${id}`;
        const aggregateItem = aggregatedMap.get(key);
        if (!aggregateItem)
            aggregatedMap.set(key, { ...itemRequirement });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const itemAggregator = (itemRequirements) => erc721ItemAggregator(erc20ItemAggregator(nativeAggregator(itemRequirements)));

// Gets the amount an address has allowed to be spent by the spender for the ERC20.
const getERC20Allowance = async (provider, ownerAddress, contractAddress, spenderAddress) => {
    try {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC20ABI), provider);
        return await contract.allowance(ownerAddress, spenderAddress);
    }
    catch (err) {
        throw new CheckoutError('Failed to get the allowance for ERC20', CheckoutErrorType.GET_ERC20_ALLOWANCE_ERROR, { contractAddress });
    }
};
// Returns the approval transaction for the ERC20 that the owner can sign
// to approve the spender spending the provided amount of ERC20.
const getERC20ApprovalTransaction = async (provider, ownerAddress, contractAddress, spenderAddress, amount) => {
    try {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC20ABI), provider);
        const approveTransaction = await contract.populateTransaction.approve(spenderAddress, amount);
        if (approveTransaction)
            approveTransaction.from = ownerAddress;
        return approveTransaction;
    }
    catch {
        throw new CheckoutError('Failed to get the approval transaction for ERC20', CheckoutErrorType.GET_ERC20_ALLOWANCE_ERROR, { contractAddress });
    }
};
const hasERC20Allowances = async (provider, ownerAddress, itemRequirements) => {
    let sufficient = true;
    const sufficientAllowances = [];
    const erc20s = new Map();
    const allowancePromises = new Map();
    const insufficientERC20s = new Map();
    const transactionPromises = new Map();
    // Populate maps for both the ERC20 data and promises to get the allowance using the same key
    // so the promise and data can be linked together when the promise resolves
    for (const itemRequirement of itemRequirements) {
        if (itemRequirement.type !== ItemType.ERC20)
            continue;
        const { contractAddress, spenderAddress } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        erc20s.set(key, itemRequirement);
        allowancePromises.set(key, getERC20Allowance(provider, ownerAddress, contractAddress, spenderAddress));
    }
    const allowances = await Promise.all(allowancePromises.values());
    const allowancePromiseIds = Array.from(allowancePromises.keys());
    // Iterate through the allowance promises and get the ERC20 data from the ERC20 map
    // If the allowance returned for that ERC20 is sufficient then just set the item requirements
    // If the allowance is insufficient then set the delta and a promise for the approval transaction
    for (let index = 0; index < allowances.length; index++) {
        const itemRequirement = erc20s.get(allowancePromiseIds[index]);
        if (!itemRequirement || itemRequirement.type !== ItemType.ERC20)
            continue;
        if (allowances[index].gte(itemRequirement.amount)) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement,
            });
            continue;
        }
        sufficient = false; // Set sufficient false on the root of the return object when an ERC20 is insufficient
        const { contractAddress, spenderAddress } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        const delta = itemRequirement.amount.sub(allowances[index]);
        // Create maps for both the insufficient ERC20 data and the transaction promises using the same key so the results can be merged
        insufficientERC20s.set(key, {
            type: ItemType.ERC20,
            sufficient: false,
            delta,
            itemRequirement,
            approvalTransaction: undefined,
        });
        transactionPromises.set(key, getERC20ApprovalTransaction(provider, ownerAddress, contractAddress, spenderAddress, delta));
    }
    // Resolves the approval transactions and merges them with the insufficient ERC20 data
    const transactions = await Promise.all(transactionPromises.values());
    const transactionPromiseIds = Array.from(transactionPromises.keys());
    transactions.forEach((transaction, index) => {
        const insufficientERC20 = insufficientERC20s.get(transactionPromiseIds[index]);
        if (!insufficientERC20)
            return;
        if (insufficientERC20.sufficient)
            return;
        insufficientERC20.approvalTransaction = transaction;
    });
    // Merge the allowance arrays to get both the sufficient allowances and the insufficient ERC20 allowances
    return { sufficient, allowances: sufficientAllowances.concat(Array.from(insufficientERC20s.values())) };
};

// Returns true if the spender address is approved for all ERC721s of this collection
const getERC721ApprovedForAll = async (provider, ownerAddress, contractAddress, spenderAddress) => {
    try {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC721ABI), provider);
        return await contract.isApprovedForAll(ownerAddress, spenderAddress);
    }
    catch (err) {
        throw new CheckoutError('Failed to check approval for all ERC721s of collection', CheckoutErrorType.GET_ERC721_ALLOWANCE_ERROR, { ownerAddress, contractAddress, spenderAddress });
    }
};
// Returns a populated transaction to approve the ERC721 for the spender.
const getApproveTransaction = async (provider, ownerAddress, contractAddress, spenderAddress, id) => {
    try {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC721ABI), provider);
        const transaction = await contract.populateTransaction.approve(spenderAddress, id);
        if (transaction)
            transaction.from = ownerAddress;
        return transaction;
    }
    catch (err) {
        throw new CheckoutError('Failed to get the approval transaction for ERC721', CheckoutErrorType.GET_ERC721_ALLOWANCE_ERROR, {
            id: id.toString(), contractAddress, spenderAddress, ownerAddress,
        });
    }
};
// Returns the address that is approved for the ERC721.
// This is sufficient when the spender is the approved address
const getERC721ApprovedAddress = async (provider, contractAddress, id) => {
    try {
        const contract = new Contract$1(contractAddress, JSON.stringify(ERC721ABI), provider);
        return await contract.getApproved(id);
    }
    catch (err) {
        throw new CheckoutError('Failed to get approved address for ERC721', CheckoutErrorType.GET_ERC721_ALLOWANCE_ERROR, { id: id.toString(), contractAddress });
    }
};
const convertIdToNumber = (id, contractAddress) => {
    const parsedId = parseInt(id, 10);
    if (Number.isNaN(parsedId)) {
        throw new CheckoutError('Invalid ERC721 ID', CheckoutErrorType.GET_ERC721_ALLOWANCE_ERROR, { id, contractAddress });
    }
    return parsedId;
};
const getApprovedCollections = async (provider, itemRequirements, owner) => {
    const approvedCollections = new Map();
    const approvedForAllPromises = new Map();
    for (const itemRequirement of itemRequirements) {
        if (itemRequirement.type !== ItemType.ERC721)
            continue;
        const { contractAddress, spenderAddress } = itemRequirement;
        const key = `${contractAddress}-${spenderAddress}`;
        approvedCollections.set(key, false);
        if (approvedForAllPromises.has(key))
            continue;
        approvedForAllPromises.set(key, getERC721ApprovedForAll(provider, owner, contractAddress, spenderAddress));
    }
    const approvals = await Promise.all(approvedForAllPromises.values());
    const keys = Array.from(approvedForAllPromises.keys());
    approvals.forEach((approval, index) => {
        approvedCollections.set(keys[index], approval);
    });
    return approvedCollections;
};
const hasERC721Allowances = async (provider, ownerAddress, itemRequirements) => {
    let sufficient = true;
    const sufficientAllowances = [];
    // Setup maps to be able to link data back to the associated promises
    const erc721s = new Map();
    const approvedAddressPromises = new Map();
    const insufficientERC721s = new Map();
    const transactionPromises = new Map();
    // Check if there are any collections with approvals for all ERC721s for a given spender
    const approvedCollections = await getApprovedCollections(provider, itemRequirements, ownerAddress);
    // Populate maps for both the ERC721 data and promises to get the approved addresses using the same key
    // so the promise and data can be linked together when the promise is resolved
    for (const itemRequirement of itemRequirements) {
        if (itemRequirement.type !== ItemType.ERC721)
            continue;
        const { contractAddress, id, spenderAddress } = itemRequirement;
        // If the collection is approved for all then just set the item requirements and sufficient true
        const approvedForAllKey = `${contractAddress}-${spenderAddress}`;
        const approvedForAll = approvedCollections.get(approvedForAllKey);
        if (approvedForAll) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement,
            });
            continue;
        }
        // If collection not approved for all then check if the given ERC721 is approved for the spender
        const key = `${contractAddress}-${id}`;
        const convertedId = convertIdToNumber(id, contractAddress);
        erc721s.set(key, itemRequirement);
        approvedAddressPromises.set(key, getERC721ApprovedAddress(provider, contractAddress, convertedId));
    }
    const approvedAddresses = await Promise.all(approvedAddressPromises.values());
    const approvedAddressPromiseIds = Array.from(approvedAddressPromises.keys());
    // Iterate through the approved address promises and get the ERC721 data from the ERC721 map
    // If the approved address returned for that ERC721 is for the spender then just set the item requirements and sufficient true
    // If the approved address does not match the spender then return the approval transaction
    for (let index = 0; index < approvedAddresses.length; index++) {
        const itemRequirement = erc721s.get(approvedAddressPromiseIds[index]);
        if (!itemRequirement || itemRequirement.type !== ItemType.ERC721)
            continue;
        if (approvedAddresses[index] === itemRequirement.spenderAddress) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement,
            });
            continue;
        }
        sufficient = false; // Set sufficient false on the root of the return object when an ERC721 is insufficient
        const { contractAddress, id, spenderAddress } = itemRequirement;
        const key = `${contractAddress}-${id}`;
        const convertedId = convertIdToNumber(id, contractAddress);
        // Create maps for both the insufficient ERC721 data and the transaction promises using the same key so the results can be merged
        insufficientERC721s.set(key, {
            type: ItemType.ERC721,
            sufficient: false,
            itemRequirement,
            approvalTransaction: undefined,
        });
        transactionPromises.set(key, getApproveTransaction(provider, ownerAddress, contractAddress, spenderAddress, convertedId));
    }
    // Resolves the approval transactions and merges them with the insufficient ERC721 data
    const transactions = await Promise.all(transactionPromises.values());
    const transactionPromiseIds = Array.from(transactionPromises.keys());
    transactions.forEach((transaction, index) => {
        const insufficientERC721 = insufficientERC721s.get(transactionPromiseIds[index]);
        if (!insufficientERC721)
            return;
        if (insufficientERC721.sufficient)
            return;
        insufficientERC721.approvalTransaction = transaction;
    });
    // Merge the allowance arrays to get both the sufficient allowances and the insufficient ERC721 allowances
    return { sufficient, allowances: sufficientAllowances.concat(Array.from(insufficientERC721s.values())) };
};

const nativeBalanceAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.NATIVE) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { amount } = itemRequirement;
        const aggregateItem = aggregatedMap.get(type);
        if (aggregateItem && aggregateItem.type === ItemType.NATIVE) {
            aggregateItem.amount = BigNumber$1.from(aggregateItem.amount).add(amount);
        }
        else {
            aggregatedMap.set(type, { ...itemRequirement });
        }
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const erc20BalanceAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.ERC20) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress, amount } = itemRequirement;
        const key = `${contractAddress}`;
        const aggregateItem = aggregatedMap.get(key);
        if (aggregateItem && aggregateItem.type === ItemType.ERC20) {
            aggregateItem.amount = BigNumber$1.from(aggregateItem.amount).add(amount);
        }
        else {
            aggregatedMap.set(key, { ...itemRequirement });
        }
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const erc721BalanceAggregator = (itemRequirements) => {
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement) => {
        const { type } = itemRequirement;
        if (type !== ItemType.ERC721) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress, id } = itemRequirement;
        const key = `${contractAddress}${id}`;
        const aggregateItem = aggregatedMap.get(key);
        if (!aggregateItem)
            aggregatedMap.set(key, { ...itemRequirement });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const balanceAggregator = (itemRequirements) => erc721BalanceAggregator(erc20BalanceAggregator(nativeBalanceAggregator(itemRequirements)));

/* eslint-disable arrow-body-style */
const getTokensFromRequirements = (itemRequirements) => itemRequirements
    .map((itemRequirement) => {
    if (itemRequirement.type === ItemType.NATIVE) {
        return {
            address: NATIVE,
        };
    }
    return {
        address: itemRequirement.contractAddress,
    };
});
/**
 * Gets the balance requirement with delta for an ERC721 requirement.
 */
const getERC721BalanceRequirement = (itemRequirement, balances) => {
    const requiredBalance = BigNumber$1.from(1);
    // Find the requirements related balance
    const itemBalanceResult = balances.find((balance) => {
        const balanceERC721Result = balance;
        return balanceERC721Result.contractAddress === itemRequirement.contractAddress
            && balanceERC721Result.id === itemRequirement.id;
    });
    // Calculate the balance delta
    const sufficient = (requiredBalance.isNegative() || requiredBalance.isZero())
        || (itemBalanceResult?.balance.gte(requiredBalance) ?? false);
    const delta = requiredBalance.sub(itemBalanceResult?.balance ?? BigNumber$1.from(0));
    let erc721BalanceResult = itemBalanceResult;
    if (!erc721BalanceResult) {
        erc721BalanceResult = {
            type: ItemType.ERC721,
            balance: BigNumber$1.from(0),
            formattedBalance: '0',
            contractAddress: itemRequirement.contractAddress,
            id: itemRequirement.id,
        };
    }
    return {
        sufficient,
        type: ItemType.ERC721,
        delta: {
            balance: delta,
            formattedBalance: delta.toString(),
        },
        current: erc721BalanceResult,
        required: {
            ...erc721BalanceResult,
            balance: BigNumber$1.from(1),
            formattedBalance: '1',
        },
    };
};
/**
 * Gets the balance requirement for a NATIVE or ERC20 requirement.
 */
const getTokenBalanceRequirement = (itemRequirement, balances) => {
    let itemBalanceResult;
    // Get the requirements related balance
    if (itemRequirement.type === ItemType.ERC20) {
        itemBalanceResult = balances.find((balance) => {
            return balance.token?.address === itemRequirement.contractAddress;
        });
    }
    else if (itemRequirement.type === ItemType.NATIVE) {
        itemBalanceResult = balances.find((balance) => {
            return isNativeToken(balance.token?.address);
        });
    }
    // Calculate the balance delta
    const requiredBalance = itemRequirement.amount;
    const sufficient = (requiredBalance.isNegative() || requiredBalance.isZero())
        || (itemBalanceResult?.balance.gte(requiredBalance) ?? false);
    const delta = requiredBalance.sub(itemBalanceResult?.balance ?? BigNumber$1.from(0));
    let name = '';
    let symbol = '';
    let decimals = DEFAULT_TOKEN_DECIMALS$1;
    if (itemBalanceResult) {
        decimals = itemBalanceResult.token?.decimals ?? DEFAULT_TOKEN_DECIMALS$1;
        name = itemBalanceResult.token.name;
        symbol = itemBalanceResult.token.symbol;
    }
    let tokenBalanceResult = itemBalanceResult;
    if (itemRequirement.type === ItemType.NATIVE) {
        // No token balance so mark as zero native
        if (!tokenBalanceResult) {
            tokenBalanceResult = {
                type: ItemType.NATIVE,
                balance: BigNumber$1.from(0),
                formattedBalance: '0',
                token: {
                    name,
                    symbol,
                    decimals: DEFAULT_TOKEN_DECIMALS$1,
                },
            };
        }
        return {
            sufficient,
            type: ItemType.NATIVE,
            delta: {
                balance: delta,
                formattedBalance: utils$1.formatUnits(delta, decimals),
            },
            current: {
                ...tokenBalanceResult,
                type: ItemType.NATIVE,
            },
            required: {
                ...tokenBalanceResult,
                type: ItemType.NATIVE,
                balance: BigNumber$1.from(itemRequirement.amount),
                formattedBalance: utils$1.formatUnits(itemRequirement.amount, decimals),
            },
        };
    }
    // No token balance so mark as zero
    if (!tokenBalanceResult) {
        tokenBalanceResult = {
            type: itemRequirement.type,
            balance: BigNumber$1.from(0),
            formattedBalance: '0',
            token: {
                name,
                symbol,
                address: itemRequirement.contractAddress,
                decimals,
            },
        };
    }
    return {
        sufficient,
        type: ItemType.ERC20,
        delta: {
            balance: delta,
            formattedBalance: utils$1.formatUnits(delta, decimals),
        },
        current: tokenBalanceResult,
        required: {
            ...tokenBalanceResult,
            balance: BigNumber$1.from(itemRequirement.amount),
            formattedBalance: utils$1.formatUnits(itemRequirement.amount, decimals),
        },
    };
};

/**
 * Gets the balances for all NATIVE and ERC20 balance requirements.
 */
const getTokenBalances = async (config, provider, ownerAddress, itemRequirements) => {
    try {
        const tokenMap = new Map();
        getTokensFromRequirements(itemRequirements).forEach((item) => {
            if (!item.address)
                return;
            tokenMap.set(item.address.toLocaleLowerCase(), item);
        });
        const { balances } = await getAllBalances(config, provider, ownerAddress, getL2ChainId(config));
        return balances.filter((balance) => tokenMap.get((balance.token.address || NATIVE).toLocaleLowerCase()));
    }
    catch (error) {
        throw new CheckoutError('Failed to get balances', CheckoutErrorType.GET_BALANCE_ERROR);
    }
};
/**
 * Gets the balances for all ERC721 balance requirements.
 */
const getERC721Balances = async (provider, ownerAddress, itemRequirements) => {
    const erc721Balances = [];
    // Setup maps to be able to link data back to the associated promises
    const erc721s = new Map();
    const erc721OwnershipPromises = new Map();
    itemRequirements
        .forEach((itemRequirement) => {
        if (itemRequirement.type !== ItemType.ERC721)
            return;
        const contract = new Contract$1(itemRequirement.contractAddress, JSON.stringify(ERC721ABI), provider);
        erc721s.set(itemRequirement.contractAddress, itemRequirement);
        erc721OwnershipPromises.set(itemRequirement.contractAddress, contract.ownerOf(itemRequirement.id));
    });
    try {
        // Convert ERC721 ownership into a balance result
        const erc721Owners = await Promise.all(erc721OwnershipPromises.values());
        const erc721OwnersPromiseIds = Array.from(erc721OwnershipPromises.keys());
        erc721Owners.forEach((erc721OwnerAddress, index) => {
            const itemRequirement = erc721s.get(erc721OwnersPromiseIds[index]);
            let itemCount = 0;
            if (itemRequirement && ownerAddress === erc721OwnerAddress) {
                itemCount = 1;
            }
            erc721Balances.push({
                type: ItemType.ERC721,
                balance: BigNumber$1.from(itemCount),
                formattedBalance: itemCount.toString(),
                contractAddress: itemRequirement.contractAddress,
                id: itemRequirement.id,
            });
        });
    }
    catch (error) {
        throw new CheckoutError('Failed to get ERC721 balances', CheckoutErrorType.GET_ERC721_BALANCE_ERROR);
    }
    return erc721Balances;
};
/**
 * Checks the item requirements against the owner balances.
 */
const balanceCheck = async (config, provider, ownerAddress, itemRequirements) => {
    const aggregatedItems = balanceAggregator(itemRequirements);
    const requiredToken = [];
    const requiredERC721 = [];
    aggregatedItems.forEach((item) => {
        switch (item.type) {
            case ItemType.ERC20:
            case ItemType.NATIVE:
                requiredToken.push(item);
                break;
            case ItemType.ERC721:
                requiredERC721.push(item);
                break;
        }
    });
    if (requiredERC721.length === 0 && requiredToken.length === 0) {
        throw new CheckoutError('Unsupported item requirement balance check', CheckoutErrorType.UNSUPPORTED_BALANCE_REQUIREMENT_ERROR);
    }
    // Get all ERC20 and NATIVE balances
    const balancePromises = [];
    if (requiredToken.length > 0) {
        balancePromises.push(getTokenBalances(config, provider, ownerAddress, aggregatedItems));
    }
    // Get all ERC721 balances
    if (requiredERC721.length > 0) {
        balancePromises.push(getERC721Balances(provider, ownerAddress, aggregatedItems));
    }
    // Wait for all balances and calculate the requirements
    const promisesResponses = await Promise.all(balancePromises);
    const balanceRequirements = [];
    // Get all ERC20 and NATIVE balances
    if (requiredToken.length > 0 && promisesResponses.length > 0) {
        const result = promisesResponses.shift();
        if (result) {
            requiredToken.forEach((item) => {
                balanceRequirements.push(getTokenBalanceRequirement(item, result));
            });
        }
    }
    // Get all ERC721 balances
    if (requiredERC721.length > 0 && promisesResponses.length > 0) {
        const result = promisesResponses.shift();
        if (result) {
            requiredERC721.forEach((item) => {
                balanceRequirements.push(getERC721BalanceRequirement(item, result));
            });
        }
    }
    // Find if there are any requirements that aren't sufficient.
    // If there is not item with sufficient === false then the requirements
    // are satisfied.
    const sufficient = balanceRequirements.find((req) => req.sufficient === false) === undefined;
    return {
        sufficient,
        balanceRequirements,
    };
};

const estimateGas = async (provider, transaction) => {
    try {
        return await provider.estimateGas(transaction);
    }
    catch (err) {
        throw new CheckoutError('Failed to estimate gas for transaction', CheckoutErrorType.UNPREDICTABLE_GAS_LIMIT);
    }
};
const getGasItemRequirement = (gas, transactionOrGas) => {
    if (transactionOrGas.type === TransactionOrGasType.TRANSACTION
        || transactionOrGas.gasToken.type === GasTokenType.NATIVE) {
        return {
            type: ItemType.NATIVE,
            amount: gas,
        };
    }
    return {
        type: ItemType.ERC20,
        amount: gas,
        contractAddress: transactionOrGas.gasToken.contractAddress,
        spenderAddress: '',
    };
};
const gasCalculator = async (provider, insufficientItems, transactionOrGas) => {
    const estimateGasPromises = [];
    let totalGas = BigNumber$1.from(0);
    // Get all the gas estimate promises for the approval transactions
    for (const item of insufficientItems) {
        if (item.approvalTransaction === undefined)
            continue;
        estimateGasPromises.push(estimateGas(provider, item.approvalTransaction));
    }
    // If the transaction is a fulfillment transaction get the estimate gas promise
    // Otherwise use the gas amount with the limit to estimate the gas
    if (transactionOrGas.type === TransactionOrGasType.TRANSACTION) {
        estimateGasPromises.push(estimateGas(provider, transactionOrGas.transaction));
    }
    else {
        const feeData = await provider.getFeeData();
        const gasPrice = getGasPriceInWei(feeData);
        if (gasPrice !== null) {
            const gas = gasPrice?.mul(transactionOrGas.gasToken.limit);
            if (gas)
                totalGas = totalGas.add(gas);
        }
    }
    // Get the gas estimates for all the transactions and calculate the total gas
    const gasEstimatePromises = await Promise.all(estimateGasPromises);
    gasEstimatePromises.forEach((gasEstimate) => {
        totalGas = totalGas.add(gasEstimate);
    });
    if (totalGas.eq(0))
        return null;
    return getGasItemRequirement(totalGas, transactionOrGas);
};

const availabilityService = (isDevelopment, isProduction) => {
    const postEndpoint = () => {
        if (isDevelopment)
            return IMMUTABLE_API_BASE_URL[ENV_DEVELOPMENT];
        if (isProduction)
            return IMMUTABLE_API_BASE_URL[Environment$1.PRODUCTION];
        return IMMUTABLE_API_BASE_URL[Environment$1.SANDBOX];
    };
    const checkDexAvailability = async () => {
        let response;
        try {
            response = await globalAxios$1.post(`${postEndpoint()}/v1/availability/checkout/swap`);
        }
        catch (error) {
            response = error.response;
        }
        if (response.status === 403) {
            return false;
        }
        if (response.status === 204) {
            return true;
        }
        throw new CheckoutError(`Error fetching from api: ${response.status} ${response.statusText}`, CheckoutErrorType.API_ERROR);
    };
    return {
        checkDexAvailability,
    };
};

const isOnRampAvailable = async () => true;
const isSwapAvailable = async (config) => {
    const availability = availabilityService(config.isDevelopment, config.isProduction);
    try {
        return await availability.checkDexAvailability();
    }
    catch {
        return false;
    }
};

const isPassportProvider = (provider) => provider.provider?.isPassport === true ?? false;
/**
 * Determines which routing options are available.
 */
const getAvailableRoutingOptions = async (config, provider) => {
    const availableRoutingOptions = {
        onRamp: config.isOnRampEnabled,
        swap: config.isSwapEnabled,
        bridge: config.isBridgeEnabled,
    };
    // Geo-blocking checks
    const geoBlockingChecks = [];
    if (availableRoutingOptions.onRamp) {
        geoBlockingChecks.push({ id: 'onRamp', promise: isOnRampAvailable() });
    }
    if (availableRoutingOptions.swap) {
        geoBlockingChecks.push({ id: 'swap', promise: isSwapAvailable(config) });
    }
    if (geoBlockingChecks.length > 0) {
        const promises = geoBlockingChecks.map((geoBlockingCheck) => geoBlockingCheck.promise);
        const geoBlockingStatus = await Promise.allSettled(promises);
        geoBlockingStatus.forEach((result, index) => {
            const statusId = geoBlockingChecks[index].id;
            availableRoutingOptions[statusId] = availableRoutingOptions[statusId]
                && result.status === 'fulfilled'
                && result.value;
        });
    }
    // Bridge not available if passport provider
    availableRoutingOptions.bridge = availableRoutingOptions.bridge && !isPassportProvider(provider);
    return availableRoutingOptions;
};

const getAllTokenBalances = async (config, readOnlyProviders, ownerAddress, availableRoutingOptions) => {
    const chainBalances = new Map();
    const chainBalancePromises = new Map();
    if (readOnlyProviders.size === 0) {
        const noProviderResult = {
            success: false,
            error: new CheckoutError('No L1 or L2 provider available', CheckoutErrorType.PROVIDER_ERROR),
            balances: [],
        };
        chainBalances.set(getL1ChainId(config), noProviderResult);
        chainBalances.set(getL2ChainId(config), noProviderResult);
        return chainBalances;
    }
    // Only get L1 Balances if we can bridge
    if (availableRoutingOptions.bridge) {
        const chainId = getL1ChainId(config);
        if (readOnlyProviders.has(chainId)) {
            chainBalancePromises.set(chainId, getAllBalances(config, readOnlyProviders.get(chainId), ownerAddress, chainId));
        }
        else {
            chainBalances.set(getL1ChainId(config), {
                success: false,
                error: new CheckoutError(`No L1 provider available for ${chainId}`, CheckoutErrorType.PROVIDER_ERROR),
                balances: [],
            });
        }
    }
    const chainId = getL2ChainId(config);
    if (readOnlyProviders.has(chainId)) {
        chainBalancePromises.set(chainId, getAllBalances(config, readOnlyProviders.get(chainId), ownerAddress, chainId));
    }
    else {
        chainBalances.set(getL2ChainId(config), {
            success: false,
            error: new CheckoutError(`No L2 provider available for ${chainId}`, CheckoutErrorType.PROVIDER_ERROR),
            balances: [],
        });
    }
    if (chainBalancePromises.size > 0) {
        const chainIds = Array.from(chainBalancePromises.keys());
        const balanceSettledResults = await Promise.allSettled(chainBalancePromises.values());
        balanceSettledResults.forEach((balanceSettledResult, index) => {
            const balanceChainId = chainIds[index];
            if (balanceSettledResult.status === 'fulfilled') {
                chainBalances.set(balanceChainId, {
                    success: true,
                    balances: balanceSettledResult.value.balances,
                });
            }
            else {
                chainBalances.set(balanceChainId, {
                    success: false,
                    error: new CheckoutError(`Error getting ${chainId} balances`, CheckoutErrorType.GET_BALANCE_ERROR),
                    balances: [],
                });
            }
        });
    }
    return chainBalances;
};

async function createReadOnlyProviders(config, existingReadOnlyProviders) {
    if (config.isProduction && existingReadOnlyProviders?.has(ChainId.ETHEREUM))
        return existingReadOnlyProviders;
    if (existingReadOnlyProviders?.has(ChainId.SEPOLIA))
        return existingReadOnlyProviders;
    const readOnlyProviders = new Map();
    const allowedNetworks = await getNetworkAllowList(config, {
        type: NetworkFilterTypes.ALL,
    });
    allowedNetworks.networks.forEach((networkInfo) => {
        const rpcUrl = config.networkMap.get(networkInfo.chainId)?.rpcUrls[0];
        const provider = new JsonRpcProvider(rpcUrl);
        readOnlyProviders.set(networkInfo.chainId, provider);
    });
    return readOnlyProviders;
}

const quoteFetcher = async (config, chainId, walletAddress, requiredToken, swappableTokens) => {
    const dexQuotes = new Map();
    // Apply a small slippage percent as a buffer to cover price fluctuations between token pairs
    const slippagePercent = 1;
    try {
        const exchange = await createExchangeInstance(chainId, config);
        const dexTransactionResponsePromises = [];
        const fromToken = [];
        // Create a quote for each swappable token
        for (const swappableToken of swappableTokens) {
            if (swappableToken === requiredToken.address)
                continue;
            dexTransactionResponsePromises.push(exchange.getUnsignedSwapTxFromAmountOut(walletAddress, swappableToken, requiredToken.address, requiredToken.amount, slippagePercent));
            fromToken.push(swappableToken);
        }
        // Resolve all the quotes and link them back to the swappable token
        // The swappable token array is in the same position in the array as the quote in the promise array
        const dexTransactionResponse = await measureAsyncExecution(config, 'Time to resolve swap quotes from the dex', Promise.allSettled(dexTransactionResponsePromises));
        dexTransactionResponse.forEach((response, index) => {
            if (response.status === 'rejected')
                return; // Ignore any requests to dex that failed to resolve
            const swappableToken = fromToken[index];
            dexQuotes.set(swappableToken, {
                quote: response.value.quote,
                approval: response.value.approval?.gasFeeEstimate ?? null,
                swap: response.value.swap.gasFeeEstimate,
            });
        });
        return dexQuotes;
    }
    catch {
        return dexQuotes;
    }
};

const constructFees$1 = (approvalGasFees, swapGasFees, swapFees) => {
    let approvalGasFeeAmount = BigNumber$1.from(0);
    let approvalGasFeeFormatted = '0';
    let approvalToken;
    if (approvalGasFees) {
        approvalGasFeeAmount = approvalGasFees.value;
        approvalGasFeeFormatted = utils$1.formatUnits(approvalGasFees.value, approvalGasFees.token.decimals);
        approvalToken = {
            name: approvalGasFees.token.name ?? '',
            symbol: approvalGasFees.token.symbol ?? '',
            address: approvalGasFees.token.address,
            decimals: approvalGasFees.token.decimals,
        };
    }
    let swapGasFeeAmount = BigNumber$1.from(0);
    let swapGasFeeFormatted = '0';
    let swapGasToken;
    if (swapGasFees) {
        swapGasFeeAmount = swapGasFees.value;
        swapGasFeeFormatted = utils$1.formatUnits(swapGasFees.value, swapGasFees.token.decimals);
        swapGasToken = {
            name: swapGasFees.token.name ?? '',
            symbol: swapGasFees.token.symbol ?? '',
            address: swapGasFees.token.address,
            decimals: swapGasFees.token.decimals,
        };
    }
    const fees = [];
    for (const swapFee of swapFees) {
        fees.push({
            amount: swapFee.amount.value,
            formattedAmount: utils$1.formatUnits(swapFee.amount.value, swapFee.amount.token.decimals),
            token: {
                name: swapFee.amount.token.name ?? '',
                symbol: swapFee.amount.token.symbol ?? '',
                address: swapFee.amount.token.address,
                decimals: swapFee.amount.token.decimals,
            },
        });
    }
    return {
        approvalGasFees: {
            amount: approvalGasFeeAmount,
            formattedAmount: approvalGasFeeFormatted,
            token: approvalToken,
        },
        swapGasFees: {
            amount: swapGasFeeAmount,
            formattedAmount: swapGasFeeFormatted,
            token: swapGasToken,
        },
        swapFees: fees,
    };
};
const constructSwapRoute = (chainId, fundsRequired, userBalance, fees) => {
    const tokenAddress = userBalance.token.address;
    let type = ItemType.ERC20;
    if (isNativeToken(tokenAddress)) {
        type = ItemType.NATIVE;
    }
    return {
        type: FundingStepType.SWAP,
        chainId,
        fundingItem: {
            type,
            fundsRequired: {
                amount: fundsRequired,
                formattedAmount: utils$1.formatUnits(fundsRequired, userBalance.token.decimals),
            },
            userBalance: {
                balance: userBalance.balance,
                formattedBalance: userBalance.formattedBalance,
            },
            token: userBalance.token,
        },
        fees,
    };
};
const isBalanceRequirementTokenValid = (balanceRequirement) => {
    if (balanceRequirement.type === ItemType.ERC20) {
        return !!balanceRequirement.required.token.address;
    }
    if (balanceRequirement.type === ItemType.NATIVE) {
        return isNativeToken(balanceRequirement.required.token.address);
    }
    return false;
};
const getRequiredToken = (balanceRequirement) => {
    let address = '';
    let amount = BigNumber$1.from(0);
    switch (balanceRequirement.type) {
        case ItemType.ERC20:
            address = balanceRequirement.required.token.address;
            amount = balanceRequirement.delta.balance;
            break;
        case ItemType.NATIVE:
            amount = balanceRequirement.delta.balance;
            break;
    }
    return { address, amount };
};
const checkUserCanCoverApprovalFees = (l2Balances, approval) => {
    // Check if approval required
    if (!approval)
        return { sufficient: true, approvalGasFee: BigNumber$1.from(0), approvalGasTokenAddress: '' };
    const approvalGasFee = approval.value;
    const approvalGasTokenAddress = approval.token.address;
    // No balance on L2 to cover approval fees
    if (l2Balances.length === 0) {
        return {
            sufficient: false,
            approvalGasFee,
            approvalGasTokenAddress,
        };
    }
    // Find the users balance of the approval token
    const l2BalanceOfApprovalToken = l2Balances.find((balance) => (isNativeToken(balance.token.address) && isNativeToken(approvalGasTokenAddress))
        || balance.token.address === approvalGasTokenAddress);
    if (!l2BalanceOfApprovalToken)
        return { sufficient: false, approvalGasFee, approvalGasTokenAddress };
    // If the user does not have enough of the token to cover approval fees then return sufficient false
    if (l2BalanceOfApprovalToken.balance.lt(approvalGasFee)) {
        return {
            sufficient: false,
            approvalGasFee,
            approvalGasTokenAddress,
        };
    }
    // The user has enough to cover approval gas fees
    return { sufficient: true, approvalGasFee, approvalGasTokenAddress };
};
const checkUserCanCoverSwapFees = (l2Balances, approvalFees, swapGasFees, swapFees, tokenBeingSwapped) => {
    // Set up a map of token addresses to amounts for each of the swap fees
    const feeMap = new Map();
    // Add the approval fee to list of fees
    if (approvalFees.approvalGasFee.gt(BigNumber$1.from(0))) {
        feeMap.set(approvalFees.approvalGasTokenAddress, approvalFees.approvalGasFee);
    }
    // Add the swap gas fee to list of fees
    if (swapGasFees) {
        const fee = feeMap.get(swapGasFees.token.address);
        if (fee) {
            feeMap.set(swapGasFees.token.address, fee.add(swapGasFees.value));
        }
        else {
            feeMap.set(swapGasFees.token.address, swapGasFees.value);
        }
    }
    // Add the token being swapped to list of fees to ensure the user can cover the fee + the token swap
    if (tokenBeingSwapped) {
        const fee = feeMap.get(tokenBeingSwapped.address);
        if (fee) { // Token being swapped is the same as gas token
            feeMap.set(tokenBeingSwapped.address, fee.add(tokenBeingSwapped.amount));
        }
        else {
            feeMap.set(tokenBeingSwapped.address, tokenBeingSwapped.amount);
        }
    }
    // Get all the fees and key them by their token id
    for (const swapFee of swapFees) {
        const fee = feeMap.get(swapFee.amount.token.address);
        if (fee) {
            feeMap.set(swapFee.amount.token.address, fee.add(swapFee.amount.value));
            continue;
        }
        feeMap.set(swapFee.amount.token.address, swapFee.amount.value);
    }
    // Go through the map and for each token address check if the user has enough balance to cover the fee
    for (const [tokenAddress, fee] of feeMap.entries()) {
        if (fee === BigNumber$1.from(0))
            continue;
        const l2BalanceOfFeeToken = l2Balances.find((balance) => (isNativeToken(balance.token.address) && isNativeToken(tokenAddress))
            || balance.token.address === tokenAddress);
        if (!l2BalanceOfFeeToken) {
            return false;
        }
        if (l2BalanceOfFeeToken.balance.lt(fee)) {
            return false;
        }
    }
    return true;
};
// The item for swapping may also be a balance requirement
// for the action. Need to ensure that if the user does a swap
// this token to cover the insufficient balance that the user
// still has enough funds of this token to fulfill the balance
// requirement.
const checkIfUserCanCoverRequirement = (l2balance, balanceRequirements, quoteTokenAddress, amountBeingSwapped, approvalFees, swapFees) => {
    let remainingBalance = BigNumber$1.from(0);
    let balanceRequirementToken = '';
    let requirementExists = false;
    balanceRequirements.balanceRequirements.forEach((requirement) => {
        if (requirement.type === ItemType.NATIVE || requirement.type === ItemType.ERC20) {
            if (requirement.required.token.address === quoteTokenAddress) {
                balanceRequirementToken = requirement.required.token.address;
                requirementExists = true;
                // Get the balance that would remain if the requirement was removed from the users balance
                remainingBalance = l2balance.sub(requirement.required.balance);
            }
        }
    });
    // No requirement exists matching this token so no need to check if user can cover requirement
    if (!requirementExists)
        return true;
    // Remove approval fees from the remainder if token matches as these need to be taken out to cover the swap
    if (approvalFees.approvalGasTokenAddress === balanceRequirementToken) {
        remainingBalance = remainingBalance.sub(approvalFees.approvalGasFee);
    }
    // Remove swap fees from the remainder if token matches as these need to be taken out to cover the swap
    for (const swapFee of swapFees) {
        if (swapFee.amount.token.address === balanceRequirementToken) {
            remainingBalance = remainingBalance.sub(swapFee.amount.value);
        }
    }
    // If the users current balance can cover the balance after fees + the amount
    // that is going to be swapped from another item requirement then return true
    return remainingBalance.gte(amountBeingSwapped);
};
const swapRoute = async (config, availableRoutingOptions, walletAddress, balanceRequirement, tokenBalanceResults, swappableTokens, balanceRequirements) => {
    const fundingSteps = [];
    if (!availableRoutingOptions.swap)
        return fundingSteps;
    if (swappableTokens.length === 0)
        return fundingSteps;
    if (!isBalanceRequirementTokenValid(balanceRequirement))
        return fundingSteps;
    const requiredToken = getRequiredToken(balanceRequirement);
    const chainId = getL2ChainId(config);
    const l2TokenBalanceResult = tokenBalanceResults.get(chainId);
    if (!l2TokenBalanceResult)
        return fundingSteps;
    const l2Balances = l2TokenBalanceResult.balances;
    if (l2Balances.length === 0)
        return fundingSteps;
    const quotes = await quoteFetcher(config, getL2ChainId(config), walletAddress, requiredToken, swappableTokens);
    const quoteTokenAddresses = Array.from(quotes.keys());
    for (const quoteTokenAddress of quoteTokenAddresses) {
        const quote = quotes.get(quoteTokenAddress);
        if (!quote)
            continue;
        // Find the balance the user has for this quoted token
        const userBalanceOfQuotedToken = l2Balances.find((balance) => balance.token.address === quoteTokenAddress);
        // If no balance found on L2 for this quoted token then continue
        if (!userBalanceOfQuotedToken)
            continue;
        // Check the amount of quoted token required against the user balance
        const amountOfQuoteTokenRequired = quote.quote.amount;
        // If user does not have enough balance to perform the swap with this token then continue
        if (userBalanceOfQuotedToken.balance.lt(amountOfQuoteTokenRequired.value))
            continue;
        const approvalFees = checkUserCanCoverApprovalFees(l2Balances, quote.approval);
        // If user does not have enough to cover approval fees then continue
        if (!approvalFees.sufficient)
            continue;
        // If user does not have enough to cover swap fees then continue
        if (!checkUserCanCoverSwapFees(l2Balances, approvalFees, quote.swap, quote.quote.fees, {
            amount: amountOfQuoteTokenRequired.value,
            address: quoteTokenAddress,
        }))
            continue;
        if (!checkIfUserCanCoverRequirement(userBalanceOfQuotedToken.balance, balanceRequirements, quoteTokenAddress, amountOfQuoteTokenRequired.value, approvalFees, quote.quote.fees))
            continue;
        const fees = constructFees$1(quote.approval, quote.swap, quote.quote.fees);
        // User has sufficient funds of this token to cover any gas fees, swap fees and balance requirements
        // so add this token to the possible swap options
        fundingSteps.push(constructSwapRoute(chainId, amountOfQuoteTokenRequired.value, userBalanceOfQuotedToken, fees));
    }
    return fundingSteps;
};

const filterTokens = (allowedTokens, balances) => {
    if (balances && balances.success) {
        return allowedTokens.filter((token) => {
            if ('address' in token) {
                return balances.balances.find((balance) => balance.token.address === token.address && balance.balance.gt(0));
            }
            return balances.balances.find((balance) => !('address' in balance.token) && balance.balance.gt(0));
        });
    }
    return [];
};
const allowListCheckForOnRamp = async (config, availableRoutingOptions) => {
    if (availableRoutingOptions.onRamp) {
        const onRampOptions = await config.remote.getConfig('onramp');
        const onRampAllowList = {};
        Object.entries(onRampOptions)
            .forEach(([onRampProvider, onRampProviderConfig]) => {
            // Allowed list per onRamp provider
            onRampAllowList[onRampProvider] = onRampProviderConfig.tokens ?? [];
        });
        return onRampAllowList;
    }
    return {};
};
const allowListCheckForBridge = async (config, tokenBalances, availableRoutingOptions) => {
    if (availableRoutingOptions.bridge) {
        const allowedTokens = (await config.remote.getConfig('bridge'))?.tokens ?? [];
        const balances = tokenBalances.get(getL1ChainId(config));
        return filterTokens(allowedTokens, balances);
    }
    return [];
};
const allowListCheckForSwap = async (config, tokenBalances, availableRoutingOptions) => {
    if (availableRoutingOptions.swap) {
        const allowedTokens = (await config.remote.getConfig('dex'))?.tokens ?? [];
        const balances = tokenBalances.get(getL2ChainId(config));
        return filterTokens(allowedTokens, balances);
    }
    return [];
};
/**
 * Checks the user balances against the route option allowlists.
 */
const allowListCheck = async (config, tokenBalances, availableRoutingOptions) => {
    const tokenAllowList = {};
    tokenAllowList.swap = await allowListCheckForSwap(config, tokenBalances, availableRoutingOptions);
    tokenAllowList.bridge = await allowListCheckForBridge(config, tokenBalances, availableRoutingOptions);
    tokenAllowList.onRamp = await allowListCheckForOnRamp(config, availableRoutingOptions);
    return tokenAllowList;
};

const getEthBalance = (balances) => {
    for (const balance of balances.balances) {
        if (isNativeToken(balance.token.address)) {
            return balance.balance;
        }
    }
    return BigNumber$1.from(0);
};

const getBridgeFeeEstimate = async (config, readOnlyProviders) => {
    try {
        const estimate = await gasEstimator({
            gasEstimateType: GasEstimateType.BRIDGE_TO_L2,
            isSpendingCapApprovalRequired: false,
        }, readOnlyProviders, config);
        const gasEstimate = estimate.gasFee.estimatedAmount;
        const bridgeFee = estimate.bridgeFee.estimatedAmount;
        let totalFees = BigNumber$1.from(0);
        if (gasEstimate)
            totalFees = totalFees.add(gasEstimate);
        if (bridgeFee)
            totalFees = totalFees.add(bridgeFee);
        return {
            type: FundingStepType.BRIDGE,
            gasFee: {
                estimatedAmount: gasEstimate ?? BigNumber$1.from(0),
                token: estimate.gasFee.token,
            },
            bridgeFee: {
                estimatedAmount: bridgeFee ?? BigNumber$1.from(0),
                token: estimate.bridgeFee.token,
            },
            totalFees,
        };
    }
    catch (err) {
        throw new CheckoutError('Error estimating gas for bridge', CheckoutErrorType.BRIDGE_GAS_ESTIMATE_ERROR, { message: err.message });
    }
};

// If the root address evaluates to this then its ETH
const INDEXER_ETH_ROOT_CONTRACT_ADDRESS = '0x0000000000000000000000000000000000000001';
const getIndexerChainName = (chainId) => {
    if (chainId === ChainId.IMTBL_ZKEVM_MAINNET)
        return 'imtbl-zkevm-mainnet';
    if (chainId === ChainId.IMTBL_ZKEVM_TESTNET)
        return 'imtbl-zkevm-testnet';
    if (chainId === ChainId.IMTBL_ZKEVM_DEVNET)
        return 'imtbl-zkevm-devent';
    return '';
};
// Indexer ERC20 call does not support IMX so cannot get root chain mapping from this endpoint.
// Use the remote config instead to find IMX address mapping.
const getImxL1Representation = async (chainId, config) => {
    const imxMappingConfig = (await config.remote.getConfig('imxAddressMapping'));
    return imxMappingConfig[chainId] ?? '';
};
const fetchL1Representation = async (config, l2address) => {
    if (isNativeToken(l2address)) {
        return {
            l1address: await getImxL1Representation(getL1ChainId(config), config),
            l2address: NATIVE,
        };
    }
    const chainName = getIndexerChainName(getL2ChainId(config));
    const blockchainData = createBlockchainDataInstance(config);
    const tokenData = await blockchainData.getToken({
        chainName,
        contractAddress: l2address,
    });
    // TODO: When bridge is ready we need to understand how L2 ETH will be mapped back to L1 ETH
    const l1address = tokenData.result.root_contract_address;
    if (l1address === INDEXER_ETH_ROOT_CONTRACT_ADDRESS) {
        return {
            l1address: 'native',
            l2address,
        };
    }
    if (l1address === null)
        return undefined; // No L1 representation of this token
    return {
        l1address,
        l2address,
    };
};

const estimateApprovalGas = async (config, readOnlyProviders, l1provider, depositorAddress, fromChainId, toChainId, token, depositAmount) => {
    try {
        const tokenBridge = await createBridgeInstance(fromChainId, toChainId, readOnlyProviders, config);
        const { unsignedTx } = await tokenBridge.getUnsignedApproveDepositBridgeTx({
            depositorAddress,
            token,
            depositAmount,
        });
        if (unsignedTx === null)
            return BigNumber$1.from(0);
        return await l1provider.estimateGas(unsignedTx);
    }
    catch (err) {
        throw new CheckoutError('Error occurred while attempting ot estimate gas for approval transaction', CheckoutErrorType.BRIDGE_GAS_ESTIMATE_ERROR, { message: err.message });
    }
};
const estimateGasForBridgeApproval = async (config, readOnlyProviders, l1provider, depositorAddress, l1Address, delta) => {
    if (l1Address === INDEXER_ETH_ROOT_CONTRACT_ADDRESS) {
        return BigNumber$1.from(0); // Native ETH does not require approval
    }
    const fromChainId = getL1ChainId(config);
    const toChainId = getL2ChainId(config);
    return await estimateApprovalGas(config, readOnlyProviders, l1provider, depositorAddress, fromChainId, toChainId, l1Address, delta);
};

const hasSufficientL1Eth = (tokenBalanceResult, totalFees) => {
    const balance = getEthBalance(tokenBalanceResult);
    return balance.gte(totalFees);
};
const getBridgeGasEstimate = async (config, readOnlyProviders, feeEstimates) => {
    let bridgeFeeEstimate = feeEstimates.get(FundingStepType.BRIDGE);
    if (bridgeFeeEstimate) {
        return bridgeFeeEstimate;
    }
    bridgeFeeEstimate = await getBridgeFeeEstimate(config, readOnlyProviders);
    feeEstimates.set(FundingStepType.BRIDGE, bridgeFeeEstimate);
    return bridgeFeeEstimate;
};
const constructFees = (approvalGasFees, bridgeGasFees, bridgeFee) => {
    const bridgeFeeDecimals = bridgeFee.token?.decimals ?? DEFAULT_TOKEN_DECIMALS$1;
    return {
        approvalGasFees: {
            amount: approvalGasFees,
            formattedAmount: utils$1.formatUnits(approvalGasFees, DEFAULT_TOKEN_DECIMALS$1),
            token: bridgeGasFees.token,
        },
        bridgeGasFees: {
            amount: bridgeGasFees.estimatedAmount,
            formattedAmount: utils$1.formatUnits(bridgeGasFees.estimatedAmount, DEFAULT_TOKEN_DECIMALS$1),
            token: bridgeGasFees.token,
        },
        bridgeFees: [{
                amount: bridgeFee.estimatedAmount,
                formattedAmount: utils$1.formatUnits(bridgeFee.estimatedAmount, bridgeFeeDecimals),
                token: bridgeFee.token,
            }],
    };
};
const constructBridgeFundingRoute = (chainId, balance, bridgeRequirement, itemType, fees) => ({
    type: FundingStepType.BRIDGE,
    chainId,
    fundingItem: {
        type: itemType,
        fundsRequired: {
            amount: bridgeRequirement.amount,
            formattedAmount: bridgeRequirement.formattedAmount,
        },
        userBalance: {
            balance: balance.balance,
            formattedBalance: balance.formattedBalance,
        },
        token: {
            name: balance.token.name,
            symbol: balance.token.symbol,
            address: balance.token.address,
            decimals: balance.token.decimals,
        },
    },
    fees,
});
const bridgeRoute = async (config, readOnlyProviders, depositorAddress, availableRoutingOptions, bridgeRequirement, tokenBalanceResults, feeEstimates) => {
    if (!availableRoutingOptions.bridge)
        return undefined;
    const chainId = getL1ChainId(config);
    const tokenBalanceResult = tokenBalanceResults.get(chainId);
    const l1provider = readOnlyProviders.get(chainId);
    if (!l1provider) {
        throw new CheckoutError('No L1 provider available', CheckoutErrorType.PROVIDER_ERROR, { chainId: chainId.toString() });
    }
    // If no balances on layer 1 then Bridge cannot be an option
    if (tokenBalanceResult === undefined || tokenBalanceResult.success === false)
        return undefined;
    const allowedTokenList = await allowListCheckForBridge(config, tokenBalanceResults, availableRoutingOptions);
    if (allowedTokenList.length === 0)
        return undefined;
    const bridgeFeeEstimate = await getBridgeGasEstimate(config, readOnlyProviders, feeEstimates);
    // If the user has no ETH to cover the bridge fees or approval fees then bridge cannot be an option
    if (!hasSufficientL1Eth(tokenBalanceResult, bridgeFeeEstimate.totalFees))
        return undefined;
    const l1RepresentationResult = await fetchL1Representation(config, bridgeRequirement.l2address);
    if (!l1RepresentationResult)
        return undefined;
    // Ensure l1address is in the allowed token list
    const { l1address } = l1RepresentationResult;
    if (isNativeToken(l1address)) {
        if (!allowedTokenList.find((token) => !('address' in token)))
            return undefined;
    }
    else if (!allowedTokenList.find((token) => token.address === l1address)) {
        return undefined;
    }
    const gasForApproval = await estimateGasForBridgeApproval(config, readOnlyProviders, l1provider, depositorAddress, l1address, bridgeRequirement.amount);
    let totalFees = bridgeFeeEstimate.bridgeFee.estimatedAmount;
    // If the L1 representation of the requirement is ETH then find the ETH balance and check if the balance covers the delta
    if (isNativeToken(l1address)) {
        const nativeETHBalance = tokenBalanceResult.balances
            .find((balance) => isNativeToken(balance.token.address));
        if (bridgeFeeEstimate.gasFee.estimatedAmount) {
            totalFees = totalFees.add(bridgeFeeEstimate.gasFee.estimatedAmount);
        }
        if (!hasSufficientL1Eth(tokenBalanceResult, totalFees))
            return undefined;
        if (nativeETHBalance && nativeETHBalance.balance.gte(bridgeRequirement.amount.add(totalFees))) {
            const bridgeFees = constructFees(gasForApproval, bridgeFeeEstimate.gasFee, bridgeFeeEstimate.bridgeFee);
            return constructBridgeFundingRoute(chainId, nativeETHBalance, bridgeRequirement, ItemType.NATIVE, bridgeFees);
        }
        return undefined;
    }
    totalFees.add(gasForApproval).add(bridgeFeeEstimate.gasFee.estimatedAmount);
    if (!hasSufficientL1Eth(tokenBalanceResult, totalFees))
        return undefined;
    // Find the balance of the L1 representation of the token and check if the balance covers the delta
    const erc20balance = tokenBalanceResult.balances.find((balance) => balance.token.address === l1address);
    if (erc20balance && erc20balance.balance.gte(bridgeRequirement.amount)) {
        const bridgeFees = constructFees(gasForApproval, bridgeFeeEstimate.gasFee, bridgeFeeEstimate.bridgeFee);
        return constructBridgeFundingRoute(chainId, erc20balance, bridgeRequirement, ItemType.ERC20, bridgeFees);
    }
    return undefined;
};

const getBalancesByChain = (config, tokenBalances) => {
    const balances = { l1balances: [], l2balances: [] };
    const l1balancesResult = tokenBalances.get(getL1ChainId(config));
    const l2balancesResult = tokenBalances.get(getL2ChainId(config));
    // If there are no l1 balance then cannot bridge
    if (!l1balancesResult)
        return balances;
    if (l1balancesResult.error !== undefined)
        return balances;
    if (!l1balancesResult.success)
        return balances;
    // If there are no l2 balance then cannot swap
    if (!l2balancesResult)
        return balances;
    if (l2balancesResult.error !== undefined)
        return balances;
    if (!l2balancesResult.success)
        return balances;
    const l1balances = l1balancesResult.balances;
    const l2balances = l2balancesResult.balances;
    return { l1balances, l2balances };
};

// The dex will return all the fees which is in a particular token (currently always IMX)
// If any of the fees are in the same token that is trying to be swapped (e.g. trying to swap IMX)
// then these fees need to be added to the amount to bridge, otherwise not enough of the token
// will be bridged over to cover the amount to swap and any fees associated with the swap
const getFeesForTokenAddress = (dexQuote, tokenAddress) => {
    let fees = BigNumber$1.from(0);
    dexQuote.quote.fees.forEach((fee) => {
        if (fee.amount.token.address === tokenAddress) {
            fees = fees.add(fee.amount.value);
        }
    });
    if (dexQuote.approval) {
        if (dexQuote.approval.token.address === tokenAddress) {
            fees = fees.add(dexQuote.approval.value);
        }
    }
    return fees;
};
// The token that is being bridged may also be a balance requirement
// Since this token is going to be swapped after bridging then get
// the amount of the current balance requirement
const getAmountFromBalanceRequirement = (balanceRequirements, quotedTokenAddress) => {
    // Find if there is an existing balance requirement of the token attempting to be bridged->swapped
    for (const requirement of balanceRequirements.balanceRequirements) {
        if (requirement.type === ItemType.NATIVE || requirement.type === ItemType.ERC20) {
            if (requirement.required.token.address === quotedTokenAddress) {
                return requirement.required.balance;
            }
        }
    }
    return BigNumber$1.from(0);
};
// Get the total amount to bridge factoring in any balance requirements
// of this token and the current balance on L2
const getAmountToBridge = (quotedAmountWithFees, amountFromBalanceRequirement, l2balance) => {
    const balance = l2balance?.balance ?? BigNumber$1.from(0);
    // Balance is fully covered and does not require bridging
    // then the one swap route will be suggested
    if (balance.gte(quotedAmountWithFees.add(amountFromBalanceRequirement))) {
        return BigNumber$1.from(0);
    }
    // If no balance on L2 then bridge full amount and balance requirement amount if any
    if (balance.lte(0)) {
        return quotedAmountWithFees.add(amountFromBalanceRequirement);
    }
    // Get the remainder from the balance after subtracting the balance requirement amount
    const remainder = balance.sub(amountFromBalanceRequirement);
    // Remove the remainder from the amount needed as the user has some balance left over
    // after covering the balance requirement or the remainder is 0 indicating they have
    // just enough to cover the balance requirement
    if (remainder.gte(0)) {
        return quotedAmountWithFees.sub(remainder);
    }
    // If the remainder is less than 0 then add the quoted amount with the balance requirement
    // and sub the users current balance to get the total amount needed to be bridged to cover
    // the quoted amount + balance requirement
    return quotedAmountWithFees.add(amountFromBalanceRequirement).sub(balance);
};
// to be sent to the bridge route
const constructBridgeRequirements = (dexQuotes, l1balances, l2balances, l1tol2addresses, balanceRequirements) => {
    const bridgeRequirements = [];
    for (const [tokenAddress, quote] of dexQuotes) {
        // Get the L2 balance for the token address
        const l2balance = l2balances.find((balance) => balance.token.address === tokenAddress);
        const l1tol2TokenMapping = l1tol2addresses.find((token) => token.l2address === tokenAddress);
        if (!l1tol2TokenMapping)
            continue;
        const { l1address, l2address } = l1tol2TokenMapping;
        if (!l1address)
            continue;
        // If the user does not have any L1 balance for this token then cannot bridge
        const l1balance = l1balances.find((balance) => {
            if (balance.token.address === undefined
                && l1address === INDEXER_ETH_ROOT_CONTRACT_ADDRESS) {
                return true;
            }
            return balance.token.address === l1address;
        });
        if (!l1balance)
            continue;
        // Get the total amount using slippage to ensure a small buffer is added to cover price fluctuations
        const quotedAmount = quote.quote.amountWithMaxSlippage.value;
        // Add fees to the quoted amount if the fees are in the same token as the token being swapped
        const fees = getFeesForTokenAddress(quote, tokenAddress);
        const quotedAmountWithFees = quotedAmount.add(fees);
        // Get the amount from the balance requirement if the token is also a balance requirement
        const amountFromBalanceRequirement = getAmountFromBalanceRequirement(balanceRequirements, tokenAddress);
        // Get the amount to bridge factoring in any balance requirements for this swappable token
        // and the current balance on L2
        const amountToBridge = getAmountToBridge(quotedAmountWithFees, amountFromBalanceRequirement, l2balance);
        // No amount to bridge as user has sufficient balance for one swap
        if (amountToBridge.lte(0)) {
            continue;
        }
        // If the amount to bridge is greater than the L1 balance then cannot bridge
        if (amountToBridge.gte(l1balance.balance)) {
            continue;
        }
        bridgeRequirements.push({
            amount: amountToBridge,
            formattedAmount: utils$1.formatUnits(amountToBridge, l1balance.token.decimals),
            // L2 address is used for the bridge requirement as the bridge route uses the indexer to find L1 address
            l2address,
        });
    }
    return bridgeRequirements;
};

const fetchL1ToL2Mappings = async (config, swappableTokens) => {
    const l1tol2addressMappingPromises = swappableTokens
        .map((token) => fetchL1Representation(config, token.address ?? ''));
    const mappings = await Promise.all(l1tol2addressMappingPromises);
    return mappings.filter((mapping) => mapping !== undefined);
};

// Fetch all the dex quotes from the list of swappable tokens
const getDexQuotes = async (config, ownerAddress, requiredTokenAddress, insufficientRequirement, filteredSwappableTokens) => {
    const filteredSwappableTokensAddresses = [];
    for (const token of filteredSwappableTokens) {
        if (!token.address)
            continue;
        filteredSwappableTokensAddresses.push(token.address);
    }
    const dexQuotes = await quoteFetcher(config, getL2ChainId(config), ownerAddress, {
        address: requiredTokenAddress,
        amount: insufficientRequirement.delta.balance,
    }, filteredSwappableTokensAddresses);
    return dexQuotes;
};

const abortBridgeAndSwap = (bridgeableTokens, swappableTokens, l1balances, l2balances, availableRoutingOptions, requiredTokenAddress) => {
    if (bridgeableTokens.length === 0)
        return true;
    if (swappableTokens.length === 0)
        return true;
    if (l1balances.length === 0)
        return true;
    if (l2balances.length === 0)
        return true;
    if (!availableRoutingOptions.bridge)
        return true;
    if (!availableRoutingOptions.swap)
        return true;
    if (requiredTokenAddress === undefined)
        return true;
    if (requiredTokenAddress === '')
        return true;
    return false;
};
const filterSwappableTokensByBridgeableAddresses = (requiredTokenAddress, bridgeableTokens, swappableTokens, l1tol2Addresses) => {
    const filteredSwappableTokens = [];
    for (const addresses of l1tol2Addresses) {
        // TODO: Check for ETH (native) L1 in bridgeableTokens first
        if (!bridgeableTokens.includes(addresses.l1address))
            continue;
        // Filter out the token that is required from the swappable tokens list
        if (addresses.l2address === requiredTokenAddress)
            continue;
        const tokenInfo = swappableTokens.find((token) => token.address === addresses.l2address);
        if (!tokenInfo)
            continue;
        filteredSwappableTokens.push(tokenInfo);
    }
    return filteredSwappableTokens;
};
// Modifies a users balance to include the amount as if the user successfully bridged
// This is so the swap route can check against the balance once the user has performed a bridge
const modifyTokenBalancesWithBridgedAmount = (config, tokenBalances, l2balances, bridgedTokens, swappableTokens) => {
    const modifiedTokenBalances = new Map();
    for (const [chainId, tokenBalance] of tokenBalances) {
        modifiedTokenBalances.set(chainId, {
            success: tokenBalance.success,
            balances: tokenBalance.balances,
        });
    }
    // Construct a map of balances to the L2 token address to make
    // it easier to adjust the balances for the tokens that can be bridged
    const balanceMap = new Map();
    for (const balance of l2balances) {
        if (!balance.token.address)
            continue;
        balanceMap.set(balance.token.address, balance);
    }
    // Go through each of the tokens that can be bridged
    // and adjust the balances to fake the bridge
    for (const bridgedToken of bridgedTokens) {
        const { amount, l2address } = bridgedToken;
        if (l2address === '')
            continue;
        let l2balance = BigNumber$1.from(0);
        // Find the current balance of this token
        const currentBalance = balanceMap.get(l2address);
        if (currentBalance)
            l2balance = currentBalance.balance;
        const newBalance = l2balance.add(amount);
        const tokenInfo = swappableTokens.find((token) => token.address === l2address);
        balanceMap.set(l2address, {
            balance: newBalance,
            formattedBalance: utils$1.formatUnits(newBalance, tokenInfo.decimals),
            token: tokenInfo,
        });
    }
    const updatedBalances = Array.from(balanceMap.values());
    modifiedTokenBalances.set(getL2ChainId(config), {
        success: true,
        balances: updatedBalances,
    });
    return modifiedTokenBalances;
};
// Reapply the original swap balances after the
// swap route was modified to fake the bridge
const reapplyOriginalSwapBalances = (tokenBalances, swapRoutes) => {
    const originalSwapSteps = [];
    for (const route of swapRoutes) {
        const { chainId, fundingItem } = route;
        const { userBalance } = route.fundingItem;
        const tokenBalance = tokenBalances.get(chainId);
        if (!tokenBalance)
            continue;
        let originalBalance = BigNumber$1.from(0);
        let originalFormattedBalance = '0';
        const l2balance = tokenBalance.balances.find((balance) => balance.token.address === fundingItem.token.address);
        if (l2balance) {
            originalBalance = l2balance.balance;
            originalFormattedBalance = l2balance.formattedBalance;
        }
        userBalance.balance = originalBalance;
        userBalance.formattedBalance = originalFormattedBalance;
        originalSwapSteps.push(route);
    }
    return originalSwapSteps;
};
const constructBridgeAndSwapRoutes = (bridgeFundingSteps, swapFundingSteps, l1tol2Addresses) => {
    const bridgeAndSwapRoutes = [];
    for (const bridgeFundingStep of bridgeFundingSteps) {
        if (!bridgeFundingStep)
            continue;
        const mapping = l1tol2Addresses.find((addresses) => {
            if (bridgeFundingStep.fundingItem.token.address === undefined) {
                return addresses.l1address === INDEXER_ETH_ROOT_CONTRACT_ADDRESS && addresses.l2address;
            }
            return addresses.l1address === bridgeFundingStep.fundingItem.token.address && addresses.l2address;
        });
        if (!mapping)
            continue;
        const swapFundingStep = swapFundingSteps.find((step) => step.fundingItem.token.address === mapping.l2address);
        if (!swapFundingStep)
            continue;
        bridgeAndSwapRoutes.push({
            bridgeFundingStep,
            swapFundingStep,
        });
    }
    return bridgeAndSwapRoutes;
};
const bridgeAndSwapRoute = async (config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, feeEstimates, tokenBalances, bridgeableTokens, swappableTokens, balanceRequirements) => {
    const { l1balances, l2balances } = getBalancesByChain(config, tokenBalances);
    const requiredTokenAddress = insufficientRequirement.required.token.address;
    if (abortBridgeAndSwap(bridgeableTokens, swappableTokens, l1balances, l2balances, availableRoutingOptions, requiredTokenAddress))
        return [];
    // Fetch L2 to L1 address mapping and based on the L1 address existing then
    // filter the bridgeable and swappable tokens list further to only include
    // tokens that can be both swapped and bridged
    const l1tol2Addresses = await fetchL1ToL2Mappings(config, swappableTokens);
    const filteredSwappableTokens = filterSwappableTokensByBridgeableAddresses(requiredTokenAddress, bridgeableTokens, swappableTokens, l1tol2Addresses);
    if (filteredSwappableTokens.length === 0)
        return [];
    // Fetch all the dex quotes from the list of swappable tokens
    const dexQuotes = await getDexQuotes(config, ownerAddress, requiredTokenAddress, insufficientRequirement, filteredSwappableTokens);
    // Construct bridge requirements based on L2 balances, slippage and swap fees
    const bridgeRequirements = constructBridgeRequirements(dexQuotes, l1balances, l2balances, l1tol2Addresses, balanceRequirements);
    if (bridgeRequirements.length === 0)
        return [];
    // Create a mapping of bridge routes to L2 addresses
    const bridgePromises = new Map();
    // Create map of bridgeable tokens to make it easier to get the amount that was bridged when modifying the users balance later
    const bridgeableRequirementsMap = new Map();
    const bridgedTokens = [];
    for (const bridgeRequirement of bridgeRequirements) {
        if (!bridgeRequirement.l2address)
            continue;
        bridgePromises.set(bridgeRequirement.l2address, bridgeRoute(config, readOnlyProviders, ownerAddress, availableRoutingOptions, bridgeRequirement, tokenBalances, feeEstimates));
        bridgeableRequirementsMap.set(bridgeRequirement.l2address, {
            amount: bridgeRequirement.amount,
            formattedAmount: bridgeRequirement.formattedAmount,
            l2address: bridgeRequirement.l2address,
        });
    }
    const bridgeResults = await Promise.all(bridgePromises.values());
    const bridgeKeys = Array.from(bridgePromises.keys());
    // Create an array to store all the tokens that are able to be bridged
    const swappableTokensAfterBridging = [];
    // Iterate through all the bridge route results
    // If a bridge route result was successful then add this token to the
    // list of tokens that should be checked with the swap route
    bridgeResults.forEach((result, index) => {
        const key = bridgeKeys[index];
        if (result === undefined)
            return;
        swappableTokensAfterBridging.push(key);
        const bridgedToken = bridgeableRequirementsMap.get(key);
        if (!bridgedToken)
            return;
        bridgedTokens.push({
            amount: bridgedToken.amount,
            formattedAmount: bridgedToken.formattedAmount,
            l2address: bridgedToken.l2address,
        });
    });
    // Bridge route determined that no tokens could be bridged
    if (swappableTokensAfterBridging.length === 0)
        return [];
    if (bridgedTokens.length === 0)
        return []; // No tokens were bridged
    // Modify the users L2 balance to include the amount as if the user successfully bridged
    const modifiedTokenBalances = modifyTokenBalancesWithBridgedAmount(config, tokenBalances, l2balances, bridgedTokens, swappableTokens);
    // Call the swap route with the faked bridged balances
    const swapRoutes = await swapRoute(config, availableRoutingOptions, ownerAddress, insufficientRequirement, modifiedTokenBalances, swappableTokensAfterBridging, balanceRequirements);
    if (!swapRoutes)
        return [];
    const originalBalanceSwapRoutes = reapplyOriginalSwapBalances(tokenBalances, swapRoutes);
    return constructBridgeAndSwapRoutes(bridgeResults, originalBalanceSwapRoutes, l1tol2Addresses);
};

const onRampRoute = async (config, availableRoutingOptions, balanceRequirement) => {
    if (balanceRequirement.type !== ItemType.ERC20 && balanceRequirement.type !== ItemType.NATIVE)
        return undefined;
    const { required, current, delta } = balanceRequirement;
    let hasAllowList = false;
    const onRampProvidersAllowList = await allowListCheckForOnRamp(config, availableRoutingOptions);
    Object.values(onRampProvidersAllowList).forEach((onRampAllowList) => {
        if (onRampAllowList.length > 0 && !hasAllowList) {
            hasAllowList = !!onRampAllowList.find((token) => token.address === required.token?.address);
        }
    });
    if (!hasAllowList)
        return undefined;
    return {
        type: FundingStepType.ONRAMP,
        chainId: getL2ChainId(config),
        fundingItem: {
            type: isNativeToken(required.token.address) ? ItemType.NATIVE : ItemType.ERC20,
            fundsRequired: {
                amount: delta.balance,
                formattedAmount: delta.formattedBalance,
            },
            userBalance: {
                balance: current.balance,
                formattedBalance: current.formattedBalance,
            },
            token: required.token,
        },
    };
};

const hasAvailableRoutingOptions = (availableRoutingOptions) => (availableRoutingOptions.bridge || availableRoutingOptions.swap || availableRoutingOptions.onRamp);
const getInsufficientRequirement = (balanceRequirements) => {
    let insufficientBalanceCount = 0;
    let insufficientRequirement;
    for (const balanceRequirement of balanceRequirements.balanceRequirements) {
        if (!balanceRequirement.sufficient) {
            insufficientBalanceCount++;
            insufficientRequirement = balanceRequirement;
        }
    }
    if (insufficientBalanceCount === 1)
        return insufficientRequirement;
    return undefined;
};
const getBridgeFundingStep = async (config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, feeEstimates) => {
    let bridgeFundingStep;
    if (insufficientRequirement === undefined)
        return undefined;
    if (insufficientRequirement.type !== ItemType.NATIVE && insufficientRequirement.type !== ItemType.ERC20) {
        return undefined;
    }
    const bridgeRequirement = {
        amount: insufficientRequirement.delta.balance,
        formattedAmount: insufficientRequirement.delta.formattedBalance,
        l2address: insufficientRequirement.required.token.address ?? '',
    };
    if (availableRoutingOptions.bridge && insufficientRequirement) {
        bridgeFundingStep = await bridgeRoute(config, readOnlyProviders, ownerAddress, availableRoutingOptions, bridgeRequirement, tokenBalances, feeEstimates);
    }
    return bridgeFundingStep;
};
const getSwapFundingSteps = async (config, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, swapTokenAllowList, balanceRequirements) => {
    const fundingSteps = [];
    if (!availableRoutingOptions.swap)
        return fundingSteps;
    if (insufficientRequirement === undefined)
        return fundingSteps;
    if (swapTokenAllowList === undefined)
        return fundingSteps;
    const tokenBalanceResult = tokenBalances.get(getL2ChainId(config));
    if (!tokenBalanceResult)
        return fundingSteps;
    if (tokenBalanceResult.error !== undefined || !tokenBalanceResult.success)
        return fundingSteps;
    if (swapTokenAllowList.length === 0)
        return fundingSteps;
    const swappableTokens = swapTokenAllowList
        .filter((token) => token.address).map((token) => token.address);
    if (swappableTokens.length === 0)
        return fundingSteps;
    return await swapRoute(config, availableRoutingOptions, ownerAddress, insufficientRequirement, tokenBalances, swappableTokens, balanceRequirements);
};
const getBridgeAndSwapFundingSteps = async (config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, tokenAllowList, feeEstimates, balanceRequirements) => {
    if (!insufficientRequirement)
        return [];
    const l1balancesResult = tokenBalances.get(getL1ChainId(config));
    const l2balancesResult = tokenBalances.get(getL2ChainId(config));
    // If there are no l1 balance then cannot bridge
    if (!l1balancesResult)
        return [];
    if (l1balancesResult.error !== undefined || !l1balancesResult.success)
        return [];
    // If there are no l2 balance then cannot swap
    if (!l2balancesResult)
        return [];
    if (l2balancesResult.error !== undefined || !l2balancesResult.success)
        return [];
    // Get a list of all the swappable tokens
    const bridgeTokenAllowList = tokenAllowList?.bridge ?? [];
    const bridgeableL1Addresses = bridgeTokenAllowList.map((token) => {
        if (token.address === undefined)
            return INDEXER_ETH_ROOT_CONTRACT_ADDRESS;
        return token.address;
    });
    const swapTokenAllowList = tokenAllowList?.swap ?? [];
    if (insufficientRequirement.type !== ItemType.NATIVE && insufficientRequirement.type !== ItemType.ERC20) {
        return [];
    }
    const routes = await bridgeAndSwapRoute(config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, feeEstimates, tokenBalances, bridgeableL1Addresses, swapTokenAllowList, balanceRequirements);
    return routes;
};
const getOnRampFundingStep = async (config, availableRoutingOptions, insufficientRequirement) => {
    if (!availableRoutingOptions.onRamp)
        return undefined;
    if (insufficientRequirement === undefined)
        return undefined;
    const onRampFundingStep = await onRampRoute(config, availableRoutingOptions, insufficientRequirement);
    return onRampFundingStep;
};
const routingCalculator = async (config, ownerAddress, balanceRequirements, availableRoutingOptions) => {
    if (!hasAvailableRoutingOptions(availableRoutingOptions)) {
        return {
            type: RoutingOutcomeType.NO_ROUTE_OPTIONS,
            message: 'No routing options are available',
        };
    }
    let readOnlyProviders;
    try {
        readOnlyProviders = await createReadOnlyProviders(config);
    }
    catch (err) {
        throw new CheckoutError('Error occurred while creating read only providers', CheckoutErrorType.PROVIDER_ERROR, { message: err.message });
    }
    const tokenBalances = await measureAsyncExecution(config, 'Time to get token balances inside router', getAllTokenBalances(config, readOnlyProviders, ownerAddress, availableRoutingOptions));
    const allowList = await measureAsyncExecution(config, 'Time to get routing allowlist', allowListCheck(config, tokenBalances, availableRoutingOptions));
    // Fee estimate cache
    const feeEstimates = new Map();
    // Ensures only 1 balance requirement is insufficient
    const insufficientRequirement = getInsufficientRequirement(balanceRequirements);
    const routePromises = [];
    routePromises.push(getBridgeFundingStep(config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, feeEstimates));
    routePromises.push(getSwapFundingSteps(config, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, allowList.swap, balanceRequirements));
    routePromises.push(getOnRampFundingStep(config, availableRoutingOptions, insufficientRequirement));
    routePromises.push(getBridgeAndSwapFundingSteps(config, readOnlyProviders, availableRoutingOptions, insufficientRequirement, ownerAddress, tokenBalances, allowList, feeEstimates, balanceRequirements));
    const resolved = await measureAsyncExecution(config, 'Time to resolve all routes', Promise.all(routePromises));
    let bridgeFundingStep;
    let swapFundingSteps = [];
    let onRampFundingStep;
    let bridgeAndSwapFundingSteps = [];
    resolved.forEach((result, index) => {
        if (index === 0)
            bridgeFundingStep = result;
        if (index === 1)
            swapFundingSteps = result;
        if (index === 2)
            onRampFundingStep = result;
        if (index === 3)
            bridgeAndSwapFundingSteps = result;
    });
    if (!bridgeFundingStep
        && swapFundingSteps.length === 0
        && !onRampFundingStep
        && bridgeAndSwapFundingSteps.length === 0) {
        return {
            type: RoutingOutcomeType.NO_ROUTES_FOUND,
            message: 'Smart Checkout did not find any funding routes to fulfill the transaction',
        };
    }
    const response = {
        type: RoutingOutcomeType.ROUTES_FOUND,
        fundingRoutes: [],
    };
    let priority = 0;
    if (swapFundingSteps.length > 0) {
        priority++;
        swapFundingSteps.forEach((swapFundingStep) => {
            response.fundingRoutes.push({
                priority,
                steps: [swapFundingStep],
            });
        });
    }
    if (bridgeFundingStep) {
        priority++;
        response.fundingRoutes.push({
            priority,
            steps: [bridgeFundingStep],
        });
    }
    if (onRampFundingStep) {
        priority++;
        response.fundingRoutes.push({
            priority,
            steps: [onRampFundingStep],
        });
    }
    if (bridgeAndSwapFundingSteps) {
        priority++;
        bridgeAndSwapFundingSteps.forEach((bridgeAndSwapFundingStep) => {
            const bridgeStep = bridgeAndSwapFundingStep.bridgeFundingStep;
            const swapStep = bridgeAndSwapFundingStep.swapFundingStep;
            response.fundingRoutes.push({
                priority,
                steps: [bridgeStep, swapStep],
            });
        });
    }
    return response;
};

const smartCheckout = async (config, provider, itemRequirements, transactionOrGasAmount) => {
    const ownerAddress = await provider.getSigner().getAddress();
    let aggregatedItems = itemAggregator(itemRequirements);
    const erc20AllowancePromise = hasERC20Allowances(provider, ownerAddress, aggregatedItems);
    const erc721AllowancePromise = hasERC721Allowances(provider, ownerAddress, aggregatedItems);
    const resolvedAllowances = await measureAsyncExecution(config, 'Time to calculate token allowances', Promise.all([erc20AllowancePromise, erc721AllowancePromise]));
    const aggregatedAllowances = allowanceAggregator(resolvedAllowances[0], resolvedAllowances[1]);
    const gasItem = await measureAsyncExecution(config, 'Time to run gas calculator', gasCalculator(provider, aggregatedAllowances, transactionOrGasAmount));
    if (gasItem !== null) {
        aggregatedItems.push(gasItem);
        aggregatedItems = itemAggregator(aggregatedItems);
    }
    const balanceCheckResult = await measureAsyncExecution(config, 'Time to run balance checks', balanceCheck(config, provider, ownerAddress, aggregatedItems));
    const { sufficient } = balanceCheckResult;
    const transactionRequirements = balanceCheckResult.balanceRequirements;
    if (sufficient) {
        return {
            sufficient,
            transactionRequirements,
        };
    }
    const availableRoutingOptions = await measureAsyncExecution(config, 'Time to fetch available routing options', getAvailableRoutingOptions(config, provider));
    const routingOutcome = await measureAsyncExecution(config, 'Total time to run the routing calculator', routingCalculator(config, ownerAddress, balanceCheckResult, availableRoutingOptions));
    return {
        sufficient,
        transactionRequirements,
        router: {
            availableRoutingOptions,
            routingOutcome,
        },
    };
};

var SignTransactionStatusType;
(function (SignTransactionStatusType) {
    SignTransactionStatusType["SUCCESS"] = "SUCCESS";
    SignTransactionStatusType["FAILED"] = "FAILED";
})(SignTransactionStatusType || (SignTransactionStatusType = {}));

const signApprovalTransactions = async (provider, approvalTransactions) => {
    let receipts = [];
    try {
        const response = await Promise.all(approvalTransactions.map((transaction) => sendTransaction(provider, transaction)));
        receipts = await Promise.all(response.map((transaction) => transaction.transactionResponse.wait()));
    }
    catch (err) {
        throw new CheckoutError('An error occurred while executing the approval transaction', CheckoutErrorType.EXECUTE_APPROVAL_TRANSACTION_ERROR, {
            message: err.message,
        });
    }
    for (const receipt of receipts) {
        if (receipt.status === 0) {
            return {
                type: SignTransactionStatusType.FAILED,
                transactionHash: receipt.transactionHash,
                reason: 'Approval transaction failed and was reverted',
            };
        }
    }
    return {
        type: SignTransactionStatusType.SUCCESS,
    };
};
const signFulfillmentTransactions = async (provider, fulfillmentTransactions) => {
    let receipts = [];
    try {
        const response = await Promise.all(fulfillmentTransactions.map((transaction) => sendTransaction(provider, transaction)));
        receipts = await Promise.all(response.map((transaction) => transaction.transactionResponse.wait()));
    }
    catch (err) {
        throw new CheckoutError('An error occurred while executing the fulfillment transaction', CheckoutErrorType.EXECUTE_FULFILLMENT_TRANSACTION_ERROR, {
            message: err.message,
        });
    }
    for (const receipt of receipts) {
        if (receipt.status === 0) {
            return {
                type: SignTransactionStatusType.FAILED,
                transactionHash: receipt.transactionHash,
                reason: 'Fulfillment transaction failed and was reverted',
            };
        }
    }
    return {
        type: SignTransactionStatusType.SUCCESS,
    };
};
const signMessage = async (provider, unsignedMessage) => {
    try {
        // eslint-disable-next-line no-underscore-dangle
        const signedMessage = await provider.getSigner()._signTypedData(unsignedMessage.unsignedMessage.domain, unsignedMessage.unsignedMessage.types, unsignedMessage.unsignedMessage.value);
        return {
            orderComponents: unsignedMessage.orderComponents,
            orderHash: unsignedMessage.orderHash,
            signedMessage,
        };
    }
    catch (err) {
        throw new CheckoutError('An error occurred while signing the message', CheckoutErrorType.SIGN_MESSAGE_ERROR, {
            message: err.message,
        });
    }
};

const getUnsignedERC721Transactions = async (actions) => {
    let approvalTransactions = [];
    let fulfillmentTransactions = [];
    const approvalPromises = [];
    const fulfillmentPromises = [];
    for (const action of actions) {
        if (action.type !== ActionType.TRANSACTION)
            continue;
        if (action.purpose === TransactionPurpose.APPROVAL) {
            approvalPromises.push(action.buildTransaction());
        }
        if (action.purpose === TransactionPurpose.FULFILL_ORDER) {
            fulfillmentPromises.push(action.buildTransaction());
        }
    }
    approvalTransactions = await Promise.all(approvalPromises);
    fulfillmentTransactions = await Promise.all(fulfillmentPromises);
    return {
        approvalTransactions,
        fulfillmentTransactions,
    };
};
const getUnsignedERC20ApprovalTransactions = async (actions) => {
    let approvalTransactions = [];
    const approvalPromises = [];
    for (const action of actions) {
        if (action.type !== ActionType.TRANSACTION)
            continue;
        if (action.purpose === TransactionPurpose.APPROVAL) {
            approvalPromises.push(action.buildTransaction());
        }
    }
    approvalTransactions = await Promise.all(approvalPromises);
    return approvalTransactions;
};
const getUnsignedFulfillmentTransactions = async (actions) => {
    let fulfillmentTransactions = [];
    const fulfillmentPromises = [];
    for (const action of actions) {
        if (action.type !== ActionType.TRANSACTION)
            continue;
        if (action.purpose === TransactionPurpose.FULFILL_ORDER) {
            fulfillmentPromises.push(action.buildTransaction());
        }
    }
    fulfillmentTransactions = await Promise.all(fulfillmentPromises);
    return fulfillmentTransactions;
};
const getUnsignedMessage = (orderHash, orderComponents, actions) => {
    let unsignedMessage;
    for (const action of actions) {
        if (action.type !== ActionType.SIGNABLE)
            continue;
        if (action.purpose === SignablePurpose.CREATE_LISTING) {
            unsignedMessage = {
                domain: action.message.domain,
                types: action.message.types,
                value: action.message.value,
            };
        }
    }
    if (!unsignedMessage)
        return undefined;
    return {
        orderHash,
        orderComponents,
        unsignedMessage,
    };
};

const MAX_FEE_PERCENTAGE_DECIMAL = 1; // 100%
const MAX_FEE_DECIMAL_PLACES = 6; // will allow 0.000001 (0.0001%) as the minimum value
const calculateFeesPercent = (orderFee, amountBn) => {
    const feePercentage = orderFee.amount;
    // note: multiply in and out of the maximum decimal places to the power of ten to do the math in big number integers
    const feePercentageMultiplier = Math.round(feePercentage.percentageDecimal * (10 ** MAX_FEE_DECIMAL_PLACES));
    const bnFeeAmount = amountBn
        .mul(BigNumber$1.from(feePercentageMultiplier))
        .div(10 ** MAX_FEE_DECIMAL_PLACES);
    return bnFeeAmount;
};
const calculateFeesToken = (orderFee, decimals) => {
    const feeToken = orderFee.amount;
    const bnFeeAmount = utils$1.parseUnits(feeToken.token, decimals);
    return bnFeeAmount;
};
const calculateFees = (orderFees, weiAmount, decimals = 18) => {
    let totalTokenFees = BigNumber$1.from(0);
    const amountBn = BigNumber$1.from(weiAmount);
    // note: multiply in and out of the maximum decimal places to the power of ten to do the math in big number integers
    const totalAllowableFees = amountBn
        .mul(MAX_FEE_PERCENTAGE_DECIMAL * (10 ** MAX_FEE_DECIMAL_PLACES))
        .div(10 ** MAX_FEE_DECIMAL_PLACES);
    const calculateFeesResult = [];
    for (const orderFee of orderFees) {
        let currentFeeBn = BigNumber$1.from(0);
        if (Object.hasOwn(orderFee.amount, 'percentageDecimal')) {
            currentFeeBn = calculateFeesPercent(orderFee, amountBn);
            totalTokenFees = totalTokenFees.add(currentFeeBn);
        }
        else if (Object.hasOwn(orderFee.amount, 'token')) {
            currentFeeBn = calculateFeesToken(orderFee, decimals);
            totalTokenFees = totalTokenFees.add(currentFeeBn);
        }
        else {
            throw new CheckoutError('Unknown fee type parsed, must be percentageDecimal or token', CheckoutErrorType.ORDER_FEE_ERROR);
        }
        if (totalTokenFees.gt(totalAllowableFees)) {
            throw new CheckoutError(`The combined fees are above the allowed maximum of ${MAX_FEE_PERCENTAGE_DECIMAL * 100}%`, CheckoutErrorType.ORDER_FEE_ERROR);
        }
        if (currentFeeBn.gt(0)) {
            calculateFeesResult.push({
                amount: currentFeeBn.toString(),
                recipientAddress: orderFee.recipient,
            });
        }
    } // for
    return calculateFeesResult;
};

const getItemRequirement = (type, contractAddress, amount, spenderAddress) => {
    switch (type) {
        case ItemType.ERC20:
            return {
                type,
                amount,
                contractAddress,
                spenderAddress,
            };
        case ItemType.NATIVE:
        default:
            return {
                type: ItemType.NATIVE,
                amount,
            };
    }
};
const getTransactionOrGas = (gasLimit, fulfillmentTransactions) => {
    if (fulfillmentTransactions.length > 0) {
        return {
            type: TransactionOrGasType.TRANSACTION,
            transaction: fulfillmentTransactions[0],
        };
    }
    return {
        type: TransactionOrGasType.GAS,
        gasToken: {
            type: GasTokenType.NATIVE,
            limit: BigNumber$1.from(gasLimit),
        },
    };
};
const buy = async (config, provider, orders) => {
    if (orders.length === 0) {
        throw new CheckoutError('No orders were provided to the orders array. Please provide at least one order.', CheckoutErrorType.FULFILL_ORDER_LISTING_ERROR);
    }
    let order;
    let spenderAddress = '';
    let decimals = 18;
    const gasLimit = constants.estimatedFulfillmentGasGwei;
    const orderbook = createOrderbookInstance(config);
    const blockchainClient = createBlockchainDataInstance(config);
    const fulfillerAddress = await measureAsyncExecution(config, 'Time to get the address from the provider', provider.getSigner().getAddress());
    // Prefetch balances and store them in memory
    resetBlockscoutClientMap();
    getAllBalances(config, provider, fulfillerAddress, getL1ChainId(config));
    getAllBalances(config, provider, fulfillerAddress, getL2ChainId(config));
    const { id, takerFees } = orders[0];
    let orderChainName;
    try {
        order = await measureAsyncExecution(config, 'Time to fetch the listing from the orderbook', orderbook.getListing(id));
        const { seaportContractAddress, chainName } = orderbook.config();
        orderChainName = chainName;
        spenderAddress = seaportContractAddress;
    }
    catch (err) {
        throw new CheckoutError('An error occurred while getting the order listing', CheckoutErrorType.GET_ORDER_LISTING_ERROR, {
            orderId: id,
            message: err.message,
        });
    }
    if (order.result.buy.length === 0) {
        throw new CheckoutError('An error occurred with the get order listing', CheckoutErrorType.GET_ORDER_LISTING_ERROR, {
            orderId: id,
            message: 'No buy side tokens found on order',
        });
    }
    const buyToken = order.result.buy[0];
    if (buyToken.type === 'ERC20') {
        const token = await measureAsyncExecution(config, 'Time to get decimals of token contract for the buy token', blockchainClient.getToken({ contractAddress: buyToken.contractAddress, chainName: orderChainName }));
        if (token.result.decimals)
            decimals = token.result.decimals;
    }
    let fees = [];
    if (takerFees && takerFees.length > 0) {
        fees = calculateFees(takerFees, buyToken.amount, decimals);
    }
    let unsignedApprovalTransactions = [];
    let unsignedFulfillmentTransactions = [];
    let orderActions = [];
    const fulfillOrderStartTime = performance.now();
    try {
        const { actions } = await measureAsyncExecution(config, 'Time to call fulfillOrder from the orderbook', orderbook.fulfillOrder(id, fulfillerAddress, fees));
        orderActions = actions;
        unsignedApprovalTransactions = await measureAsyncExecution(config, 'Time to construct the unsigned approval transactions', getUnsignedERC20ApprovalTransactions(actions));
    }
    catch (err) {
        const elapsedTimeInSeconds = (performance.now() - fulfillOrderStartTime) / 1000;
        debugLogger(config, 'Time to call fulfillOrder from the orderbook', elapsedTimeInSeconds);
        if (err.message.includes(OrderStatusName.EXPIRED)) {
            throw new CheckoutError('Order is expired', CheckoutErrorType.ORDER_EXPIRED_ERROR, { orderId: id });
        }
        // The balances error will be handled by bulk order fulfillment but for now we
        // need to assert on this string to check that the error is not a balances error
        if (!err.message.includes('The fulfiller does not have the balances needed to fulfill')) {
            throw new CheckoutError('Error occurred while trying to fulfill the order', CheckoutErrorType.FULFILL_ORDER_LISTING_ERROR, {
                orderId: id,
                message: err.message,
            });
        }
    }
    try {
        unsignedFulfillmentTransactions = await measureAsyncExecution(config, 'Time to construct the unsigned fulfillment transactions', getUnsignedFulfillmentTransactions(orderActions));
    }
    catch {
        // if cannot estimate gas then silently continue and use gas limit in smartCheckout
        // but get the fulfillment transactions after they have approved the spending
    }
    let amount = BigNumber$1.from('0');
    let type = ItemType.NATIVE;
    let contractAddress = '';
    const buyArray = order.result.buy;
    if (buyArray.length > 0) {
        switch (buyArray[0].type) {
            case 'NATIVE':
                type = ItemType.NATIVE;
                break;
            case 'ERC20':
                type = ItemType.ERC20;
                contractAddress = buyArray[0].contractAddress;
                break;
            default:
                throw new CheckoutError('Purchasing token type is unsupported', CheckoutErrorType.UNSUPPORTED_TOKEN_TYPE_ERROR, {
                    orderId: id,
                });
        }
    }
    buyArray.forEach((item) => {
        if (item.type !== ItemType.ERC721) {
            amount = amount.add(BigNumber$1.from(item.amount));
        }
    });
    const feeArray = order.result.fees;
    feeArray.forEach((item) => {
        amount = amount.add(BigNumber$1.from(item.amount));
    });
    const itemRequirements = [
        getItemRequirement(type, contractAddress, amount, spenderAddress),
    ];
    const smartCheckoutResult = await measureAsyncExecution(config, 'Total time running smart checkout', smartCheckout(config, provider, itemRequirements, getTransactionOrGas(gasLimit, unsignedFulfillmentTransactions)));
    if (smartCheckoutResult.sufficient) {
        const approvalResult = await signApprovalTransactions(provider, unsignedApprovalTransactions);
        if (approvalResult.type === SignTransactionStatusType.FAILED) {
            return {
                status: CheckoutStatus.FAILED,
                transactionHash: approvalResult.transactionHash,
                reason: approvalResult.reason,
                smartCheckoutResult,
            };
        }
        try {
            if (unsignedFulfillmentTransactions.length === 0) {
                unsignedFulfillmentTransactions = await getUnsignedFulfillmentTransactions(orderActions);
            }
        }
        catch (err) {
            throw new CheckoutError('Error fetching fulfillment transaction', CheckoutErrorType.FULFILL_ORDER_LISTING_ERROR, {
                message: err.message,
            });
        }
        const fulfillmentResult = await signFulfillmentTransactions(provider, unsignedFulfillmentTransactions);
        if (fulfillmentResult.type === SignTransactionStatusType.FAILED) {
            return {
                status: CheckoutStatus.FAILED,
                transactionHash: fulfillmentResult.transactionHash,
                reason: fulfillmentResult.reason,
                smartCheckoutResult,
            };
        }
        return {
            status: CheckoutStatus.SUCCESS,
            smartCheckoutResult,
        };
    }
    return {
        status: CheckoutStatus.INSUFFICIENT_FUNDS,
        smartCheckoutResult,
    };
};

const cancel = async (config, provider, orderIds) => {
    let unsignedCancelOrderTransaction;
    if (orderIds.length === 0) {
        throw new CheckoutError('No orderIds were provided to the orderIds array. Please provide at least one orderId.', CheckoutErrorType.CANCEL_ORDER_LISTING_ERROR);
    }
    // Update this when bulk cancel is supported
    const orderId = orderIds[0];
    try {
        const offererAddress = await measureAsyncExecution(config, 'Time to get the address from the provider', provider.getSigner().getAddress());
        const orderbook = createOrderbookInstance(config);
        const cancelOrderResponse = await measureAsyncExecution(config, 'Time to get the cancel order from the orderbook', orderbook.cancelOrdersOnChain([orderId], offererAddress));
        unsignedCancelOrderTransaction = await cancelOrderResponse.cancellationAction.buildTransaction();
    }
    catch (err) {
        throw new CheckoutError('An error occurred while cancelling the order listing', CheckoutErrorType.CANCEL_ORDER_LISTING_ERROR, {
            orderId,
            message: err.message,
        });
    }
    const result = await signFulfillmentTransactions(provider, [unsignedCancelOrderTransaction]);
    if (result.type === SignTransactionStatusType.FAILED) {
        return {
            status: CheckoutStatus.FAILED,
            transactionHash: result.transactionHash,
            reason: result.reason,
        };
    }
    return {
        status: CheckoutStatus.SUCCESS,
    };
};

const getERC721Requirement = (id, contractAddress, spenderAddress) => ({
    type: ItemType.ERC721,
    id,
    contractAddress,
    spenderAddress,
});
const getBuyToken = (buyToken, decimals = 18) => {
    const bnAmount = utils$1.parseUnits(buyToken.amount, decimals);
    if (buyToken.type === ItemType.NATIVE) {
        return {
            type: ItemType.NATIVE,
            amount: bnAmount.toString(),
        };
    }
    return {
        type: ItemType.ERC20,
        amount: bnAmount.toString(),
        contractAddress: buyToken.contractAddress,
    };
};
const sell = async (config, provider, orders) => {
    let orderbook;
    let listing;
    let spenderAddress = '';
    if (orders.length === 0) {
        throw new CheckoutError('No orders were provided to the orders array. Please provide at least one order.', CheckoutErrorType.PREPARE_ORDER_LISTING_ERROR);
    }
    const { buyToken, sellToken, makerFees } = orders[0];
    let decimals = 18;
    if (buyToken.type === ItemType.ERC20) {
        // get this from the allowed list
        const buyTokenContract = new Contract$1(buyToken.contractAddress, JSON.stringify(ERC20ABI), provider);
        decimals = await measureAsyncExecution(config, 'Time to get decimals of token contract for the buy token', buyTokenContract.decimals());
    }
    const buyTokenOrNative = getBuyToken(buyToken, decimals);
    try {
        const walletAddress = await measureAsyncExecution(config, 'Time to get the address from the provider', provider.getSigner().getAddress());
        orderbook = createOrderbookInstance(config);
        const { seaportContractAddress } = orderbook.config();
        spenderAddress = seaportContractAddress;
        listing = await measureAsyncExecution(config, 'Time to prepare the listing from the orderbook', orderbook.prepareListing({
            makerAddress: walletAddress,
            buy: buyTokenOrNative,
            sell: {
                type: ItemType.ERC721,
                contractAddress: sellToken.collectionAddress,
                tokenId: sellToken.id,
            },
        }));
    }
    catch (err) {
        throw new CheckoutError('An error occurred while preparing the listing', CheckoutErrorType.PREPARE_ORDER_LISTING_ERROR, {
            message: err.message,
            id: sellToken.id,
            collectionAddress: sellToken.collectionAddress,
        });
    }
    const itemRequirements = [
        getERC721Requirement(sellToken.id, sellToken.collectionAddress, spenderAddress),
    ];
    const smartCheckoutResult = await measureAsyncExecution(config, 'Total time running smart checkout', smartCheckout(config, provider, itemRequirements, {
        type: TransactionOrGasType.GAS,
        gasToken: {
            type: GasTokenType.NATIVE,
            limit: BigNumber$1.from(constants.estimatedFulfillmentGasGwei),
        },
    }));
    if (smartCheckoutResult.sufficient) {
        const unsignedTransactions = await getUnsignedERC721Transactions(listing.actions);
        const approvalResult = await signApprovalTransactions(provider, unsignedTransactions.approvalTransactions);
        if (approvalResult.type === SignTransactionStatusType.FAILED) {
            return {
                status: CheckoutStatus.FAILED,
                transactionHash: approvalResult.transactionHash,
                reason: approvalResult.reason,
                smartCheckoutResult,
            };
        }
        const unsignedMessage = getUnsignedMessage(listing.orderHash, listing.orderComponents, listing.actions);
        if (!unsignedMessage) {
            // For sell it is expected the orderbook will always return an unsigned message
            // If for some reason it is missing then we cannot proceed with the create listing
            throw new CheckoutError('The unsigned message is missing after preparing the listing', CheckoutErrorType.SIGN_MESSAGE_ERROR, {
                id: sellToken.id,
                collectionAddress: sellToken.collectionAddress,
            });
        }
        const signedMessage = await signMessage(provider, unsignedMessage);
        let orderId = '';
        const createListingParams = {
            orderComponents: signedMessage.orderComponents,
            orderHash: signedMessage.orderHash,
            orderSignature: signedMessage.signedMessage,
            makerFees: [],
        };
        if (makerFees !== undefined) {
            const orderBookFees = calculateFees(makerFees, buyTokenOrNative.amount, decimals);
            if (orderBookFees.length !== makerFees.length) {
                throw new CheckoutError('One of the fees is too small, must be greater than 0.000001', CheckoutErrorType.CREATE_ORDER_LISTING_ERROR);
            }
            createListingParams.makerFees = orderBookFees;
        }
        try {
            const order = await orderbook.createListing(createListingParams);
            orderId = order.result.id;
        }
        catch (err) {
            throw new CheckoutError('An error occurred while creating the listing', CheckoutErrorType.CREATE_ORDER_LISTING_ERROR, {
                message: err.message,
                collectionId: sellToken.id,
                collectionAddress: sellToken.collectionAddress,
            });
        }
        return {
            status: CheckoutStatus.SUCCESS,
            orderIds: [orderId],
            smartCheckoutResult,
        };
    }
    return {
        status: CheckoutStatus.INSUFFICIENT_FUNDS,
        smartCheckoutResult,
    };
};

class FiatRampService {
    config;
    /**
     * Constructs a new instance of the FiatRampService class.
     * @param {CheckoutConfiguration} config - The config required for the FiatRampService.
     */
    constructor(config) {
        this.config = config;
    }
    async feeEstimate() {
        const config = (await this.config.remote.getConfig('onramp'));
        return config[OnRampProvider.TRANSAK]?.fees;
    }
    async createWidgetUrl(params) {
        return (await this.getTransakWidgetUrl(params));
    }
    async getTransakWidgetUrl(params) {
        let widgetUrl = `${TRANSAK_API_BASE_URL[this.config.environment]}?`;
        const onRampConfig = (await this.config.remote.getConfig('onramp'));
        const apiKey = onRampConfig[OnRampProvider.TRANSAK].publishableApiKey;
        const transakPublishableKey = `apiKey=${apiKey}`;
        const zkevmNetwork = 'network=immutablezkevm';
        const defaultPaymentMethod = 'defaultPaymentMethod=credit_debit_card';
        const disableBankTransfer = 'disablePaymentMethods=sepa_bank_transfer,gbp_bank_transfer,'
            + 'pm_cash_app,pm_jwire,pm_paymaya,pm_bpi,pm_ubp,pm_grabpay,pm_shopeepay,pm_gcash,pm_pix,'
            + 'pm_astropay,pm_pse,inr_bank_transfer';
        const productsAvailed = 'productsAvailed=buy';
        const exchangeScreenTitle = 'exchangeScreenTitle=Buy';
        const themeColor = 'themeColor=0D0D0D';
        widgetUrl += `${transakPublishableKey}&`
            + `${zkevmNetwork}&`
            + `${defaultPaymentMethod}&`
            + `${disableBankTransfer}&`
            + `${productsAvailed}&`
            + `${exchangeScreenTitle}&`
            + `${themeColor}`;
        if (params.isPassport && params.email) {
            const encodedEmail = encodeURIComponent(params.email);
            widgetUrl += `&email=${encodedEmail}&isAutoFillUserData=true&disableWalletAddressForm=true`;
        }
        if (params.tokenAmount && params.tokenSymbol) {
            widgetUrl += `&defaultCryptoAmount=${params.tokenAmount}&cryptoCurrencyCode=${params.tokenSymbol}`;
        }
        else {
            widgetUrl += '&defaultCryptoCurrency=IMX';
        }
        if (params.walletAddress) {
            widgetUrl += `&walletAddress=${params.walletAddress}`;
        }
        return widgetUrl;
    }
}

async function getItemRequirementsFromRequirements(provider, requirements) {
    // Get all decimal values by calling contracts for each ERC20
    const decimalPromises = [];
    requirements.forEach((itemRequirementParam) => {
        if (itemRequirementParam.type === ItemType.ERC20) {
            const { contractAddress } = itemRequirementParam;
            decimalPromises.push(getTokenContract(contractAddress, ERC20ABI, provider).decimals());
        }
    });
    const decimals = await Promise.all(decimalPromises);
    // Map ItemRequirementsParam objects to ItemRequirement by parsing amounts from formatted string to BigNumebrs
    const itemRequirements = requirements.map((itemRequirementParam, index) => {
        if (itemRequirementParam.type === ItemType.NATIVE) {
            return {
                ...itemRequirementParam,
                amount: utils$1.parseUnits(itemRequirementParam.amount, 18),
            };
        }
        if (itemRequirementParam.type === ItemType.ERC20) {
            return {
                ...itemRequirementParam,
                amount: utils$1.parseUnits(itemRequirementParam.amount, decimals[index]),
            };
        }
        return itemRequirementParam;
    });
    return itemRequirements;
}

/**
 * Validates and builds a version string based on the given SemanticVersion object.
 * If the version is undefined or has an invalid major version, it returns the default checkout version.
 * If the version is all zeros, it also returns the default checkout version.
 * Otherwise, it constructs a validated version string based on the major, minor, patch, and build numbers.
 */
function validateAndBuildVersion(version) {
    const defaultPackageVersion = globalPackageVersion();
    if (version === undefined || version.major === undefined)
        return defaultPackageVersion;
    if (!Number.isInteger(version.major) || version.major < 0)
        return defaultPackageVersion;
    if (version.minor !== undefined && version.minor < 0)
        return defaultPackageVersion;
    if (version.patch !== undefined && version.patch < 0)
        return defaultPackageVersion;
    if (version.major === 0 && version.minor === undefined)
        return defaultPackageVersion;
    if (version.major === 0 && version.minor === 0 && version.patch === undefined)
        return defaultPackageVersion;
    if (version.major === 0 && version.minor === undefined && version.patch === undefined)
        return defaultPackageVersion;
    if (version.major === 0 && version.minor === 0 && version.patch === 0)
        return defaultPackageVersion;
    let validatedVersion = version.major.toString();
    if (version.minor === undefined)
        return validatedVersion;
    if (Number.isInteger(version.minor)) {
        validatedVersion += `.${version.minor.toString()}`;
    }
    if (version.patch === undefined)
        return validatedVersion;
    if (Number.isInteger(version.patch)) {
        validatedVersion += `.${version.patch.toString()}`;
    }
    if (version.prerelease === undefined || version.prerelease !== 'alpha')
        return validatedVersion;
    if (version.prerelease === 'alpha') {
        validatedVersion += `-${version.prerelease}`;
    }
    if (version.build === undefined)
        return validatedVersion;
    if (Number.isInteger(version.build) && version.build >= 0) {
        validatedVersion += `.${version.build.toString()}`;
    }
    return validatedVersion;
}

function loadUnresolved(version) {
    if (window === undefined) {
        throw new Error('missing window object: please run Checkout client side');
    }
    if (document === undefined) {
        throw new Error('missing document object: please run Checkout client side');
    }
    const scriptId = 'immutable-checkout-widgets-bundle';
    const validVersion = validateAndBuildVersion(version);
    // Prevent the script to be loaded more than once
    // by checking the presence of the script and its version.
    const initScript = document.getElementById(scriptId);
    if (initScript)
        return { loaded: true, element: initScript };
    const tag = document.createElement('script');
    let cdnUrl = `https://cdn.jsdelivr.net/npm/@imtbl/sdk@${validVersion}/dist/browser/checkout/widgets.js`;
    tag.setAttribute('id', scriptId);
    tag.setAttribute('data-version', validVersion);
    tag.setAttribute('src', cdnUrl);
    document.head.appendChild(tag);
    return { loaded: false, element: tag };
}

const SANDBOX_CONFIGURATION = {
    baseConfig: {
        environment: Environment$1.SANDBOX,
    },
    passport: undefined,
};
const WIDGETS_SCRIPT_TIMEOUT = 100;
// Checkout SDK
class Checkout {
    readOnlyProviders;
    config;
    fiatRampService;
    availability;
    passport;
    /**
     * Constructs a new instance of the CheckoutModule class.
     * @param {CheckoutModuleConfiguration} [config=SANDBOX_CONFIGURATION] - The configuration object for the CheckoutModule.
     */
    constructor(config = SANDBOX_CONFIGURATION) {
        this.config = new CheckoutConfiguration(config);
        this.fiatRampService = new FiatRampService(this.config);
        this.readOnlyProviders = new Map();
        this.availability = availabilityService(this.config.isDevelopment, this.config.isProduction);
        this.passport = config.passport;
    }
    /**
     * Loads the widgets bundle and initiate the widgets factory.
     * @param {WidgetsInit} init - The initialisation parameters for loading the widgets bundle and applying configuration
     */
    async widgets(init) {
        const checkout = this;
        const factory = new Promise((resolve, reject) => {
            function checkForWidgetsBundleLoaded() {
                if (typeof ImmutableCheckoutWidgets !== 'undefined') {
                    resolve(new ImmutableCheckoutWidgets.WidgetsFactory(checkout, init.config));
                }
                else {
                    // If ImmutableCheckoutWidgets is not defined, wait for set amount of time.
                    // When time has elapsed, check again if ImmutableCheckoutWidgets is defined.
                    // Once it's defined, the promise will resolve and setTimeout won't be called again.
                    setTimeout(checkForWidgetsBundleLoaded, WIDGETS_SCRIPT_TIMEOUT);
                }
            }
            try {
                const script = loadUnresolved(init.version);
                if (script.loaded && typeof ImmutableCheckoutWidgets !== 'undefined') {
                    // eslint-disable-next-line no-console
                    console.warn('Checkout widgets script is already loaded');
                    resolve(new ImmutableCheckoutWidgets.WidgetsFactory(checkout, init.config));
                }
                else {
                    checkForWidgetsBundleLoaded();
                }
            }
            catch (err) {
                reject(new CheckoutError('Failed to load widgets script', CheckoutErrorType.WIDGETS_SCRIPT_LOAD_ERROR, { message: err.message }));
            }
        });
        return factory;
    }
    /**
     * Creates a provider using the given parameters.
     * @param {CreateProviderParams} params - The parameters for creating the provider.
     * @returns {Promise<CreateProviderResult>} A promise that resolves to the created provider.
     */
    async createProvider(params) {
        return await createProvider(params.walletProviderName, this.passport);
    }
    /**
     * Checks if a wallet is connected to the specified provider.
     * @param {CheckConnectionParams} params - The parameters for checking the wallet connection.
     * @returns {Promise<CheckConnectionResult>} - A promise that resolves to the result of the check.
     */
    async checkIsWalletConnected(params) {
        const web3Provider = await validateProvider(this.config, params.provider, { allowUnsupportedProvider: true });
        return checkIsWalletConnected(web3Provider);
    }
    /**
     * Connects to a blockchain network using the specified provider.
     * @param {ConnectParams} params - The parameters for connecting to the network.
     * @returns {Promise<ConnectResult>} A promise that resolves to an object containing the provider and network information.
     * @throws {Error} If the provider is not valid or if there is an error connecting to the network.
     */
    async connect(params) {
        const web3Provider = await validateProvider(this.config, params.provider, { allowUnsupportedProvider: true });
        await connectSite(web3Provider);
        return { provider: web3Provider };
    }
    /**
     * Switches the network for the current wallet provider.
     * @param {SwitchNetworkParams} params - The parameters for switching the network.
     * @returns {Promise<SwitchNetworkResult>} - A promise that resolves to the result of switching the network.
     */
    async switchNetwork(params) {
        const web3Provider = await validateProvider(this.config, params.provider, {
            allowUnsupportedProvider: true,
            allowMistmatchedChainId: true,
        });
        const switchNetworkRes = await switchWalletNetwork(this.config, web3Provider, params.chainId);
        return switchNetworkRes;
    }
    /**
     * Retrieves the balance of a wallet address.
     * @param {GetBalanceParams} params - The parameters for retrieving the balance.
     * @returns {Promise<GetBalanceResult>} - A promise that resolves to the balance result.
     */
    async getBalance(params) {
        const web3Provider = await validateProvider(this.config, params.provider);
        if (!params.contractAddress || params.contractAddress === '') {
            return await getBalance(this.config, web3Provider, params.walletAddress);
        }
        return await getERC20Balance(web3Provider, params.walletAddress, params.contractAddress);
    }
    /**
     * Retrieves the balances of all tokens for a given wallet address on a specific chain.
     * @param {GetAllBalancesParams} params - The parameters for retrieving the balances.
     * @returns {Promise<GetAllBalancesResult>} - A promise that resolves to the result of retrieving the balances.
     */
    async getAllBalances(params) {
        const web3Provider = await validateProvider(this.config, params.provider);
        return getAllBalances(this.config, web3Provider, params.walletAddress, params.chainId);
    }
    /**
     * Retrieves the supported networks based on the provided parameters.
     * @param {GetNetworkAllowListParams} params - The parameters for retrieving the network allow list.
     * @returns {Promise<GetNetworkAllowListResult>} - A promise that resolves to the network allow list result.
     */
    async getNetworkAllowList(params) {
        return await getNetworkAllowList(this.config, params);
    }
    /**
     * Retrieves the supported tokens based on the provided parameters.
     * @param {GetTokenAllowListParams} params - The parameters for retrieving the token allow list.
     * @returns {Promise<GetTokenAllowListResult>} - A promise that resolves to the token allow list result.
     */
    async getTokenAllowList(params) {
        return await getTokenAllowList(this.config, params);
    }
    /**
     * Retrieves the default supported wallets based on the provided parameters.
     * @param {GetWalletAllowListParams} params - The parameters for retrieving the wallet allow list.
     * @returns {Promise<GetWalletAllowListResult>} - A promise that resolves to the wallet allow list result.
     */
    async getWalletAllowList(params) {
        return await getWalletAllowList(params);
    }
    /**
     * Sends a transaction using the specified provider and transaction parameters.
     * @param {SendTransactionParams} params - The parameters for sending the transaction.
     * @returns {Promise<SendTransactionResult>} A promise that resolves to the result of the transaction.
     */
    async sendTransaction(params) {
        const web3Provider = await validateProvider(this.config, params.provider);
        return await sendTransaction(web3Provider, params.transaction);
    }
    /**
     * Retrieves network information using the specified provider.
     * @param {GetNetworkParams} params - The parameters for retrieving network information.
     * @returns {Promise<NetworkInfo>} A promise that resolves to the network information.
     */
    async getNetworkInfo(params) {
        const web3Provider = await validateProvider(this.config, params.provider, {
            allowUnsupportedProvider: true,
            allowMistmatchedChainId: true,
        });
        return await getNetworkInfo(this.config, web3Provider);
    }
    /**
     * Determines the requirements for performing a buy.
     * @param {BuyParams} params - The parameters for the buy.
    */
    async buy(params) {
        if (params.orders.length > 1) {
            // eslint-disable-next-line no-console
            console.warn('This endpoint currently only processes the first order in the array.');
        }
        const web3Provider = await validateProvider(this.config, params.provider);
        return await buy(this.config, web3Provider, params.orders);
    }
    /**
     * Determines the requirements for performing a sell.
     * @param {SellParams} params - The parameters for the sell.
     * Only currently actions the first order in the array until we support batch processing.
     * Only currently actions the first fee in the fees array of each order until we support multiple fees.
    */
    async sell(params) {
        if (params.orders.length > 1) {
            // eslint-disable-next-line no-console
            console.warn('This endpoint currently only processes the first order in the array.');
        }
        const web3Provider = await validateProvider(this.config, params.provider);
        return await sell(this.config, web3Provider, params.orders);
    }
    /**
     * Cancels a sell.
     * @param {CancelParams} params - The parameters for the cancel.
     */
    async cancel(params) {
        // eslint-disable-next-line no-console
        console.warn('This endpoint currently only processes the first order in the array.');
        const web3Provider = await validateProvider(this.config, params.provider);
        return await cancel(this.config, web3Provider, params.orderIds);
    }
    /**
     * Determines the transaction requirements to complete a purchase.
     * @params {SmartCheckoutParams} params - The parameters for smart checkout.
     */
    async smartCheckout(params) {
        const web3Provider = await validateProvider(this.config, params.provider);
        let itemRequirements = [];
        try {
            itemRequirements = await getItemRequirementsFromRequirements(web3Provider, params.itemRequirements);
        }
        catch {
            throw new CheckoutError('Failed to map item requirements', CheckoutErrorType.ITEM_REQUIREMENTS_ERROR);
        }
        return await smartCheckout(this.config, web3Provider, itemRequirements, params.transactionOrGasAmount);
    }
    /**
     * Checks if the given object is a Web3 provider.
     * @param {Web3Provider} web3Provider - The object to check.
     * @returns {boolean} - True if the object is a Web3 provider, false otherwise.
     */
    static isWeb3Provider(web3Provider) {
        return isWeb3Provider(web3Provider);
    }
    /**
     * Estimates the gas required for a swap or bridge transaction.
     * @param {GasEstimateParams} params - The parameters for the gas estimation.
     * @returns {Promise<GasEstimateSwapResult | GasEstimateBridgeToL2Result>} - A promise that resolves to the gas estimation result.
     */
    async gasEstimate(params) {
        this.readOnlyProviders = await createReadOnlyProviders(this.config, this.readOnlyProviders);
        return await gasEstimator(params, this.readOnlyProviders, this.config);
    }
    /**
     * Creates and returns a URL for the fiat ramp widget.
     * @param {FiatRampParams} params - The parameters for creating the url.
     * @returns {Promise<string>} - A promise that resolves to a string url.
     */
    async createFiatRampUrl(params) {
        let tokenAmount;
        let tokenSymbol = 'IMX';
        let email;
        const walletAddress = await params.web3Provider.getSigner().getAddress();
        const isPassport = params.web3Provider.provider?.isPassport || false;
        if (isPassport && params.passport) {
            const userInfo = await params.passport.getUserInfo();
            email = userInfo?.email;
        }
        const tokenList = await getTokenAllowList(this.config, { type: TokenFilterTypes.ONRAMP });
        const token = tokenList.tokens?.find((t) => t.address?.toLowerCase() === params.tokenAddress?.toLowerCase());
        if (token) {
            tokenAmount = params.tokenAmount;
            tokenSymbol = token.symbol;
        }
        return await this.fiatRampService.createWidgetUrl({
            exchangeType: params.exchangeType,
            isPassport,
            walletAddress,
            tokenAmount,
            tokenSymbol,
            email,
        });
    }
    /**
     * Fetches fiat ramp fee estimations.
     * @returns {Promise<OnRampProviderFees>} - A promise that resolves to OnRampProviderFees.
     */
    async getExchangeFeeEstimate() {
        return await this.fiatRampService.feeEstimate();
    }
    /**
     * Fetches Swap widget availability.
     * @returns {Promise<boolean>} - A promise that resolves to a boolean.
     */
    async isSwapAvailable() {
        return this.availability.checkDexAvailability();
    }
}

var checkout = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get BridgeEventType () { return BridgeEventType; },
    CHECKOUT_API_BASE_URL: CHECKOUT_API_BASE_URL,
    get ChainId () { return ChainId; },
    get ChainName () { return ChainName; },
    Checkout: Checkout,
    CheckoutConfiguration: CheckoutConfiguration,
    get CheckoutErrorType () { return CheckoutErrorType; },
    get CheckoutStatus () { return CheckoutStatus; },
    get ConnectEventType () { return ConnectEventType; },
    get ConnectTargetLayer () { return ConnectTargetLayer; },
    get ExchangeType () { return ExchangeType; },
    get FundingStepType () { return FundingStepType; },
    get GasEstimateType () { return GasEstimateType; },
    get GasTokenType () { return GasTokenType; },
    get IMTBLWidgetEvents () { return IMTBLWidgetEvents; },
    get ItemType () { return ItemType; },
    get NetworkFilterTypes () { return NetworkFilterTypes; },
    get OnRampEventType () { return OnRampEventType; },
    get OrchestrationEventType () { return OrchestrationEventType; },
    get ProviderEventType () { return ProviderEventType; },
    get RoutingOutcomeType () { return RoutingOutcomeType; },
    get SaleEventType () { return SaleEventType; },
    get SwapEventType () { return SwapEventType; },
    get TokenFilterTypes () { return TokenFilterTypes; },
    get TransactionOrGasType () { return TransactionOrGasType; },
    get WalletEventType () { return WalletEventType; },
    get WalletFilterTypes () { return WalletFilterTypes; },
    get WalletProviderName () { return WalletProviderName; },
    get WidgetTheme () { return WidgetTheme; },
    get WidgetType () { return WidgetType; }
});

export { blockchain_data as blockchainData, checkout, config, immutablex_client as immutablexClient, orderbook, passport, provider };
