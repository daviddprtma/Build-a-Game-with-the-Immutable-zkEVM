import { BigNumberish, BytesLike, ethers } from 'ethers';
export interface Transaction {
    to: string;
    value?: BigNumberish;
    data?: BytesLike;
    gasLimit?: BigNumberish;
    delegateCall?: boolean;
    revertOnError?: boolean;
}
export interface SimulatedTransaction extends Transaction {
    succeeded: boolean;
    executed: boolean;
    gasUsed: number;
    gasLimit: number;
    result?: string;
    reason?: string;
}
export interface TransactionEncoded {
    delegateCall: boolean;
    revertOnError: boolean;
    gasLimit: BigNumberish;
    target: string;
    value: BigNumberish;
    data: BytesLike;
}
export type Transactionish = ethers.providers.TransactionRequest | ethers.providers.TransactionRequest[] | Transaction | Transaction[];
export interface TransactionResponse<R = any> extends ethers.providers.TransactionResponse {
    receipt?: R;
}
export type TransactionBundle = {
    entrypoint: string;
    transactions: Transaction[];
    nonce?: BigNumberish;
};
export type IntendedTransactionBundle = TransactionBundle & {
    chainId: BigNumberish;
    intent: {
        id: string;
        wallet: string;
    };
};
export type SignedTransactionBundle = IntendedTransactionBundle & {
    signature: string;
    nonce: BigNumberish;
};
export type RelayReadyTransactionBundle = SignedTransactionBundle | IntendedTransactionBundle;
export declare const MetaTransactionsType = "tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]";
export declare function intendTransactionBundle(bundle: TransactionBundle, wallet: string, chainId: BigNumberish, id: string): IntendedTransactionBundle;
export declare function intendedTransactionID(bundle: IntendedTransactionBundle): string;
export declare function unpackMetaTransactionsData(data: BytesLike): [ethers.BigNumber, TransactionEncoded[]];
export declare function packMetaTransactionsData(nonce: ethers.BigNumberish, txs: Transaction[]): string;
export declare function digestOfTransactions(nonce: BigNumberish, txs: Transaction[]): string;
export declare function subdigestOfTransactions(address: string, chainId: BigNumberish, nonce: ethers.BigNumberish, txs: Transaction[]): string;
export declare function subdigestOfGuestModuleTransactions(guestModule: string, chainId: BigNumberish, txs: Transaction[]): string;
export declare function toSequenceTransactions(wallet: string, txs: (Transaction | ethers.providers.TransactionRequest)[]): {
    nonce?: ethers.BigNumberish;
    transaction: Transaction;
}[];
export declare function toSequenceTransaction(wallet: string, tx: ethers.providers.TransactionRequest): {
    nonce?: ethers.BigNumberish;
    transaction: Transaction;
};
export declare function isSequenceTransaction(tx: any): tx is Transaction;
export declare function hasSequenceTransactions(txs: any[]): txs is Transaction[];
export declare function sequenceTxAbiEncode(txs: Transaction[]): TransactionEncoded[];
export declare function fromTxAbiEncode(txs: TransactionEncoded[]): Transaction[];
export declare function encodeNonce(space: BigNumberish, nonce: BigNumberish): ethers.BigNumber;
export declare function decodeNonce(nonce: BigNumberish): [ethers.BigNumber, ethers.BigNumber];
export declare function fromTransactionish(wallet: string, transaction: Transactionish): Transaction[];
export declare function isTransactionBundle(cand: any): cand is TransactionBundle;
export declare function isSignedTransactionBundle(cand: any): cand is SignedTransactionBundle;
export declare function encodeBundleExecData(bundle: TransactionBundle): string;
export declare const selfExecuteSelector = "0x61c2926c";
export declare const selfExecuteAbi = "tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]";
export declare const unwind: (wallet: string, transactions: Transaction[]) => Transaction[];
