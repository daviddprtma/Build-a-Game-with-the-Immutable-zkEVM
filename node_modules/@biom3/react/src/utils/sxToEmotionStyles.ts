/* eslint-disable no-restricted-syntax */
//  ^ is neccissary due to array methods not playing nicely with types.
import { Gradient, smartPickTokenValue } from '@biom3/design-tokens';
import { CSSProperties } from 'react';
import merge from 'ts-deepmerge';

import {
  MakeObjectResponsive,
  Measurement,
  MeasurementAndResponsiveMeasurement,
  shortHandCssRuleMapping,
  SxProps,
  ValidSxValues,
} from '../types/sxProps';
import { BiomeTheme } from '../types/theme';

export function hasKey<K extends string>(
  key: K,
  object: {},
): object is { [_ in K]: keyof SxProps } {
  // @TODO: would be awesome to try and get this working
  // (because it actually narrows the type), but it's not a priority atm
  // ): object is { [_ in K]: {} } {
  return typeof object === 'object' && object !== null && key in object;
}

// @TODO: this is 99% the correct type, but still includes the shorthand rules.
// ideally, the type should only be longform rules.
export function convertShorthandRule(rule: keyof SxProps) {
  let longHandRule = rule;
  if (hasKey(rule, shortHandCssRuleMapping)) {
    longHandRule = shortHandCssRuleMapping[rule];
  }
  return longHandRule;
}

export function applyXandYStyleAmount(
  rule: keyof SxProps,
  value: string,
): CSSProperties {
  const rulePrefix = rule.substring(0, rule.length - 1);
  return rule.match(/[margin|padding]Y/)
    ? { [`${rulePrefix}Top`]: value, [`${rulePrefix}Bottom`]: value }
    : { [`${rulePrefix}Left`]: value, [`${rulePrefix}Right`]: value };
}

export function applyStyleAmount(
  rule: keyof SxProps,
  value: ValidSxValues | null,
  themeProps: BiomeTheme,
): CSSProperties {
  if (value === undefined || value === null) return {};
  const valueFromToken =
    smartPickTokenValue<string | Gradient>(themeProps, `${value}`) ?? value;

  const isGradient = typeof valueFromToken === 'object';
  if (isGradient && rule.match(/background$|backgroundImage$|^color/)) {
    const gradient = valueFromToken;
    const styleObject = {
      backgroundImage: gradient.spectrum,
      backgroundBlendMode: gradient.blendMode,
    };
    return rule.match(/color/)
      ? {
          ...styleObject,
          backgroundClip: 'text',
          textFillColor: 'transparent',
        }
      : styleObject;
  }

  if (
    rule.match(/paddingX$|paddingY|marginY|marginX$/) &&
    typeof valueFromToken === 'string'
  ) {
    return applyXandYStyleAmount(rule, valueFromToken);
  }

  return { [rule]: valueFromToken };
}

type MeasurementOrNull = Measurement | null;
type NullOrMeasurementArray = MeasurementOrNull[];

export function renderResponsiveStyles(
  rule: keyof SxProps,
  values: NullOrMeasurementArray,
  themeProps: BiomeTheme,
) {
  const [defaultValue, ...responsiveValues] = values;
  const responsiveStyles = responsiveValues.map(
    (responsiveValue: MeasurementOrNull, index: number) => {
      const mediaStyleRule = `@media screen and (min-width: ${themeProps.base.breakpointAsArray?.[index]}px)`;
      const cssValue =
        typeof responsiveValue === 'function'
          ? responsiveValue(themeProps)
          : responsiveValue;
      return responsiveValue
        ? {
            [mediaStyleRule]: applyStyleAmount(rule, cssValue, themeProps),
          }
        : {};
    },
  );
  const styles: CSSProperties = {
    ...(defaultValue
      ? applyStyleAmount(
          rule,
          typeof defaultValue === 'function'
            ? defaultValue(themeProps)
            : defaultValue,
          themeProps,
        )
      : {}),
    ...Object.assign({}, ...responsiveStyles),
  };
  return styles;
}

export function renderResponsiveStylesFromObject(
  rule: keyof SxProps,
  values: MakeObjectResponsive<MeasurementOrNull>,
  themeProps: BiomeTheme,
) {
  const { default: defaultProp, ...responsiveProps } = values;
  const orderedArray = [defaultProp];
  let key: keyof typeof themeProps.base.breakpoint;
  for (key in themeProps.base.breakpoint) {
    const responsiveStyle = responsiveProps[key];
    if (responsiveStyle) {
      orderedArray.push(responsiveStyle);
    } else {
      orderedArray.push(null);
    }
  }
  return renderResponsiveStyles(rule, orderedArray, themeProps);
}

// @TODO: the types here are not great. might need some work. :(
export function renderDescendantStylesFromObject(
  descendantSelector: string,
  descendantValue: {
    [key: string]:
      | string
      | number
      | ((theme: BiomeTheme) => string | number)
      | null;
  },
  themeProps: BiomeTheme,
) {
  const descendantStyles = {
    [descendantSelector]: {},
  };
  let key: keyof typeof descendantValue;
  for (key in descendantValue) {
    const rule = convertShorthandRule(key as keyof SxProps);
    const value: MeasurementAndResponsiveMeasurement | null =
      descendantValue[key];
    descendantStyles[descendantSelector] = merge(
      descendantStyles[descendantSelector],
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      chooseWhichStylesToRender(rule, value, themeProps),
    );
  }
  return descendantStyles;
}

export function chooseWhichStylesToRender(
  rule: keyof SxProps,
  value: MeasurementAndResponsiveMeasurement | null,
  themeProps: BiomeTheme,
) {
  if (value === null) return {};

  // @NOTE: We must ignore any of the @emotion/react keyframe based
  // animation style objects, as these do NOT need to go through sx processing
  if (typeof value === 'function' && typeof rule === 'function') {
    return {};
  }

  const cssValue = typeof value === 'function' ? value(themeProps) : value;

  // @TODO: find a way to not have to cast cssValue here (hint: its due to Array.isArray())
  return Array.isArray(cssValue)
    ? renderResponsiveStyles(rule, cssValue as Measurement[], themeProps)
    : typeof cssValue === 'object' && cssValue.default
    ? renderResponsiveStylesFromObject(rule, cssValue, themeProps)
    : typeof cssValue === 'object'
    ? renderDescendantStylesFromObject(rule, cssValue, themeProps)
    : applyStyleAmount(rule, cssValue, themeProps);
}

export function convertSxToEmotionStyles(sx: SxProps, themeProps: BiomeTheme) {
  const stylesArray: CSSProperties[] = [];

  // @NOTE: important that we use Object.getOwnPropertyNames instead of say,
  // Object.keys, as the latter will return keys which are ordered differently from
  // their insertion order (which is quite important given that rule order matters in CSS).
  // more about this here: https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order/38218582#38218582
  Object.getOwnPropertyNames(sx).forEach(rule => {
    const typedRule = rule as keyof typeof sx;
    const value = sx[typedRule];
    const longHandRule = convertShorthandRule(typedRule);
    if (value || typeof value === 'number') {
      stylesArray.push(
        chooseWhichStylesToRender(longHandRule, value, themeProps),
      );
    }
  });

  return merge({}, ...stylesArray);
}
