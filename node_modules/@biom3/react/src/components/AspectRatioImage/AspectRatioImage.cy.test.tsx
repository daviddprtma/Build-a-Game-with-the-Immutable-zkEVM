/* eslint-disable prefer-template */
import { onLightBase } from '@biom3/design-tokens';

import { cyMountWithProviders, cySmartGet } from '../../utils/testHelpers';
import {
  ASPECT_RATIOS,
  AspectRatio,
  AspectRatioImage,
  getAspectRatioSx,
} from './AspectRatioImage';

function getExpectedPaddingBottom(aspect: AspectRatio) {
  return parseFloat(getAspectRatioSx(aspect).paddingBottom);
}

describe('<AspectRatioImage />', () => {
  beforeEach(() => {
    cy.viewport(100, 200);
  });

  it('should have correct displayName', () => {
    expect(AspectRatioImage.displayName).to.eq('AspectRatioImage');
  });

  ASPECT_RATIOS.forEach(aspect => {
    it(`should correctly apply ${aspect} aspect ratios`, () => {
      cyMountWithProviders(
        <AspectRatioImage aspectRatio={aspect} testId="moo" />,
      );

      cySmartGet('moo__innerContainer')
        .should('have.css', 'padding-bottom')
        .then(pb => {
          const expectedPaddingBottom = getExpectedPaddingBottom(aspect);
          const parsed = parseInt(pb as unknown as string, 10);
          // @NOTE: allow for sub-pixel calc variation
          expect(parsed).to.be.within(
            expectedPaddingBottom - 1,
            expectedPaddingBottom + 1,
          );
        });
    });
  });

  it('should support responsive aspectRatio', () => {
    cyMountWithProviders(
      <AspectRatioImage aspectRatio={['1:1', null, '16:9']} testId="moo" />,
    );
    cySmartGet('moo__innerContainer')
      .should('have.css', 'padding-bottom')
      .and('eq', getExpectedPaddingBottom('1:1') + 'px');

    cy.viewport(onLightBase.breakpoint.medium, onLightBase.breakpoint.medium);

    cySmartGet('moo__innerContainer')
      .should('have.css', 'padding-bottom')
      .then(pb => {
        const expectedPaddingBottom =
          getExpectedPaddingBottom('16:9') *
          0.01 *
          onLightBase.breakpoint.medium;
        const parsed = parseInt(pb as unknown as string, 10);
        // @NOTE: allow for sub-pixel calc variation
        expect(parsed).to.be.within(
          expectedPaddingBottom - 1,
          expectedPaddingBottom + 1,
        );
      });
  });

  it('should support responsive objectFit', () => {
    cyMountWithProviders(
      <AspectRatioImage
        aspectRatio="1:1"
        objectFit={['contain', null, 'cover']}
        testId="moo"
      />,
    );
    cySmartGet('moo__innerContainer__cloudImage--defaultImage')
      .should('have.css', 'object-fit')
      .and('eq', 'contain');
    cy.viewport(onLightBase.breakpoint.medium, 200);
    cySmartGet('moo__innerContainer__cloudImage--defaultImage')
      .should('have.css', 'object-fit')
      .and('eq', 'cover');
  });

  it('should support responsive objectPosition', () => {
    cyMountWithProviders(
      <AspectRatioImage
        aspectRatio="1:1"
        objectPosition={['50%', null, '20% 50%']}
        testId="moo"
      />,
    );
    cySmartGet('moo__innerContainer__cloudImage--defaultImage')
      .should('have.css', 'object-position')
      .and('eq', '50% 50%');
    cy.viewport(onLightBase.breakpoint.medium, 200);
    cySmartGet('moo__innerContainer__cloudImage--defaultImage')
      .should('have.css', 'object-position')
      .and('eq', '20% 50%');
  });

  it('should correctly forward domRef', () => {
    const domRef = cy.stub().as('domRefStub');
    cyMountWithProviders(<AspectRatioImage domRef={domRef} />);
    cySmartGet('@domRefStub').should('have.been.calledWithMatch', {
      nodeName: 'DIV',
    });
  });

  it('should correctly accept custom sx input', () => {
    cyMountWithProviders(<AspectRatioImage testId="moo" sx={{ bg: 'gold' }} />);
    cySmartGet('moo').should('have.backgroundColor', 'gold');
  });
});
