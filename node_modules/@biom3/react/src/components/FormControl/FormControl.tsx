import { PropsOf } from '@emotion/react';
import {
  Children,
  isValidElement,
  ReactElement,
  ReactNode,
  useId,
} from 'react';
import merge from 'ts-deepmerge';

import { useGetSubcomponentChild } from '../../hooks';
import { InputTextAlign, InputValidationStatus } from '../../types/input';
import { Autocomplete } from '../Autocomplete';
import { Box, BoxWithRCAndDomProps } from '../Box';
import { Checkbox } from '../Checkbox';
import { NumberStepper } from '../NumberStepper';
import { Radio } from '../Radio';
import { Select } from '../Select';
import { SmartClone } from '../SmartClone';
import { TextArea } from '../TextArea';
import { TextInput } from '../TextInput';
import { DEFAULT_TEXT_INPUT_ALIGN } from '../TextInput/shared';
import { Toggle } from '../Toggle';
import { FormControlCaption } from './FormControlCaption';
import { FormControlLabel } from './FormControlLabel';
import { FormControlValidation } from './FormControlValidation';

export type FormControlProps<RC extends ReactElement | undefined = undefined> =
  BoxWithRCAndDomProps<RC> & {
    children?: ReactNode;
    id?: string;
    validationStatus?: InputValidationStatus;
    textAlign?: InputTextAlign;
  };

const SUPPORTED_INPUT_COMPONENTS = [
  TextArea,
  TextInput,
  Checkbox,
  Toggle,
  Radio,
  Select,
  Autocomplete,
  NumberStepper,
] as const;

export function FormControl<RC extends ReactElement | undefined = undefined>({
  domRef,
  sx = {},
  id: idProp,
  testId,
  children,
  validationStatus,
  textAlign = DEFAULT_TEXT_INPUT_ALIGN,
  ...domAttributes
}: FormControlProps<RC>) {
  const fallbackId = useId();
  const id = idProp || fallbackId;
  const label = useGetSubcomponentChild(children, FormControlLabel);
  const caption = useGetSubcomponentChild(children, FormControlCaption);
  const validation = useGetSubcomponentChild(children, FormControlValidation);

  // Typescript struggles to type 'find' and infer prop types, so we need to cast here.
  const inputComponent = Children.toArray(children).find(child =>
    SUPPORTED_INPUT_COMPONENTS.some(
      inputEl => isValidElement(child) && child.type === inputEl,
    ),
  ) as ReactElement<PropsOf<(typeof SUPPORTED_INPUT_COMPONENTS)[number]>>;

  const shouldUseColumnBasedLayout =
    isValidElement(inputComponent) &&
    (inputComponent.type === TextArea ||
      inputComponent.type === TextInput ||
      inputComponent.type === Select ||
      inputComponent.type === Autocomplete ||
      inputComponent.type === NumberStepper);

  return (
    <Box
      {...domAttributes}
      domRef={domRef}
      testId={testId}
      sx={merge(
        {
          display: 'flex',
          flexDirection: shouldUseColumnBasedLayout ? 'column' : 'row',
          gap: 'base.spacing.x1',
        },
        sx,
      )}
    >
      {shouldUseColumnBasedLayout ? (
        <>
          {label && (
            <SmartClone
              textAlign={label.props.textAlign || textAlign}
              htmlFor={id}
            >
              {label}
            </SmartClone>
          )}
          {inputComponent && (
            <SmartClone
              textAlign={inputComponent.props.textAlign || textAlign}
              id={id}
              validationStatus={
                inputComponent.props.validationStatus || validationStatus
              }
            >
              {inputComponent}
            </SmartClone>
          )}
          {caption && (
            <SmartClone
              textAlign={caption.props.textAlign || textAlign}
              htmlFor={id}
            >
              {caption}
            </SmartClone>
          )}
          {validation && (
            <SmartClone
              htmlFor={id}
              textAlign={validation.props.textAlign || textAlign}
              validationStatus={
                validation.props.validationStatus || validationStatus
              }
            >
              {validation}
            </SmartClone>
          )}
        </>
      ) : (
        <>
          <Box
            sx={{
              d: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
            }}
          >
            {label && (
              <SmartClone
                textAlign={label.props.textAlign || textAlign}
                htmlFor={id}
              >
                {label}
              </SmartClone>
            )}
            {caption && (
              <SmartClone
                htmlFor={id}
                textAlign={caption.props.textAlign || textAlign}
              >
                {caption}
              </SmartClone>
            )}
            {validation && (
              <SmartClone
                htmlFor={id}
                textAlign={validation.props.textAlign || textAlign}
                validationStatus={
                  validation.props.validationStatus || validationStatus
                }
              >
                {validation}
              </SmartClone>
            )}
          </Box>

          {inputComponent && (
            <SmartClone
              id={id}
              validationStatus={
                inputComponent.props.validationStatus || validationStatus
              }
              sx={merge(
                {
                  order: textAlign === 'left' ? '-1' : '1',
                  ...(textAlign === 'left'
                    ? { mr: 'base.spacing.x2' }
                    : { ml: 'base.spacing.x2' }),
                },
                { ...inputComponent.props.sx },
              )}
            >
              {inputComponent}
            </SmartClone>
          )}
        </>
      )}
    </Box>
  );
}

FormControl.displayName = 'FormControl';
FormControl.Label = FormControlLabel;
FormControl.Validation = FormControlValidation;
FormControl.Caption = FormControlCaption;
