import {
  Children,
  cloneElement,
  ReactElement,
  useContext,
  useEffect,
  useState,
} from 'react';
import merge from 'ts-deepmerge';

import { useForwardLocalDomRef, useTheme } from '../../hooks';
import { useWindowSizeStore } from '../../providers/BiomeWindowSize';
import { isChildSubcomponent, renderNullAndWarnUser } from '../../utils';
import { Box, BoxWithRCAndDomProps } from '../Box';
import { TableContext } from './context';
import { TableRow } from './TableRow';

export type TableHeadProps<RC extends ReactElement | undefined = undefined> =
  BoxWithRCAndDomProps<RC>;

export function TableHead<RC extends ReactElement | undefined = undefined>({
  children,
  sx = {},
  rc = <thead />,
  className,
  testId: testIdProp,
  domRef = { current: null },
  ...props
}: TableHeadProps<RC>) {
  const {
    testId,
    stickyHeaders,
    setThWidths,
    horizontalSpacing,
    verticalSpacing,
  } = useContext(TableContext);
  const { base } = useTheme();
  const localRef = useForwardLocalDomRef(domRef);
  const [measurementsTaken, setMeasurementsTaken] = useState(false);
  const { state: width } = useWindowSizeStore(state => state.width);

  useEffect(() => {
    if (localRef.current && !measurementsTaken) {
      const ths = localRef.current.querySelectorAll('th');

      setThWidths(() => {
        const widths = Array.from(ths).map(th => {
          return th.getBoundingClientRect().width;
        });
        setTimeout(() => setMeasurementsTaken(true), 0);
        return widths;
      });
    }
  }, [measurementsTaken, setThWidths, localRef]);
  useEffect(() => {
    setMeasurementsTaken(false);
  }, [
    width,
    horizontalSpacing,
    verticalSpacing,
    stickyHeaders,
    base.colorMode,
  ]);

  return (
    <Box
      {...props}
      rc={rc}
      testId={`${testIdProp ?? testId}__thead`}
      className={`${className ?? ''} thead`}
      domRef={localRef}
      sx={merge(
        {
          ...(stickyHeaders && measurementsTaken
            ? {
                '& th': {
                  display: 'none',
                },
              }
            : {}),
          ...(stickyHeaders && !measurementsTaken
            ? {
                '& th': {
                  opacity: 0,
                },
              }
            : {}),
        },
        sx,
      )}
    >
      {Children.map(children, child => {
        if (isChildSubcomponent(child, TableRow)) {
          return cloneElement(child, { parentNode: 'thead' });
        }

        return renderNullAndWarnUser(TableHead.displayName);
      })}
    </Box>
  );
}

TableHead.displayName = 'Table.Head';
