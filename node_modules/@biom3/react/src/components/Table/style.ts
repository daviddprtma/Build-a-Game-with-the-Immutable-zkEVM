import merge from 'ts-deepmerge';

import { MakeResponsive, MakeWriteable } from '../../types/shared';
import { SxProps } from '../../types/sxProps';
import { BiomeTheme } from '../../types/theme';
import { vFlex } from '../../utils/sxChunks';
import { isError } from '../../utils/textStyleHelpers';
import { TableSpacing } from './shared';

export const baseContainerSx = {
  ...vFlex,
  alignItems: 'flex-start',
  maxw: '100%',
  margin: '0 auto',
  position: 'relative',
};

export const baseTableStyle = {
  border: 'none',
  borderCollapse: 'collapse',
  d: 'block',
  textAlign: 'left',
  maxw: '100%',
  m: '0',
  overflowX: 'auto',
  borderRadius: 'base.borderRadius.x6',

  '&.stickyHeaders': {
    bradtl: '0px',
    bradtr: '0px',
    bradbl: 'base.borderRadius.x6',
    bradbr: 'base.borderRadius.x6',
  },

  '&.tableBorder': {
    border: '1px solid',
    borderColor: 'base.color.translucent.standard.200',
  },

  '&.stickyHeaders.tableBorder': {
    borderTopWidth: '0px',
  },

  '&.stickyTable.tableBorder': {
    border: 'none',
  },

  '&.columnBorder .td, &.columnBorder .th': {
    borderRight: '1px solid',
    borderColor: 'base.color.translucent.standard.200',
  },

  '&.rowBorder .td, &.rowBorder .th': {
    borderBottom: '1px solid',
    borderColor: 'base.color.translucent.standard.200',
  },

  '&.rowBorder .th': {
    borderColor: 'base.color.translucent.standard.300',
  },

  '& thead .tr': {
    bg: 'base.color.translucent.emphasis.400',
  },

  '& .th': {
    bg: 'base.color.translucent.emphasis.400',
  },

  '& tbody .tr': {
    bg: 'base.color.translucent.emphasis.200',
  },

  '& .tbody .td': {
    bg: 'transparent',
    transitionDuration: 'base.motion.normal.fast.cssDuration',
    transitionTimingFunction: 'base.motion.normal.fast.cssEase',
    transitionProperty: 'background',
  },

  '&.rowHoverFx .tbody tr:hover .td': {
    bg: 'base.color.translucent.standard.50',
  },

  '&.stripedBg .tbody .tr:nth-of-type(odd) .td': {
    bg: 'base.color.translucent.standard.100',
  },

  '&.stripedBg.rowHoverFx .tbody .tr:nth-of-type(odd):hover .td': {
    bg: 'base.color.translucent.standard.150',
  },
};

export const baseStickyContainerSx = {
  position: 'sticky',
  top: '0',
  left: '0',
  width: '100%',
  overflow: 'clip',
  zIndex: 1,
  backdropFilter: 'blur(8px)',

  '&.tableBorder': {
    border: '1px solid',
    borderColor: 'base.color.translucent.standard.200',
    borderBottomWidth: '0px',
  },

  '& thead th': {
    textShadow: ({ base }: BiomeTheme) =>
      `0px 1px 2px ${base.color.translucent.inverse[700]}`,
  },
};

export function getCellSx({
  horizontalSpacing,
  verticalSpacing,
  theme: { base },
}: {
  horizontalSpacing?: TableSpacing;
  verticalSpacing?: TableSpacing;
  theme: BiomeTheme;
}) {
  const style: MakeWriteable<SxProps, string> = {};

  switch (horizontalSpacing) {
    case 'xxSmall':
      style.px = base.spacing.x1;
      break;

    case 'xSmall':
      style.px = base.spacing.x2;
      break;

    case 'small':
      style.px = base.spacing.x3;
      break;

    case 'xLarge':
      style.px = base.spacing.x8;
      break;

    case 'xxLarge':
      style.px = base.spacing.x10;
      break;

    case 'medium':
      style.px = base.spacing.x6;
      break;

    default:
      break;
  }

  switch (verticalSpacing) {
    case 'xxSmall':
      style.py = base.spacing.x1;
      break;

    case 'xSmall':
      style.py = base.spacing.x2;
      break;

    case 'small':
      style.py = base.spacing.x3;
      break;

    case 'xLarge':
      style.py = base.spacing.x8;
      break;

    case 'xxLarge':
      style.py = base.spacing.x10;
      break;

    case 'medium':
      style.py = base.spacing.x6;
      break;

    default:
      break;
  }

  return style;
}

export function getResponsiveCellSx({
  horizontalSpacing,
  verticalSpacing,
  theme,
}: {
  horizontalSpacing?: MakeResponsive<TableSpacing>;
  verticalSpacing?: MakeResponsive<TableSpacing>;
  theme: BiomeTheme;
}) {
  const horizontalSpacingAsArray = Array.isArray(horizontalSpacing)
    ? [...horizontalSpacing]
    : [horizontalSpacing];
  horizontalSpacingAsArray.shift();
  const verticalSpacingAsArray = Array.isArray(verticalSpacing)
    ? [...verticalSpacing]
    : [verticalSpacing];
  verticalSpacingAsArray.shift();

  const horizontalSizeStyles = merge(
    ...horizontalSpacingAsArray.map((responsiveSize, index) => {
      if (responsiveSize != null && !isError(responsiveSize)) {
        const mediaStyleRule = `@media screen and (min-width: ${theme.base.breakpointAsArray?.[index]}px)`;
        return {
          [mediaStyleRule]: getCellSx({
            horizontalSpacing: responsiveSize,
            theme,
          }),
        };
      }
      return {};
    }),
  );

  const verticalSizeStyles = merge(
    ...verticalSpacingAsArray.map((responsiveSize, index) => {
      if (responsiveSize != null && !isError(responsiveSize)) {
        const mediaStyleRule = `@media screen and (min-width: ${theme.base.breakpointAsArray?.[index]}px)`;
        return {
          [mediaStyleRule]: getCellSx({
            verticalSpacing: responsiveSize,
            theme,
          }),
        };
      }
      return {};
    }),
  );

  return merge(horizontalSizeStyles, verticalSizeStyles);
}

export const baseCaptionSx = {
  captionSide: 'bottom',
  textAlign: 'left',
  order: 3,
  c: 'base.color.text.secondary',
};

export const baseTdSx = {
  verticalAlign: 'middle',
};

export function getCaptionSx({
  verticalSpacing,
  theme: { base },
}: {
  verticalSpacing?: TableSpacing;
  theme: BiomeTheme;
}) {
  switch (verticalSpacing) {
    case 'xxSmall':
      return { '--captionGap': base.spacing.x1 };

    case 'xSmall':
      return { '--captionGap': base.spacing.x2 };

    case 'small':
      return { '--captionGap': base.spacing.x3 };

    case 'xLarge':
      return { '--captionGap': base.spacing.x8 };

    case 'xxLarge':
      return { '--captionGap': base.spacing.x10 };

    case 'medium':
    default:
      return { '--captionGap': base.spacing.x6 };
  }
}

export function getResponsiveCaptionSx({
  verticalSpacing,
  theme,
}: {
  verticalSpacing?: MakeResponsive<TableSpacing>;
  theme: BiomeTheme;
}) {
  const verticalSpacingAsArray = Array.isArray(verticalSpacing)
    ? [...verticalSpacing]
    : [verticalSpacing];
  verticalSpacingAsArray.shift();

  return merge(
    ...verticalSpacingAsArray.map((responsiveSize, index) => {
      if (responsiveSize != null && !isError(responsiveSize)) {
        const mediaStyleRule = `@media screen and (min-width: ${theme.base.breakpointAsArray?.[index]}px)`;
        return {
          [mediaStyleRule]: getCaptionSx({
            verticalSpacing: responsiveSize,
            theme,
          }),
        };
      }
      return {};
    }),
  );
}
