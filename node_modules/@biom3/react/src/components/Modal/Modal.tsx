import {
  cloneElement,
  ComponentType,
  useCallback,
  useEffect,
  useId,
  useMemo,
} from 'react';

import {
  useBrowserEffect,
  useBrowserLayoutEffect,
  useForwardLocalDomRef,
  useGetSubcomponentChild,
} from '../../hooks';
import {
  CLOSE_MODAL,
  OPEN_MODAL,
  UPDATE_MODAL_PROPS,
  useOverlaysStore,
} from '../../providers/BiomeOverlaysProvider';
import { ModalComponentProps } from '../../types/overlays';
import { SmartClone } from '../SmartClone';
import { ModalContent, ModalContentProps } from './ModalContent';
import { ModalTarget } from './ModalTarget';

export function Modal({
  visible,
  id: idProp,
  children,
  domRef = { current: null },
  onCloseModal,
  showBgOverlay = true,
  bgOverlaySx = {},
  fullScreenUntilBreakpoint,
  outsideClicksClose = true,
  position = { x: 'center', y: 'center' },
  testId = 'modal',
  ContentSubcomponent = ModalContent,
}: ModalComponentProps) {
  const localDomRef = useForwardLocalDomRef(domRef);
  const fallbackId = useId();
  const id = idProp || fallbackId;
  const target = useGetSubcomponentChild(children, ModalTarget);
  const content = useGetSubcomponentChild(
    children,
    ContentSubcomponent as ComponentType<ModalContentProps<undefined>>,
  );

  const { state: modalList, dispatchAction } = useOverlaysStore(
    state => state.modalList,
  );
  const isControlled = useMemo(() => typeof visible !== 'undefined', [visible]);

  const modalProps = useMemo(
    () => ({
      id,
      content: content ? cloneElement(content, { id }) : null,
      targetRef: localDomRef,
      showBgOverlay,
      isControlled,
      onCloseModal,
      outsideClicksClose,
      bgOverlaySx,
      fullScreenUntilBreakpoint,
      position,
      testId,
    }),
    [
      bgOverlaySx,
      content,
      fullScreenUntilBreakpoint,
      id,
      isControlled,
      localDomRef,
      onCloseModal,
      outsideClicksClose,
      position,
      showBgOverlay,
      testId,
    ],
  );

  // @NOTE: this useEffect allows the Modal props to stay up to date,
  // as the application re-renders and things potentially change
  useEffect(() => {
    dispatchAction({
      type: UPDATE_MODAL_PROPS,
      payload: modalProps,
    });
  }, [dispatchAction, modalProps]);

  const closeModal = useCallback(() => {
    dispatchAction({
      type: CLOSE_MODAL,
      payload: { id },
    });
    onCloseModal?.();
  }, [dispatchAction, onCloseModal, id]);

  const showModal = useCallback(() => {
    dispatchAction({
      type: OPEN_MODAL,
      payload: modalProps,
    });
  }, [dispatchAction, modalProps]);

  useBrowserLayoutEffect(() => {
    if (visible) {
      showModal();
    } else if (modalList.find(modal => modal.id === id)) {
      closeModal();
    }
    // @NOTE: we want to trigger these changes ONLY when the visible prop changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visible]);

  // @NOTE: when the Modal is unmounted, call to remove it from the modalList
  useBrowserEffect(() => {
    return () => closeModal();
  }, []);

  const onClickProps = useMemo(() => {
    return !isControlled
      ? {
          onClick: () => {
            if (modalList.find(modal => modal.id === id)) {
              closeModal();
            } else {
              showModal();
            }
          },
        }
      : {};
  }, [modalList, isControlled, id, closeModal, showModal]);

  return target ? (
    <SmartClone {...onClickProps} id={id} domRef={localDomRef} testId={testId}>
      {target}
    </SmartClone>
  ) : null;
}

Modal.displayName = 'Modal';
Modal.Content = ModalContent;
Modal.Target = ModalTarget;
