/* eslint-disable react/destructuring-assignment */
/* eslint-disable react/sort-comp */
import debounce from 'lodash.debounce';
import { Component, createRef, ReactElement, ReactNode } from 'react';
import merge from 'ts-deepmerge';

import { Box, BoxWithRCAndDomProps } from '../Box';
import { Icon } from '../Icon';
import { SmartClone } from '../SmartClone';
import {
  containerSx,
  gridCss,
  loadingUiSx,
  overflowCss,
  sentinalCss,
  testItemCss,
} from './style';

// @TODO: Really would love this component to be functional, as opposed
// to a class, so that it can take advantage of all the biome hooks. :(
// Turns out, this is a lot more complicated than I thought it would be
// (given all the stages of initialisation and internal state)

type RecycleViewListItem = {
  id: number | string;
};

type GridColumnWidthRange =
  | { min: '100%' }
  | {
      min: number;
      max: number;
    };

export type RecycleViewProps<
  T extends RecycleViewListItem,
  RC extends ReactElement | undefined,
> = BoxWithRCAndDomProps<RC> &
  typeof RecycleView.defaultProps & {
    initialData: T[];
    renderItem: (item: T, itemKey?: string) => ReactNode;
    loadMoreItems?: (concattedItemsSize: number) => Promise<T[]>;
    gridColumnWidthRange?: GridColumnWidthRange;
    atEndOfData: boolean;
    gridGap?: number;
    padForCardItems?: boolean;
  };

type State<T> = {
  currentItems: T[];
};

const ACCEPTABLE_ITEM_WIDTH_RANGE: GridColumnWidthRange = {
  min: 120,
  max: 350,
};

type PerfFrameCallback = () => void;

export const notEnoughItemsWarning = (itemsCount: number, gridSize: number) =>
  `@biom3/react 
<RecycleView /> Warning: 
Pagination functionality has been disabled because you have not 
supplied enough initialData items (${itemsCount}) to power it. 
If this isn't intentional, please supply more items via initialData prop.
At the current screen size, you need to supply at least ${gridSize} items.`;

export class RecycleView<
  T extends RecycleViewListItem,
  RC extends ReactElement | undefined,
> extends Component<RecycleViewProps<T, RC>, State<T>> {
  static displayName = 'RecycleView';

  static defaultProps = {
    padForCardItems: true,
    gridGap: 10,
    gridColumnWidthRange: ACCEPTABLE_ITEM_WIDTH_RANGE,
    // @TODO: wtf eslint. :facepalm:
    // eslint-disable-next-line react/default-props-match-prop-types
    sx: {},
  };

  constructor(props: RecycleViewProps<T, RC>) {
    super(props);
    this.state = {
      currentItems: [],
    };
  }

  private dimensions = {
    container: {
      w: 0,
      h: 0,
    },
    singleItem: {
      w: 0,
      h: 0,
      outerH: 0,
    },
  };

  private shortCircuitPagingFunctionality = false;

  private lastScroll = 0;

  private loadingMoreItems = false;

  private concattedItems: T[] = [];

  private currentColumnWidth = 0;

  private paddingTop = 0;

  private topSentinelPreviousY = 0;

  private bottomSentinelPreviousY = 0;

  private bottomSentinalIsIntersecting = false;

  private currentColumnCount = 1;

  private currentGridSize = 0;

  private currentFirstIndex = 0;

  private topIntersectionObserver: IntersectionObserver | null = null;

  private bottomIntersectionObserver: IntersectionObserver | null = null;

  private containerRef = this.props.domRef || createRef<HTMLDivElement>();

  private testItemRef = createRef<HTMLDivElement>();

  private topSentinelRef = createRef<HTMLDivElement>();

  private bottomSentinelRef = createRef<HTMLDivElement>();

  private gridRef = createRef<HTMLDivElement>();

  private overflowRef = createRef<HTMLDivElement>();

  private scrollTicking = false;

  private rAF: ((callback: PerfFrameCallback) => void) | null = null;

  private rIC: ((callback: PerfFrameCallback) => void) | null = null;

  private debouncedResize = debounce(() => {
    if (this.handleResize()) {
      this.initRecycleView();
    }
  }, 200);

  private containerResizeObserver: ResizeObserver | null = null;

  private get currentConcattedItemsDataSize() {
    return this.concattedItems.length;
  }

  // means that we always increment by 4 rows at once
  private rowIncrementAmount = 4;

  private get gridIndexIncrement() {
    return this.rowIncrementAmount * this.currentColumnCount;
  }

  private resetPadding() {
    this.paddingTop = 0;
  }

  private checkToLoadMoreItems() {
    // @NOTE: check that we are:
    // 1. not at the end of the data (props.atEndOfData)
    // 2. that the last item of currentConcattedItemsDataSize is
    // inside the currentItems array
    if (this.props.atEndOfData || this.loadingMoreItems) return false;

    const currentLastItemIndex =
      this.currentFirstIndex + this.state.currentItems.length;
    const totalItemsIndexMinusOnePage =
      this.concattedItems.length -
      Math.floor(this.state.currentItems.length * 0.5);
    return currentLastItemIndex >= totalItemsIndexMinusOnePage;
  }

  private async fetchMoreItems() {
    if (!this.props.loadMoreItems || this.loadingMoreItems) return;

    this.loadingMoreItems = true;
    const newItems = await this.props.loadMoreItems(
      this.currentConcattedItemsDataSize,
    );
    this.concattedItems = [...this.concattedItems, ...newItems];
    this.loadingMoreItems = false;
    if (this.bottomSentinalIsIntersecting) {
      this.changePaging(true);
    }
  }

  private calculateNewFirstIndex(scrollingDownwards = true) {
    let firstIndex: number;

    if (scrollingDownwards) {
      firstIndex = this.currentFirstIndex + this.gridIndexIncrement;
    } else {
      firstIndex = this.currentFirstIndex - this.gridIndexIncrement;
    }

    if (firstIndex < 0) {
      firstIndex = 0;
    }

    return firstIndex;
  }

  private changePaging(downwards: boolean) {
    const newFirstIndex = this.calculateNewFirstIndex(downwards);
    this.updatePadding(downwards);
    this.currentFirstIndex = newFirstIndex;
    this.chooseCurrentItems();
    // @TODO: add this stuff:
    if (downwards && this.checkToLoadMoreItems()) {
      this.fetchMoreItems();
    }
  }

  private updatePadding(scrollingDownwards = true) {
    const paddingOffset =
      this.dimensions.singleItem.outerH * this.rowIncrementAmount;

    if (scrollingDownwards) {
      this.paddingTop += paddingOffset;
    } else {
      this.paddingTop =
        this.paddingTop === 0 ? 0 : this.paddingTop - paddingOffset;
    }
  }

  private topSentinelCallback = ([entry]: IntersectionObserverEntry[]) => {
    if (this.shortCircuitPagingFunctionality) return;
    // Stop users from going off the page (in terms of the results set total)
    if (this.currentFirstIndex === 0) {
      this.resetPadding();
    }

    const { isIntersecting } = entry;
    const currentY = entry.boundingClientRect.top;
    const shouldChangePage =
      currentY > this.topSentinelPreviousY && isIntersecting;
    // @NOTE: if the user has scrolled up enough, trigger a new page event:
    if (shouldChangePage) {
      this.changePaging(false);
    }
    // Store current offset, for the next time:
    this.topSentinelPreviousY = currentY;
  };

  private bottomSentinelCallback = ([entry]: IntersectionObserverEntry[]) => {
    if (this.shortCircuitPagingFunctionality) return;
    const { isIntersecting } = entry;
    this.bottomSentinalIsIntersecting = isIntersecting;
    const currentY = entry.boundingClientRect.top;
    // Stop the paging from going further than the edge of the concattedItems:
    if (
      this.currentFirstIndex ===
        this.currentConcattedItemsDataSize - this.currentGridSize ||
      this.loadingMoreItems
    ) {
      this.bottomSentinelPreviousY = currentY;
      return;
    }
    const shouldChangePage =
      currentY < this.bottomSentinelPreviousY && isIntersecting;
    // @NOTE: if the user has scrolled down enough, trigger a new page event:
    if (shouldChangePage) {
      this.changePaging(true);
    }
    // Store current offset, for the next time:
    this.bottomSentinelPreviousY = currentY;
  };

  // @TODO: sadly - we cannot seem to get away without some basic onScroll
  // listening, as its pretty simple for a user to scroll so quickly that
  // they end up scrolling past the sentinels without triggering them
  // Would love to work out another way around this, which doesnt involve
  // listening to onScroll
  private debouncedOnScroll = debounce(
    () => {
      if (this.shortCircuitPagingFunctionality) return;

      if (!this.scrollTicking) {
        this.scrollTicking = true;
        this.rIC?.(() => {
          this.rAF?.(() => {
            const containerRect =
              this.overflowRef.current!.getBoundingClientRect();
            const topSentinenRect =
              this.topSentinelRef.current!.getBoundingClientRect();
            const currentScroll = this.overflowRef.current!.scrollTop;
            const isScrollingUp = currentScroll < this.lastScroll;
            const hasOverScrolled =
              topSentinenRect.top >= containerRect.top && isScrollingUp;
            if (hasOverScrolled) {
              const scrollDifference = this.lastScroll - currentScroll;
              if (scrollDifference > containerRect.height) {
                // @NOTE: jump the user back to the top of the page
                this.reset();
              } else {
                // @NOTE: jump the user to the next page upwards
                this.changePaging(false);
              }
            }
            this.lastScroll = currentScroll;
            this.scrollTicking = false;
          });
        });
      }
    },
    25,
    { leading: true },
  );

  private initListeners() {
    if (
      !this.topSentinelRef.current ||
      !this.bottomSentinelRef.current ||
      !this.overflowRef.current ||
      typeof this.containerRef === 'function' ||
      !this.containerRef.current
    ) {
      // @NOTE: early exit if we dont have all the domRef's that we need
      return;
    }

    if (
      !this.topIntersectionObserver ||
      !this.bottomIntersectionObserver ||
      !this.containerResizeObserver
    ) {
      this.topIntersectionObserver = new IntersectionObserver(
        this.topSentinelCallback,
        {
          root: this.overflowRef.current,
        },
      );
      this.bottomIntersectionObserver = new IntersectionObserver(
        this.bottomSentinelCallback,
        {
          root: this.overflowRef.current,
        },
      );
      this.containerResizeObserver = new ResizeObserver(this.debouncedResize);
    }

    // Enable the observers:
    this.topIntersectionObserver.observe(this.topSentinelRef.current);
    this.bottomIntersectionObserver.observe(this.bottomSentinelRef.current);
    this.containerResizeObserver.observe(this.containerRef.current);

    // @NOTE: bind scroll event, to watch for "FAST" scrolls:
    this.overflowRef.current.addEventListener('scroll', this.debouncedOnScroll);
  }

  private unloadListeners() {
    if (
      !this.topSentinelRef.current ||
      !this.bottomSentinelRef.current ||
      typeof this.containerRef === 'function' ||
      !this.containerRef.current ||
      !this.overflowRef.current
    ) {
      // @NOTE: early exit if we dont have all the domRef's that we need
      return;
    }

    this.topIntersectionObserver?.unobserve(this.topSentinelRef.current);
    this.bottomIntersectionObserver?.unobserve(this.bottomSentinelRef.current);
    this.containerResizeObserver?.unobserve(this.containerRef.current);
    this.overflowRef.current.removeEventListener(
      'scroll',
      this.debouncedOnScroll,
    );
  }

  private handleResize() {
    if (
      !this.gridRef.current ||
      typeof this.containerRef === 'function' ||
      !this.containerRef.current ||
      !this.testItemRef.current
    ) {
      // @NOTE: early exit if we dont have all the domRef's that we need
      return false;
    }

    // @NOTE: grab the width of the nodePoolContainerDom,
    // because we need the width minus any scroll bars
    this.dimensions.container.w = this.gridRef.current.offsetWidth;
    this.dimensions.container.h = this.containerRef.current.offsetHeight;
    this.dimensions.singleItem.w = this.testItemRef.current.offsetWidth;
    this.dimensions.singleItem.h = this.testItemRef.current.offsetHeight;
    this.dimensions.singleItem.outerH =
      this.testItemRef.current.offsetHeight + this.props.gridGap;

    return true;
  }

  private chooseCurrentItems() {
    const newState = { ...this.state };
    newState.currentItems = this.concattedItems.slice(
      this.currentFirstIndex,
      this.currentFirstIndex + this.currentGridSize,
    );
    this.setState(newState);
  }

  private reset() {
    this.currentFirstIndex = 0;
    this.resetPadding();
    if (this.overflowRef.current) {
      this.overflowRef.current.scrollTop = 0;
    }
    this.chooseCurrentItems();
  }

  private initRecycleView() {
    // @NOTE: proceed with the initialization
    this.concattedItems = [...this.props.initialData];
    this.reset();
    this.calculateGridColumns();
    this.calculateAppropriateListSize();
    this.chooseCurrentItems();
    this.initListeners();
  }

  private calculateAppropriateListSize() {
    const {
      dimensions: { container, singleItem },
    } = this;

    if (container.h === 0) {
      return;
    }

    // @NOTE: Smaller form-factor screens require greater ratio's for the
    // total list item size vs the screen size
    // (to prevent the intersection observers from triggering during page changes)
    const heightMultiplyer =
      this.currentColumnCount === 1
        ? 6.5
        : container.h <= 150
        ? 13
        : container.h <= 250
        ? 10
        : container.h <= 500
        ? 6
        : 4;
    let rowCount = 1;
    let looping = true;
    while (looping && rowCount < 100) {
      const allRowsHeight = rowCount * singleItem.outerH;
      if (allRowsHeight >= container.h * heightMultiplyer) {
        looping = false;
      } else {
        rowCount += 1;
      }
    }

    this.currentGridSize = rowCount * this.currentColumnCount;

    // @NOTE: if the user hasnt supplied enough data
    if (this.currentGridSize >= this.props.initialData.length) {
      if (this.props.initialData.length !== 0)
        console.warn(
          notEnoughItemsWarning(
            this.props.initialData.length,
            this.currentGridSize + 1,
          ),
        );
      this.shortCircuitPagingFunctionality = true;
    } else {
      this.shortCircuitPagingFunctionality = false;
    }
  }

  private calculateGridColumns() {
    const { container } = this.dimensions;

    if (container.w === 0) {
      return;
    }

    let columnCount = 1;
    let cardWidth = container.w;

    // @NOTE: support either a row of 1 or a row of X columns
    if (
      typeof this.props.gridColumnWidthRange.min === 'number' &&
      container.w >
        (this.props.gridColumnWidthRange.min + this.props.gridGap * 2) * 2
    ) {
      let looping = true;
      // @NOTE: protect while loop from crashing out 50 * 200 = 8000px
      // (no desktop resolutions should ever get wider than this ...)
      while (looping && columnCount <= 50) {
        cardWidth =
          Math.floor(container.w / columnCount) -
          (this.props.gridGap * (columnCount - 1)) / columnCount;
        if (
          cardWidth <= this.props.gridColumnWidthRange.max &&
          cardWidth >= this.props.gridColumnWidthRange.min
        ) {
          looping = false;
        } else {
          columnCount += 1;
        }
      }
    }

    this.currentColumnWidth = cardWidth;
    this.currentColumnCount = columnCount;
  }

  private initPerfCallbacks() {
    // @TODO: sadly, window.requestIdleCallback is not supported by
    // Safari, so we have to use fallback to a plain callback
    this.rAF = (callback: () => void) => window.requestAnimationFrame(callback);
    this.rIC =
      'requestIdleCallback' in window
        ? (callback: () => void) =>
            window.requestIdleCallback(callback, { timeout: 100 })
        : (callback: () => void) => callback();
  }

  /* COMPONENT LIFE-CYCLE EVENTS:
  ----------------------------------------------------------------------- */

  componentDidMount() {
    this.initPerfCallbacks();

    if (this.handleResize()) {
      this.initRecycleView();
    }
  }

  componentWillUnmount() {
    this.unloadListeners();
  }

  componentDidUpdate(prevProps: RecycleViewProps<T, RC>) {
    if (
      prevProps.initialData?.[0]?.id !== this.props.initialData?.[0]?.id &&
      this.handleResize()
    ) {
      // @NOTE: save off a copy of the initialData - so that we can concat
      // it with any new data that comes in
      this.initRecycleView();
    }
  }

  /* COMPONENT RENDER:
  ----------------------------------------------------------------------- */

  render() {
    const {
      gridGap,
      padForCardItems,
      rc,
      testId,
      sx,
      initialData,
      renderItem,
      loadMoreItems,
      gridColumnWidthRange,
      atEndOfData,
      className,
      ...otherDomProps
    } = this.props;
    return (
      <Box
        {...otherDomProps}
        rc={rc || <div />}
        domRef={this.containerRef}
        testId={testId}
        sx={merge(containerSx, sx) as BoxWithRCAndDomProps<undefined>['sx']}
        className={`${className ?? ''} container`}
      >
        <div
          ref={this.testItemRef}
          css={testItemCss}
          style={{
            width: `${this.currentColumnWidth}px`,
          }}
          className="testItem"
        >
          {this.props.initialData[0] &&
            this.props.renderItem(this.props.initialData[0], 'testElement')}
        </div>
        <div
          css={overflowCss(this.props.padForCardItems)}
          className="overflow"
          ref={this.overflowRef}
        >
          <div
            css={{
              position: 'relative',
              paddingTop: `${this.paddingTop}px`,
              minHeight: '100%',
            }}
            className="overflow-inner"
          >
            <div
              data-sentinel="top"
              ref={this.topSentinelRef}
              css={merge(sentinalCss, {
                top: `${this.paddingTop}px`,
              })}
            />
            <div
              css={gridCss(this.props.padForCardItems, this.props.gridGap)}
              ref={this.gridRef}
              className="grid"
            >
              {this.state.currentItems.map(item => {
                return (
                  <SmartClone
                    sx={{
                      width: `${this.currentColumnWidth}px`,
                    }}
                    key={item.id}
                  >
                    {this.props.renderItem(item)}
                  </SmartClone>
                );
              })}
              {this.loadingMoreItems && (
                <Box sx={loadingUiSx} className="loading-container">
                  <Icon icon="Loading" sx={{ width: 'base.icon.size.300' }} />
                </Box>
              )}
            </div>

            <div
              data-sentinel="bottom"
              ref={this.bottomSentinelRef}
              css={merge(sentinalCss, {
                bottom: '0px',
              })}
            />
          </div>
        </div>
      </Box>
    );
  }
}

RecycleView.displayName = 'RecycleView';
