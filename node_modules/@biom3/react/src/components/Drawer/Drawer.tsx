import { cloneElement, useCallback, useEffect, useId, useMemo } from 'react';

import {
  useBrowserEffect,
  useBrowserLayoutEffect,
  useForwardLocalDomRef,
  useGetSubcomponentChild,
} from '../../hooks';
import {
  CLOSE_DRAWER,
  OPEN_DRAWER,
  UPDATE_DRAWER_PROPS,
  useOverlaysStore,
} from '../../providers/BiomeOverlaysProvider';
import {
  DEFAULT_DRAWER_POSITION,
  DEFAULT_DRAWER_SIZE,
  DrawerComponentProps,
} from '../../types/overlays';
import { SmartClone } from '../SmartClone';
import { DrawerContent } from './DrawerContent';
import { DrawerTarget } from './DrawerTarget';

export function Drawer({
  visible,
  id: idProp,
  children,
  size = DEFAULT_DRAWER_SIZE,
  domRef = { current: null },
  showHeaderBar = true,
  onCloseDrawer,
  showBgOverlay = true,
  headerBarTitle,
  outsideClicksClose = true,
  drawerPosition = DEFAULT_DRAWER_POSITION,
  testId = 'Drawer',
}: DrawerComponentProps) {
  const localDomRef = useForwardLocalDomRef(domRef);
  const fallbackId = useId();
  const id = idProp || fallbackId;
  const target = useGetSubcomponentChild(children, DrawerTarget);
  const content = useGetSubcomponentChild(children, DrawerContent);

  const { state: drawerList, dispatchAction } = useOverlaysStore(
    state => state.drawerList,
  );

  const isControlled = useMemo(() => typeof visible !== 'undefined', [visible]);

  const drawerProps = useMemo(
    () => ({
      id,
      content: content ? cloneElement(content, { id }) : null,
      size,
      targetRef: localDomRef,
      headerBarTitle,
      showHeaderBar,
      showBgOverlay,
      isControlled,
      onCloseDrawer,
      outsideClicksClose,
      drawerPosition,
      testId,
    }),
    [
      content,
      drawerPosition,
      headerBarTitle,
      id,
      isControlled,
      localDomRef,
      onCloseDrawer,
      outsideClicksClose,
      showBgOverlay,
      showHeaderBar,
      size,
      testId,
    ],
  );

  // @NOTE: this useEffect allows Drawer props to stay up to date,
  // as the application re-renders and things potentially change
  useEffect(() => {
    dispatchAction({
      type: UPDATE_DRAWER_PROPS,
      payload: drawerProps,
    });
  }, [dispatchAction, drawerProps]);

  const closeDrawer = useCallback(() => {
    dispatchAction({
      type: CLOSE_DRAWER,
      payload: { id },
    });
    onCloseDrawer?.();
  }, [dispatchAction, onCloseDrawer, id]);

  const showDrawer = useCallback(() => {
    dispatchAction({
      type: OPEN_DRAWER,
      payload: drawerProps,
    });
  }, [dispatchAction, drawerProps]);

  useBrowserLayoutEffect(() => {
    if (visible) {
      showDrawer();
    } else if (drawerList.find(bottomSheet => bottomSheet.id === id)) {
      closeDrawer();
    }
    // @NOTE: we want to trigger these changes ONLY when the visible prop changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visible]);

  // @NOTE: when the Drawer is unmounted, call to remove it from the modalList
  useBrowserEffect(() => {
    return () => closeDrawer();
  }, []);

  const onClickProps = useMemo(() => {
    return !isControlled
      ? {
          onClick: () => {
            if (drawerList.find(bottomSheet => bottomSheet.id === id)) {
              closeDrawer();
            } else {
              showDrawer();
            }
          },
        }
      : {};
  }, [drawerList, isControlled, id, closeDrawer, showDrawer]);

  return target ? (
    <SmartClone {...onClickProps} id={id} domRef={localDomRef}>
      {target}
    </SmartClone>
  ) : null;
}

Drawer.displayName = 'Drawer';
Drawer.Content = DrawerContent;
Drawer.Target = DrawerTarget;
