import { base } from '@biom3/design-tokens';
import { motion } from 'framer-motion';
import {
  Children,
  JSXElementConstructor,
  ReactElement,
  ReactNode,
  useId,
  useMemo,
  useState,
} from 'react';
import merge from 'ts-deepmerge';

import {
  useBrowserEffect,
  useBrowserLayoutEffect,
  useForwardLocalDomRef,
  useGetSubcomponentChild,
  useGetSubcomponentChildren,
  useResizeObserver,
  useTheme,
} from '../../hooks';
import { useWindowSizeStore } from '../../providers';
import { getStartingSize } from '../../utils/styleHelpers';
import { getSubcomponentChild } from '../../utils/subcomponentHelpers';
import { BaseClickable } from '../Clickable';
import { Popover } from '../Popover';
import { SmartClone } from '../SmartClone';
import { SvgIcon } from '../SvgIcon';
import {
  DEFAULT_TEXT_INPUT_ALIGN,
  DEFAULT_TEXT_INPUT_SIZE,
  TEXT_INPUT_SIZES,
} from '../TextInput/shared';
import {
  baseInputSx,
  inputContainerBaseSx,
  inputIconBaseSx,
  renderContainerStyles,
  renderInputSx,
  renderResponsiveContainerStyles,
  renderResponsiveInputSx,
} from '../TextInput/styles';
import { VerticalMenu } from '../VerticalMenu';
import { Option } from './Option';
import { SelectDefaultFramedImage } from './SelectDefaultFramedImage';
import { SelectDefaultIcon } from './SelectDefaultIcon';
import { chevronSx, selectCustomSx } from './styles';
import {
  DEFAULT_SELECT_SIZE,
  OnOptionClick,
  OptionKey,
  OptionProps,
  SelectProps,
} from './types';

function pickAnOption(selectedOption?: OptionKey, options?: ReactNode) {
  return typeof selectedOption !== 'undefined' && Array.isArray(options)
    ? (options.find(
        option => option.props.optionKey === selectedOption,
      ) as ReactElement<
        OptionProps,
        string | JSXElementConstructor<OptionProps>
      >)
    : null;
}

export const noOptionFoundErrorText = (selectedOption: OptionKey | undefined) =>
  `No <Option> found for selectedOption: ${selectedOption}`;

export function Select({
  children,
  validationStatus,
  defaultLabel = 'Select an option',
  sx = {},
  popoverContainerSx = {},
  onSelectChange,
  domRef = { current: null },
  testId = 'Select',
  id: idProp,
  size = DEFAULT_SELECT_SIZE,
  textAlign = DEFAULT_TEXT_INPUT_ALIGN,
  targetClickOveride,
  disabled,
  ...props
}: SelectProps) {
  const { selectedOption, defaultOption, ...otherProps } =
    'selectedOption' in props
      ? { ...props, defaultOption: undefined }
      : {
          ...props,
          selectedOption: undefined,
        };

  const theme = useTheme();
  const [selectedOptionChildren, setSelectedOptionChildren] =
    useState<ReactNode | null>(null);
  const localRef = useForwardLocalDomRef(domRef);
  const [popoverVisible, setPopoverVisible] = useState(false);
  const options = useGetSubcomponentChildren(children, Option);
  const defaultIcon = useGetSubcomponentChild(children, SelectDefaultIcon);
  const defaultFramedImage = useGetSubcomponentChild(
    children,
    SelectDefaultFramedImage,
  );
  const targetSize = useResizeObserver(localRef, 30);
  const fallbackId = useId();
  const id = idProp || fallbackId;
  const {
    state: { width: windowWidth },
  } = useWindowSizeStore(store => store);

  // @NOTE: collect up specific children, depending on the current
  // state of the Select component
  const { selectedOptionFramedImage, selectedOptionIcon, selectedOptionText } =
    useMemo(
      () => ({
        selectedOptionFramedImage: getSubcomponentChild(
          selectedOptionChildren,
          Option.FramedImage,
        ),
        selectedOptionIcon: getSubcomponentChild(
          selectedOptionChildren,
          Option.Icon,
        ),
        selectedOptionText: getSubcomponentChild(
          selectedOptionChildren,
          Option.Label,
        ),
      }),
      [selectedOptionChildren],
    );

  // @NOTE: setup controlled API selection children
  const controlledSelectionFramedImage = useMemo(() => {
    if (selectedOption === null) return null;
    const pickedOption = pickAnOption(selectedOption, options);
    if (pickedOption && pickedOption?.props.children) {
      return getSubcomponentChild(
        pickedOption.props.children,
        Option.FramedImage,
      );
    }
    if (selectedOption !== undefined) {
      throw new Error(noOptionFoundErrorText(selectedOption));
    }
    return false;
  }, [options, selectedOption]);
  const controlledSelectionIcon = useMemo(() => {
    if (selectedOption === null) return null;
    const pickedOption = pickAnOption(selectedOption, options);
    if (pickedOption && pickedOption?.props.children) {
      return getSubcomponentChild(pickedOption.props.children, Option.Icon);
    }
    if (selectedOption !== undefined) {
      throw new Error(noOptionFoundErrorText(selectedOption));
    }
    return false;
  }, [options, selectedOption]);
  const controlledSelectionText = useMemo(() => {
    if (selectedOption === null) return null;
    const pickedOption = pickAnOption(selectedOption, options);
    if (pickedOption && pickedOption?.props.children) {
      return getSubcomponentChild(pickedOption.props.children, Option.Label);
    }
    if (selectedOption !== undefined) {
      throw new Error(noOptionFoundErrorText(selectedOption));
    }
    return false;
  }, [options, selectedOption]);

  const startingSize = useMemo(
    () => getStartingSize(size, DEFAULT_TEXT_INPUT_SIZE, TEXT_INPUT_SIZES),
    [size],
  );
  const leftSideContent = useMemo(
    () =>
      defaultIcon ||
      defaultFramedImage ||
      controlledSelectionIcon ||
      controlledSelectionFramedImage ||
      selectedOptionIcon ||
      selectedOptionFramedImage,
    [
      controlledSelectionFramedImage,
      controlledSelectionIcon,
      defaultFramedImage,
      defaultIcon,
      selectedOptionFramedImage,
      selectedOptionIcon,
    ],
  );
  const allButtonSx = useMemo(
    () =>
      merge(
        inputContainerBaseSx,
        baseInputSx,
        renderContainerStyles({ size: startingSize, theme }),
        renderResponsiveContainerStyles({
          size,
          theme,
        }),
        renderInputSx({
          validationStatus,
          leftHandButtonsWidth: leftSideContent ? 24 : 0,
          rightHandButtonsWidth: 0,
          textAlign,
          theme,
          hasValue: Boolean(selectedOptionText || controlledSelectionText),
        }),
        renderResponsiveInputSx({
          theme,
          size,
          validationStatus,
          leftHandButtonsWidth: leftSideContent ? 24 : 0,
          rightHandButtonsWidth: 0,
          textAlign,
          hasValue: Boolean(selectedOptionText || controlledSelectionText),
        }),
        selectCustomSx({ textAlign, disabled }),
        sx,
      ),
    [
      leftSideContent,
      size,
      startingSize,
      sx,
      textAlign,
      theme,
      validationStatus,
      disabled,
      selectedOptionText,
      controlledSelectionText,
    ],
  );

  const leftContentStyles = useMemo(
    () => merge(inputIconBaseSx, { mr: '0' }),
    [],
  );
  const rightChevronSx = useMemo(() => merge(chevronSx), []);

  // @NOTE: life cycle stuff below here:
  // ------------------------------------------------------------------

  useBrowserLayoutEffect(() => {
    // @NOTE: if the popover is visible, and the window width changes,
    // close it, so it doesnt look out of place ...
    setPopoverVisible(false);
  }, [windowWidth, setPopoverVisible]);

  // @NOTE: When selectedOption is null, we need to clear out any
  // selected option children, BUT ONLY when we're in controlled mode
  useBrowserEffect(() => {
    if (selectedOption === null && selectedOptionChildren) {
      setSelectedOptionChildren(null);
    }
  }, [selectedOption, selectedOptionChildren]);

  useBrowserEffect(() => {
    if (defaultOption !== undefined) {
      const pickedOption = pickAnOption(defaultOption, options);
      setSelectedOptionChildren(pickedOption?.props.children);
    }
  }, [defaultOption]);

  return (
    <Popover
      domRef={localRef}
      position={{ x: textAlign, y: 'below' }}
      visible={popoverVisible}
      id={id}
      onOutsideClick={() => setPopoverVisible(false)}
    >
      <Popover.Target>
        <BaseClickable
          {...otherProps}
          disabled={disabled}
          testId={`${testId}__target`}
          sx={allButtonSx}
          onClick={event => {
            if (targetClickOveride) {
              targetClickOveride?.(event);
            } else {
              setPopoverVisible(!popoverVisible);
            }
          }}
        >
          {typeof selectedOption !== 'undefined' && selectedOption !== null ? (
            <>
              {controlledSelectionFramedImage ? (
                <SmartClone
                  testId={`${testId}__target__controlledFramedImage`}
                  sx={leftContentStyles}
                >
                  {controlledSelectionFramedImage}
                </SmartClone>
              ) : controlledSelectionIcon ? (
                <SmartClone
                  testId={`${testId}__target__controlledIcon`}
                  sx={leftContentStyles}
                >
                  {controlledSelectionIcon}
                </SmartClone>
              ) : (
                defaultFramedImage || defaultIcon || null
              )}

              <SmartClone
                testId={`${testId}__target__controlledLabel`}
                size="small"
              >
                {controlledSelectionText}
              </SmartClone>
            </>
          ) : selectedOptionChildren ? (
            <>
              {selectedOptionFramedImage ? (
                <SmartClone
                  testId={`${testId}__target__selectedFramedImage`}
                  sx={leftContentStyles}
                >
                  {selectedOptionFramedImage}
                </SmartClone>
              ) : selectedOptionIcon ? (
                <SmartClone
                  testId={`${testId}__target__selectedIcon`}
                  sx={leftContentStyles}
                >
                  {selectedOptionIcon}
                </SmartClone>
              ) : (
                defaultFramedImage || defaultIcon || null
              )}

              <SmartClone
                testId={`${testId}__target__selectedLabel`}
                size="small"
              >
                {selectedOptionText}
              </SmartClone>
            </>
          ) : (
            <>
              {defaultFramedImage ? (
                <SmartClone testId={`${testId}__target__defaultFramedImage`}>
                  {defaultFramedImage}
                </SmartClone>
              ) : defaultIcon ? (
                <SmartClone testId={`${testId}__target__defaultIcon`}>
                  {defaultIcon}
                </SmartClone>
              ) : null}

              <SmartClone
                testId={`${testId}__target__defaultLabel`}
                size="small"
              >
                {defaultLabel}
              </SmartClone>
            </>
          )}

          <SvgIcon className="chevron" sx={rightChevronSx} rc={<motion.svg />}>
            <motion.path
              initial="down"
              variants={{
                down: {
                  d: 'M5 9L12 16L19 9',
                },
                up: {
                  d: 'M5 16L12 9L19 16',
                },
              }}
              animate={popoverVisible ? 'up' : 'down'}
              transition={{
                ease: base.motion.normal.fast.jsEase,
                duration: base.motion.normal.fast.jsDuration,
              }}
            />
          </SvgIcon>
        </BaseClickable>
      </Popover.Target>

      <Popover.Content
        testId={`${testId}__content`}
        sx={merge(
          {
            w: `${targetSize.width}px`,
            boxShadow: 'base.shadow.500',
            bradbl: 'base.borderRadius.x6',
            bradbr: 'base.borderRadius.x6',
          },
          popoverContainerSx,
        )}
      >
        <VerticalMenu
          textAlign={textAlign}
          sx={{ minw: 'unset' }}
          testId={`${testId}__content__verticalMenu`}
        >
          {Children.map(options, child => (
            <SmartClone
              onOptionClick={
                ((childrenEls, optionKey) => {
                  setPopoverVisible(false);
                  setSelectedOptionChildren(childrenEls);
                  onSelectChange?.(optionKey);
                }) as OnOptionClick
              }
            >
              {child}
            </SmartClone>
          ))}
        </VerticalMenu>
      </Popover.Content>
    </Popover>
  );
}

Select.displayName = 'Select';
Select.DefaultFramedImage = SelectDefaultFramedImage;
Select.DefaultIcon = SelectDefaultIcon;
