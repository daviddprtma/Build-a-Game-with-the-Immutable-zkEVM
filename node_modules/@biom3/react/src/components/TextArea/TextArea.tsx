import { ClassNames } from '@emotion/react';
import { AnimatePresence } from 'framer-motion';
import {
  ChangeEvent,
  ComponentPropsWithoutRef,
  ReactElement,
  useCallback,
  useState,
} from 'react';
import merge from 'ts-deepmerge';

import {
  useConvertSxToEmotionStyles,
  useForwardLocalDomRef,
  useTheme,
} from '../../hooks';
import { TextAreaProps } from '../../types/input';
import { getStartingSize } from '../../utils/styleHelpers';
import { Box } from '../Box';
import { ClearValueButton } from '../TextInput/ClearValueButton';
import {
  DEFAULT_TEXT_AREA_ALIGN,
  DEFAULT_TEXT_AREA_SIZE,
  TEXT_AREA_SIZES,
} from './shared';
import {
  baseTextAreaSx,
  clearValueButtonSx,
  containerBaseSx,
  getClearValueButtonSx,
  getContainerSx,
  getResponsiveClearValueButtonSx,
  getResponsiveContainerSx,
  getResponsiveTextAreaSx,
  getTextAreaSx,
} from './styles';

export function TextArea<RC extends ReactElement | undefined = undefined>({
  onClick,
  domRef,
  textAreaRef = { current: null },
  placeholder,
  testId = 'TextArea',
  name,
  id = name,
  children,
  className,
  validationStatus,
  onChange,
  onClearValue,
  value,
  // @NOTE: normally, the ClearValueButton would be a subcomponent, and engineers
  // can choose whether they want it or not. This would mean however, that by default,
  // we have no ClearValueButton. This is not ideal - as design wants inputs to
  // feature this by default. Thus, for now, it is a simple flag instead, and is not
  // a subcomponent.
  hideClearValueButton,
  rc,
  // @NOTE: this would normally be undefined, but then we get react errors
  // around a component switching between controlled and uncontrolled.
  defaultValue = '',
  disabled,
  rows = 5,
  // @NOTE: normally this prop would simply be called "size", but
  // native text input tags already have a property called "size",
  // (The size attribute defines the width of the <input> and the
  // height of the <select> element).
  // Thus we will need to call this property something else,
  // eg "sizeVariant"
  sizeVariant = DEFAULT_TEXT_AREA_SIZE,
  textAlign = DEFAULT_TEXT_AREA_ALIGN,
  sx = {},
  ...inputDomAttributes
}: RC extends undefined ? TextAreaProps : TextAreaProps & { rc: RC }) {
  const localTextAreaRef = useForwardLocalDomRef(textAreaRef);
  const [uncontrolledValue, setUncontrolledValue] = useState<
    ComponentPropsWithoutRef<'textarea'>['value']
  >(
    typeof value === 'number'
      ? value.toString()
      : typeof value === 'string'
      ? value
      : defaultValue,
  );

  const onClearInputText = useCallback(() => {
    // @NOTE: if its a CONTROLLED input, simply call the
    // onClearValue prop, and then early exit
    if (value !== undefined) {
      return onClearValue?.();
    }

    // @NOTE: input is UNCONTROLLED, so we need to manually
    // update it's value:
    if (localTextAreaRef.current) {
      localTextAreaRef.current.value = '';
      localTextAreaRef.current.focus();
    }
    onChange?.({
      type: 'change',
      target: localTextAreaRef?.current,
    } as ChangeEvent<HTMLTextAreaElement>);
    setUncontrolledValue('');
    onClearValue?.();
    return false;
  }, [localTextAreaRef, onChange, value, onClearValue, setUncontrolledValue]);

  const handleInputChange = useCallback(
    (event: ChangeEvent<HTMLTextAreaElement>) => {
      setUncontrolledValue(event.target.value);
      onChange?.(event);
    },
    [setUncontrolledValue, onChange],
  );

  const valueToUse = value ?? uncontrolledValue;
  const theme = useTheme();
  const defaultSize = getStartingSize(
    sizeVariant,
    DEFAULT_TEXT_AREA_SIZE,
    TEXT_AREA_SIZES,
  );
  const allContainerStyles = merge(
    containerBaseSx,
    getContainerSx({
      validationStatus,
      size: defaultSize,
      theme,
      hasValue: Boolean(valueToUse),
    }),
    getResponsiveContainerSx({
      validationStatus,
      size: sizeVariant,
      theme,
      hasValue: Boolean(valueToUse),
    }),
    sx,
  );

  const allInputSx = merge(
    baseTextAreaSx,
    getTextAreaSx({
      textAlign,
      theme,
      size: defaultSize,
    }),
    getResponsiveTextAreaSx({
      textAlign,
      theme,
      size: sizeVariant,
    }),
  );
  const convertedInputStyles = useConvertSxToEmotionStyles(allInputSx);
  const allClearButtonSx = merge(
    clearValueButtonSx,
    getClearValueButtonSx({ theme, size: defaultSize }),
    getResponsiveClearValueButtonSx({ theme, size: sizeVariant }),
  );

  const [focused, setFocused] = useState(false);

  return (
    <ClassNames>
      {({ cx }) => (
        <Box
          rc={rc}
          domRef={domRef}
          className={cx(className, { disabled, focused })}
          testId={testId}
          sx={allContainerStyles}
          data-validation-status={validationStatus}
          onClick={ev => {
            onClick?.(ev);
            localTextAreaRef.current?.focus();
          }}
        >
          <textarea
            {...inputDomAttributes}
            rows={rows}
            disabled={disabled}
            name={name}
            ref={localTextAreaRef}
            data-testid={`${testId}__textarea`}
            onChange={handleInputChange}
            value={valueToUse}
            id={id}
            placeholder={placeholder}
            css={convertedInputStyles}
            onFocus={ev => {
              setFocused(true);
              inputDomAttributes.onFocus?.(ev);
            }}
            onBlur={ev => {
              setFocused(false);
              inputDomAttributes.onBlur?.(ev);
            }}
          />

          <AnimatePresence>
            {valueToUse && !hideClearValueButton && (
              <ClearValueButton
                sx={allClearButtonSx}
                disabled={disabled}
                onClick={onClearInputText}
                testId={`${testId}__clearValueButton`}
              />
            )}
          </AnimatePresence>
        </Box>
      )}
    </ClassNames>
  );
}

TextArea.displayName = 'TextArea';
