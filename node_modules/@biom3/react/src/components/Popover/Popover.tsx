import { useCallback, useEffect, useId, useMemo } from 'react';

import {
  useBrowserEffect,
  useBrowserLayoutEffect,
  useForwardLocalDomRef,
  useGetSubcomponentChild,
} from '../../hooks';
import {
  CLOSE_POPOVER,
  OPEN_POPOVER,
  UPDATE_POPOVER_PROPS,
  useOverlaysStore,
} from '../../providers/BiomeOverlaysProvider';
import { PopoverComponentProps } from '../../types/overlays';
import { SmartClone } from '../SmartClone';
import { PopoverContent } from './PopoverContent';
import { PopoverTarget } from './PopoverTarget';

export function Popover({
  visible,
  id: idProp,
  children,
  position = { x: 'center', y: 'below' },
  domRef = { current: null },
  onOutsideClick,
  verticalGap = 4,
}: PopoverComponentProps) {
  const localDomRef = useForwardLocalDomRef(domRef);
  const fallbackId = useId();
  const id = idProp || fallbackId;
  const target = useGetSubcomponentChild(children, PopoverTarget);
  const content = useGetSubcomponentChild(children, PopoverContent);
  const { state: popoverList, dispatchAction } = useOverlaysStore(
    state => state.popoverList,
  );

  const isControlled = useMemo(() => typeof visible !== 'undefined', [visible]);

  const popoverProps = useMemo(
    () => ({
      id,
      content,
      targetRef: localDomRef,
      position,
      isControlled,
      onOutsideClick,
      verticalGap,
    }),
    [
      content,
      id,
      isControlled,
      localDomRef,
      onOutsideClick,
      position,
      verticalGap,
    ],
  );

  // @NOTE: this useEffect allows the Popover props to stay up to date,
  // as the application re-renders and things potentially change
  useEffect(() => {
    dispatchAction({
      type: UPDATE_POPOVER_PROPS,
      payload: popoverProps,
    });
  }, [dispatchAction, popoverProps]);

  const showPopover = useCallback(() => {
    dispatchAction({
      type: OPEN_POPOVER,
      payload: popoverProps,
    });
  }, [dispatchAction, popoverProps]);

  const hidePopover = useCallback(() => {
    dispatchAction({
      type: CLOSE_POPOVER,
      payload: { id },
    });
  }, [dispatchAction, id]);

  useBrowserLayoutEffect(() => {
    if (visible) {
      showPopover();
    } else if (popoverList.find(popover => popover.id === id)) {
      hidePopover();
    }
    // @NOTE: we want to trigger these changes ONLY when the visible prop changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visible]);

  // @NOTE: when the Popover is unmounted, call to remove it from the modalList
  useBrowserEffect(() => {
    return () => hidePopover();
  }, []);

  const onClickProps = useMemo(() => {
    return !isControlled
      ? {
          onClick: () => {
            if (popoverList.find(popover => popover.id === id)) {
              hidePopover();
            } else {
              showPopover();
            }
          },
        }
      : {};
  }, [popoverList, isControlled, id, hidePopover, showPopover]);

  return target ? (
    <SmartClone {...onClickProps} id={id} domRef={localDomRef}>
      {target}
    </SmartClone>
  ) : null;
}

Popover.displayName = 'Popover';
Popover.Target = PopoverTarget;
Popover.Content = PopoverContent;
