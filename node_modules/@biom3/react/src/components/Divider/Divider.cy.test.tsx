import {
  designTokens,
  onDarkBase,
  onLightBase,
  smartPickTokenValue,
} from '@biom3/design-tokens';

import { hexToRgbString } from '../../utils/colorHelpers';
import { cyMountWithProviders, cySmartGet } from '../../utils/testHelpers';
import { Divider } from './Divider';

describe('<Divider />', () => {
  it('should have correct displayName', () => {
    expect(Divider.displayName).to.eq('Divider');
  });
  it(`should render a div by default, but override that when an 'as' prop is provided`, () => {
    cyMountWithProviders(
      <>
        <Divider testId="default" />
        <Divider testId="asHr" rc={<hr />} />
      </>,
    );

    cySmartGet('default').its('0.nodeName').should('equal', 'DIV');
    cySmartGet('asHr').its('0.nodeName').should('equal', 'HR');
  });

  it('should render as "medium" size, by default', () => {
    cyMountWithProviders(<Divider testId="moo" />);
    cySmartGet('moo')
      .should('have.css', 'font-family')
      .and('match', /Roboto/);

    cySmartGet('moo').should(
      'have.css',
      'font-size',
      smartPickTokenValue(
        designTokens,
        'base.text.body.medium.regular.fontSize',
      ),
    );

    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const height = after.getPropertyValue('height');
        expect(height).to.equal('2px');
      });
    });
  });

  it('should responsively apply the "size" prop, when neccissary', () => {
    cy.viewport(200, 200);
    cyMountWithProviders(
      <Divider testId="moo" size={['xSmall', 'small', 'medium', 'large']}>
        some text
      </Divider>,
    );

    cySmartGet('moo')
      .should('have.css', 'font-family')
      .and('match', /Roboto/);
    cySmartGet('moo').should('have.css', 'text-transform', 'uppercase');
    cySmartGet('moo').should(
      'have.color',
      smartPickTokenValue(designTokens, 'base.color.text.secondary'),
    );
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const height = after.getPropertyValue('height');
        const background = after.getPropertyValue('background-color');
        expect(height).to.equal('1px');

        expect(background).to.equal(
          hexToRgbString(
            smartPickTokenValue(
              designTokens,
              'base.color.translucent.standard.200',
            ),
          ),
        );
      });
    });

    cy.viewport(onLightBase.breakpoint.small, 200);

    cySmartGet('moo')
      .should('have.css', 'font-family')
      .and('match', /Roboto/);
    cySmartGet('moo').should('have.css', 'text-transform', 'uppercase');
    cySmartGet('moo').should(
      'have.color',
      smartPickTokenValue(designTokens, 'base.color.text.primary'),
    );
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const height = after.getPropertyValue('height');
        const background = after.getPropertyValue('background-color');
        expect(height).to.equal('1px');
        expect(background).to.equal(
          hexToRgbString(
            smartPickTokenValue(designTokens, 'base.color.text.primary'),
          ),
        );
      });
    });

    cy.viewport(onLightBase.breakpoint.medium, 200);

    cySmartGet('moo').should('have.css', 'text-transform', 'none');
    cySmartGet('moo')
      .should('have.css', 'font-family')
      .and('match', /Roboto/);
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const height = after.getPropertyValue('height');
        expect(height).to.equal('2px');
      });
    });

    cy.viewport(onLightBase.breakpoint.large, 200);

    cySmartGet('moo').should('have.css', 'text-transform', 'none');
    cySmartGet('moo')
      .should('have.css', 'font-family')
      .and('match', /Suisse-Intl/);
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const height = after.getPropertyValue('height');
        expect(height).to.equal('4px');
      });
    });
  });

  it('should allow sx styles to be passed through from parent', () => {
    cyMountWithProviders(
      <Divider testId="moo" sx={{ marginY: 'base.spacing.x5' }} />,
    );
    cySmartGet('moo').should(
      'have.css',
      'margin-top',
      smartPickTokenValue(designTokens, 'base.spacing.x5'),
    );
    cySmartGet('moo').should(
      'have.css',
      'margin-bottom',
      smartPickTokenValue(designTokens, 'base.spacing.x5'),
    );
  });

  it('should render correctly (with some margin), children are provided', () => {
    cyMountWithProviders(<Divider testId="moo">some text</Divider>);
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const marginLeft = after.getPropertyValue('margin-left');
        expect(marginLeft).to.equal(
          smartPickTokenValue(designTokens, 'base.spacing.x6'),
        );
      });
    });
  });

  it(`should invert it's coloring, based on the current biome theme`, () => {
    cyMountWithProviders(<Divider testId="moo">some text</Divider>, {
      theme: { base: onLightBase },
    });
    cySmartGet('moo').should(
      'have.color',
      smartPickTokenValue({ base: onLightBase }, 'base.color.text.primary'),
    );
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const background = after.getPropertyValue('background-color');
        expect(background).to.equal(
          hexToRgbString(
            smartPickTokenValue(
              { base: onLightBase },
              'base.color.text.primary',
            ),
          ),
        );
      });
    });

    cyMountWithProviders(<Divider testId="moo">some text</Divider>, {
      theme: { base: onDarkBase },
    });
    cySmartGet('moo').should(
      'have.color',
      smartPickTokenValue({ base: onDarkBase }, 'base.color.text.primary'),
    );
    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const background = after.getPropertyValue('background-color');
        expect(background).to.equal(
          hexToRgbString(
            smartPickTokenValue(
              { base: onDarkBase },
              'base.color.text.primary',
            ),
          ),
        );
      });
    });
  });

  it('should render "left" aligned, by default', () => {
    cyMountWithProviders(<Divider testId="moo">some text</Divider>);

    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const width = after.getPropertyValue('width');
        expect(parseFloat(width)).to.be.within(404, 405);
      });
    });
  });

  it('should render "center" aligned, when neccissary', () => {
    cyMountWithProviders(
      <Divider testId="moo" textAlign="center">
        some text
      </Divider>,
    );

    cySmartGet('moo').within($el => {
      cy.window().then(win => {
        const after = win.getComputedStyle($el[0], '::after');
        const before = win.getComputedStyle($el[0], '::before');
        const afterWidth = after.getPropertyValue('width');
        const beforeWidth = before.getPropertyValue('width');
        expect(parseFloat(afterWidth)).to.be.within(190, 191);
        expect(parseFloat(beforeWidth)).to.be.within(190, 191);
      });
    });
  });
});
