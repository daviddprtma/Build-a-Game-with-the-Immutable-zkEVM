import { ClassNames } from '@emotion/react';
import { AnimatePresence } from 'framer-motion';
import {
  ChangeEvent,
  ComponentPropsWithoutRef,
  ReactElement,
  useCallback,
  useRef,
  useState,
} from 'react';
import merge from 'ts-deepmerge';

import {
  useConvertSxToEmotionStyles,
  useForwardLocalDomRef,
  useGetSubcomponentChild,
  useResizeObserver,
  useSplitApartChildrenAndSubComponents,
  useTheme,
} from '../../hooks';
import { TextInputProps } from '../../types/input';
import { getStartingSize } from '../../utils/styleHelpers';
import { Box } from '../Box';
import { SmartClone } from '../SmartClone';
import { Stack } from '../Stack';
import { ClearValueButton } from './ClearValueButton';
import {
  DEFAULT_TEXT_INPUT_ALIGN,
  DEFAULT_TEXT_INPUT_SIZE,
  TEXT_INPUT_SIZES,
} from './shared';
import {
  baseInputSx,
  buttonsContainerSx,
  inputContainerBaseSx,
  leftButtonsContainerSx,
  renderContainerStyles,
  renderInputSx,
  renderResponsiveContainerStyles,
  renderResponsiveInputSx,
  rightButtonsContainerSx,
} from './styles';
import { TextInputAdornment } from './TextInputAdornment';
import { TextInputButton } from './TextInputButton';
import { TextInputFramedImage } from './TextInputFramedImage';
import { TextInputIcon } from './TextInputIcon';
import { TextInputStatefulButtCon } from './TextInputStatefulButtCon';

// @NOTE: when touching the styles inside this component, plz be aware that
// other components compose themselves using them, eg:
// <Select />
// <TextArea />

export function TextInput<RC extends ReactElement | undefined = undefined>({
  domRef,
  inputRef = { current: null },
  rc,
  placeholder,
  sx = {},
  testId = 'TextInput',
  name,
  id = name,
  children,
  className,
  validationStatus,
  onChange,
  onClearValue,
  value,
  // @NOTE: normally, the ClearValueButton would be a subcomponent, and engineers
  // can choose whether they want it or not. This would mean however, that by default,
  // we have no ClearValueButton. This is not ideal - as design wants inputs to
  // feature this by default. Thus, for now, it is a simple flag instead, and is not
  // a subcomponent.
  hideClearValueButton,
  textAlign = DEFAULT_TEXT_INPUT_ALIGN,
  // @NOTE: this would normally be undefined, but then we get react errors
  // around a component switching between controlled and uncontrolled.
  defaultValue = '',
  // @NOTE: normally this prop would simply be called "size", but
  // native text input tags already have a property called "size",
  // (The size attribute defines the width of the <input> and the
  // height of the <select> element).
  // Thus we will need to call this property something else,
  // eg "sizeVariant"
  sizeVariant = DEFAULT_TEXT_INPUT_SIZE,
  disabled,
  ...inputDomAttributes
}: RC extends undefined ? TextInputProps : TextInputProps & { rc: RC }) {
  const localInputRef = useForwardLocalDomRef(inputRef);
  const [uncontrolledValue, setUncontrolledValue] = useState<
    ComponentPropsWithoutRef<'input'>['value']
  >(
    typeof value === 'number'
      ? value.toString()
      : typeof value === 'string'
      ? value
      : defaultValue,
  );

  const button = useGetSubcomponentChild(children, TextInputButton);
  const buttCon = useGetSubcomponentChild(children, TextInputStatefulButtCon);
  const icon = useGetSubcomponentChild(children, TextInputIcon);
  const framedImage = useGetSubcomponentChild(children, TextInputFramedImage);
  const adornment = useGetSubcomponentChild(children, TextInputAdornment);
  const { otherChildren } = useSplitApartChildrenAndSubComponents(children, [
    TextInputButton,
    TextInputStatefulButtCon,
    TextInputIcon,
    TextInputFramedImage,
    TextInputAdornment,
  ]);

  const rightHandButtonsContainerRef = useRef<HTMLDivElement>(null);
  const leftHandButtonsContainerRef = useRef<HTMLDivElement>(null);
  const { width: rightHandButtonsContainerWidth } = useResizeObserver(
    rightHandButtonsContainerRef,
    30,
  );
  const { width: leftHandButtonsContainerWidth } = useResizeObserver(
    leftHandButtonsContainerRef,
    30,
  );

  const onClearInputText = useCallback(() => {
    // @NOTE: if its a CONTROLLED input, simply call the
    // onClearValue prop, and then early exit
    if (value !== undefined) {
      return onClearValue?.();
    }

    // @NOTE: input is UNCONTROLLED, so we need to manually
    // update it's value:
    if (localInputRef.current) {
      localInputRef.current.value = '';
      localInputRef.current.focus();
    }
    onChange?.({
      type: 'change',
      target: localInputRef?.current,
    } as ChangeEvent<HTMLInputElement>);
    setUncontrolledValue('');
    onClearValue?.();
    return false;
  }, [localInputRef, onChange, value, onClearValue, setUncontrolledValue]);

  const handleInputChange = useCallback(
    (event: ChangeEvent<HTMLInputElement>) => {
      setUncontrolledValue(event.target.value);
      onChange?.(event);
    },
    [setUncontrolledValue, onChange],
  );

  const theme = useTheme();
  const defaultSize = getStartingSize(
    sizeVariant,
    DEFAULT_TEXT_INPUT_SIZE,
    TEXT_INPUT_SIZES,
  );
  const allContainerStyles = merge(
    inputContainerBaseSx,
    renderContainerStyles({ size: defaultSize, theme }),
    renderResponsiveContainerStyles({
      size: sizeVariant,
      theme,
    }),
    sx,
  );
  const valueToUse = value ?? uncontrolledValue;
  const allInputSx = merge(
    baseInputSx,
    renderInputSx({
      theme,
      validationStatus,
      leftHandButtonsWidth: leftHandButtonsContainerWidth,
      rightHandButtonsWidth: rightHandButtonsContainerWidth,
      textAlign,
      hasValue: Boolean(valueToUse),
    }),
    renderResponsiveInputSx({
      theme,
      validationStatus,
      size: sizeVariant,
      leftHandButtonsWidth: leftHandButtonsContainerWidth,
      rightHandButtonsWidth: rightHandButtonsContainerWidth,
      textAlign,
      hasValue: Boolean(valueToUse),
    }),
  );
  const convertedInputStyles = useConvertSxToEmotionStyles(allInputSx);
  const hasLeftHandItems =
    framedImage || icon || (textAlign === 'left' && Boolean(adornment));

  return (
    <ClassNames>
      {({ cx }) => (
        <Box
          rc={rc}
          domRef={domRef}
          className={cx(className, { disabled })}
          testId={testId}
          sx={allContainerStyles}
          data-validation-status={validationStatus}
        >
          <input
            {...inputDomAttributes}
            disabled={disabled}
            name={name}
            ref={localInputRef}
            data-testid={`${testId}__input`}
            onChange={handleInputChange}
            value={valueToUse}
            id={id}
            placeholder={placeholder}
            css={convertedInputStyles}
          />

          {hasLeftHandItems && (
            <Stack
              direction="row"
              alignItems="center"
              sx={merge(leftButtonsContainerSx, buttonsContainerSx)}
              domRef={leftHandButtonsContainerRef}
            >
              {framedImage || icon || null}
              {textAlign === 'left' && adornment ? (
                <SmartClone
                  testId={adornment?.props?.testId || `${testId}__adornment`}
                >
                  {adornment}
                </SmartClone>
              ) : null}
            </Stack>
          )}

          <Stack
            alignItems="center"
            direction="row"
            sx={merge(rightButtonsContainerSx, buttonsContainerSx)}
            testId={`${testId}__rightButtonsContainer`}
            domRef={rightHandButtonsContainerRef}
          >
            {textAlign === 'right' && Boolean(adornment) ? (
              <SmartClone
                testId={adornment?.props?.testId || `${testId}__adornment`}
              >
                {adornment}
              </SmartClone>
            ) : null}

            <AnimatePresence>
              {valueToUse && !hideClearValueButton && (
                <ClearValueButton
                  disabled={disabled}
                  onClick={onClearInputText}
                  testId={`${testId}__rightButtonsContainer__clearValueButton`}
                />
              )}
            </AnimatePresence>

            {button && (
              <SmartClone
                disabled={disabled}
                currentInputValue={valueToUse}
                testId={
                  button.props.testId ??
                  `${testId}__rightButtonsContainer__rightButton`
                }
              >
                {button}
              </SmartClone>
            )}
            {buttCon && (
              <SmartClone
                disabled={disabled}
                currentInputValue={valueToUse}
                testId={
                  buttCon.props.testId ??
                  `${testId}__rightButtonsContainer__rightButtCon`
                }
              >
                {buttCon}
              </SmartClone>
            )}
          </Stack>

          {otherChildren}
        </Box>
      )}
    </ClassNames>
  );
}

TextInput.displayName = 'TextInput';
TextInput.Button = TextInputButton;
TextInput.Icon = TextInputIcon;
TextInput.FramedImage = TextInputFramedImage;
TextInput.StatefulButtCon = TextInputStatefulButtCon;
TextInput.Adornment = TextInputAdornment;
