/* eslint-disable react/destructuring-assignment */
import { motion } from 'framer-motion';
import debounce from 'lodash.debounce';
import {
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import merge from 'ts-deepmerge';

import { DEFAULT_BODY_COLOR } from '../../components/Text/Body/shared';
import { recursivelyAddTooltipAttrsToChildNodes } from '../../components/Tooltip/shared';
import {
  useConvertSxToEmotionStyles,
  useEventListener,
  useTheme,
} from '../../hooks';
import { useTooltipStore } from '../../providers';
import { BiomeShadowRootContext } from '../../providers/BiomeShadowRootProvider';
import { DEFAULT_TOOLTIP_SIZE, TOOLTIP_SIZES, TooltipItem } from '../../types';
import { isTouchDevice } from '../../utils/deviceHelpers';
import {
  getSafeCenterHorizontalPosition,
  getSafeTopVerticalPosition,
} from '../../utils/positionHelpers';
import {
  getStartingSize,
  setDefaultSxTextColor,
} from '../../utils/styleHelpers';
import { getBodyTextStyles } from '../../utils/textStyleHelpers';
import {
  baseContainerSx,
  getContainerStyles,
  responsiveContainerStyles,
} from './styles';

const getBoundingRect = (element: Element) => element.getBoundingClientRect();
const LEAVE_DELAY = 55;

export function TooltipOverlay() {
  const shadowRoot = useContext(BiomeShadowRootContext);
  const containerElementRef = useRef<ShadowRoot | HTMLElement>(
    shadowRoot || document.body,
  );
  const theme = useTheme();
  const baseContainerStyles = useConvertSxToEmotionStyles(
    merge(setDefaultSxTextColor({}, DEFAULT_BODY_COLOR), baseContainerSx),
  );
  const hoverLeaveTimer = useRef<number>();
  const currentTooltipBubbleRef = useRef<HTMLDivElement>(null);
  const animatedTooltipBubbleRef = useRef<HTMLDivElement>(null);
  const { state: tooltipList } = useTooltipStore(state => state.tooltipList);
  const [currentTooltip, setCurrentTooltip] = useState<TooltipItem | undefined>(
    undefined,
  );
  const [currentTooltipTargetRect, setCurrentTooltipTargetRect] = useState<
    DOMRect | undefined
  >(undefined);
  const [currentTooltipBubbleRect, setCurrentTooltipBubbleRect] = useState<
    DOMRect | undefined
  >(undefined);

  const calculatedPosition = useMemo(() => {
    if (
      !currentTooltipTargetRect ||
      !currentTooltipBubbleRect ||
      !currentTooltip
    ) {
      return {
        left: 0,
        top: 0,
      };
    }

    const left = getSafeCenterHorizontalPosition(
      currentTooltipTargetRect,
      currentTooltipBubbleRect,
    );
    const top = getSafeTopVerticalPosition(
      currentTooltipTargetRect,
      currentTooltipBubbleRect,
      16,
    );

    return { left, top };
  }, [currentTooltip, currentTooltipBubbleRect, currentTooltipTargetRect]);

  const onDocumentBodyClick = useCallback(
    (event: MouseEvent) => {
      if (isTouchDevice() && tooltipList.length > 0) {
        const clickedElement = event.target as HTMLElement;
        const clickedTooptiptId =
          clickedElement.getAttribute('data-tooltip-id');
        const isTooltipTarget =
          clickedElement.getAttribute('data-tooltip-target') === 'true';
        const clickingOnACurrentlyOpenTooltip =
          clickedTooptiptId === currentTooltip?.id;

        if (!isTooltipTarget && clickingOnACurrentlyOpenTooltip) {
          // @NOTE: If we're clicking on a tooltip bubble element, then do nothing
          // (allows user to select things inside of a tooltip)
          return false;
        }

        if (isTooltipTarget && clickingOnACurrentlyOpenTooltip) {
          // @NOTE: If the target is clicked again and the tooltip is already open, toggle it closed
          setCurrentTooltip(undefined);
        } else if (clickedTooptiptId !== currentTooltip?.id) {
          // @NOTE: Else If the tooltip id of the clicked element is different to the
          // current tooltip, open a new one
          setCurrentTooltip(
            tooltipList.find(tooltip => tooltip.id === clickedTooptiptId),
          );
        } else {
          // @NOTE: Else we're not clicking atop a tooltip, so just close any open tooltip
          setCurrentTooltip(undefined);
        }
        return false;
      }

      return false;
    },
    [tooltipList, currentTooltip],
  );

  const clearCurrentTooltipData = useCallback(() => {
    setCurrentTooltip(undefined);
    setCurrentTooltipTargetRect(undefined);
    setCurrentTooltipBubbleRect(undefined);
  }, []);

  const handleHoverStart = useCallback(
    (hoveredTooptipTargetId: string) => {
      clearTimeout(hoverLeaveTimer.current);
      if (hoveredTooptipTargetId !== currentTooltip?.id) {
        const newTooltip = tooltipList.find(
          tooltip => tooltip.id === hoveredTooptipTargetId,
        );
        setCurrentTooltip(newTooltip);
      }
    },
    [tooltipList, currentTooltip],
  );

  const handleHoverTooltipClose = useCallback(() => {
    clearTimeout(hoverLeaveTimer.current);
    if (currentTooltip) {
      clearCurrentTooltipData();
    }
  }, [currentTooltip, clearCurrentTooltipData]);

  const handleHoverStop = useCallback(() => {
    clearTimeout(hoverLeaveTimer.current);
    hoverLeaveTimer.current = window.setTimeout(() => {
      handleHoverTooltipClose();
    }, LEAVE_DELAY);
  }, [handleHoverTooltipClose]);

  const onMouseMove = useCallback(
    (event: MouseEvent) => {
      if (!isTouchDevice() && tooltipList.length > 0) {
        const hoveredElement = event.target as HTMLElement;
        const hoveredTooptipTargetId =
          hoveredElement?.getAttribute('data-tooltip-id');
        if (hoveredTooptipTargetId) {
          handleHoverStart(hoveredTooptipTargetId);
        } else {
          handleHoverStop();
        }

        return false;
      }

      return false;
    },
    [tooltipList.length, handleHoverStart, handleHoverStop],
  );

  useEventListener('mousemove', onMouseMove, containerElementRef);
  useEventListener('click', onDocumentBodyClick, containerElementRef);

  const onResizeAndScroll = useCallback(() => {
    if (currentTooltip) {
      clearCurrentTooltipData();
    }
  }, [currentTooltip, clearCurrentTooltipData]);
  const debouncedOnResizeAndOnScroll = debounce(onResizeAndScroll, 300, {
    leading: true,
  });
  useEventListener('scroll', debouncedOnResizeAndOnScroll, containerElementRef);
  useEventListener('resize', debouncedOnResizeAndOnScroll, containerElementRef);

  useEffect(() => {
    if (shadowRoot) {
      containerElementRef.current = shadowRoot;
    }
  }, [shadowRoot]);
  useEffect(() => {
    if (currentTooltip) {
      const target = shadowRoot
        ? shadowRoot.querySelector(`[data-tooltip-id="${currentTooltip.id}"]`)
        : document.body.querySelector(
            `[data-tooltip-id="${currentTooltip.id}"]`,
          );
      if (target) {
        setCurrentTooltipTargetRect(getBoundingRect(target));
      } else {
        setCurrentTooltipTargetRect(undefined);
      }

      recursivelyAddTooltipAttrsToChildNodes(
        animatedTooltipBubbleRef.current,
        currentTooltip.id,
      );
    } else {
      setCurrentTooltipTargetRect(undefined);
    }
  }, [currentTooltip, shadowRoot]);

  useEffect(() => {
    if (!currentTooltipBubbleRef.current) return;
    setCurrentTooltipBubbleRect(
      getBoundingRect(currentTooltipBubbleRef.current),
    );
  }, [currentTooltipTargetRect, currentTooltipBubbleRef]);

  // @NOTE: if there is no current tooltips open, simply return null
  if (!currentTooltip) return null;

  const startingSize = getStartingSize(
    currentTooltip?.size,
    DEFAULT_TOOLTIP_SIZE,
    TOOLTIP_SIZES,
  );

  const allContainerStyles = merge(
    baseContainerStyles,
    getBodyTextStyles({
      size: 'small',
      mono: false,
      themeProps: theme,
      weight: 'regular',
    }),
    getContainerStyles({ size: startingSize, theme }),
    responsiveContainerStyles({ size: currentTooltip?.size, theme }),
    { top: calculatedPosition.top, left: calculatedPosition.left },
  );

  return (
    <>
      {/* 
      @NOTE: sometimes the left + animation props can have a weird impact
      on the dimensions / layout of rendered tooltip bubble.
      To combat this, we can render a hidden version of it on the page. 
      This version is the one we will use for more accurate measurements etc.
     */}
      <div
        ref={currentTooltipBubbleRef}
        css={merge(allContainerStyles, {
          top: '0',
          left: '0',
          opacity: 0,
          pointerEvents: 'none',
        })}
      >
        {currentTooltip.content}
      </div>
      <motion.div
        ref={animatedTooltipBubbleRef}
        data-tooltip-id={currentTooltip.id}
        data-testid="tooltip__container"
        initial={{
          opacity: 0,
          y: '-8%',
        }}
        animate={{
          opacity: 1,
          y: '0%',
        }}
        transition={{
          duration: theme.base.motion.normal.fast.jsDuration,
          ease: theme.base.motion.normal.fast.jsEase,
        }}
        key={currentTooltip.id}
        css={allContainerStyles}
      >
        {currentTooltip.content}
      </motion.div>
    </>
  );
}
